<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":true,"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="欢迎来到我的虚幻个人博客，不定期更新">
<meta property="og:type" content="website">
<meta property="og:title" content="Zoomi的虚幻世界">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Zoomi的虚幻世界">
<meta property="og:description" content="欢迎来到我的虚幻个人博客，不定期更新">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zoomi">
<meta property="article:tag" content="Unreal Engine, 游戏开发, 编程, 技术, 博客">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Zoomi的虚幻世界</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <link rel="stylesheet" href="/css/win11-dark.css">
  <!-- APlayer CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
  <!-- MetingJS -->
  <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
  <!-- APlayer JS -->
  <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<link rel="alternate" href="/atom.xml" title="Zoomi的虚幻世界" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zoomi的虚幻世界</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我的邮箱:LFF3216689784@outlook.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>目录</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
  <!-- 主页弹窗提示 -->
  <script>
    window.addEventListener('DOMContentLoaded', function() {
      if (!sessionStorage.getItem('ue5_tip_shown')) {
        var tip = document.createElement('div');
        tip.innerHTML = '<div id="ue5-tip-mask" style="position:fixed;z-index:9999;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.18);display:flex;align-items:center;justify-content:center;">'+
          '<div style="background:#fff;padding:32px 38px 24px 38px;border-radius:14px;box-shadow:0 4px 28px #0003;max-width:90vw;text-align:center;font-size:18px;line-height:2;">'+
          '如需查阅我的个人学习文档请点击<b style="color:#409EFF;">目录</b>，感谢您的支持😀<br><button id="ue5-tip-btn" style="margin-top:18px;padding:6px 22px;background:#409EFF;color:#fff;border:none;border-radius:8px;font-size:16px;cursor:pointer;">知道了</button></div></div>';
        document.body.appendChild(tip);
        document.getElementById('ue5-tip-btn').onclick = function() {
          tip.remove();
          sessionStorage.setItem('ue5_tip_shown', '1');
        };
        document.getElementById('ue5-tip-mask').onclick = function(e) {
          if (e.target === this) {
            tip.remove();
            sessionStorage.setItem('ue5_tip_shown', '1');
          }
        };
      }
    });
  </script>

  <!-- UE5 推荐学习网站 -->
  <div class="ue5-recommend-wrap" style="max-width:900px;margin:40px auto 24px auto;padding:36px 28px 28px 28px;background:#fff;border-radius:16px;box-shadow:0 4px 24px #0002;">
    <h2 style="color:#409EFF;text-align:center;margin-bottom:18px;">虚幻5引擎推荐学习网站</h2>
    <ul style="font-size:17px;line-height:2;">
      <li><a href="https://docs.unrealengine.com/5.0/zh-CN/" target="_blank" style="color:#2563eb;">Unreal Engine 5 官方文档（中文）</a></li>
      <li><a href="https://www.unrealengine.com/marketplace/zh-CN/store" target="_blank" style="color:#2563eb;">UE5 官方商城</a></li>
      <li><a href="https://learn.unrealengine.com/home" target="_blank" style="color:#2563eb;">Unreal Online Learning（英文官方教程）</a></li>
      <li><a href="https://bilibili.com" target="_blank" style="color:#2563eb;">B站 UE5 高质量教程合集</a></li>
      <li><a href="https://www.youtube.com/c/UnrealEngine" target="_blank" style="color:#2563eb;">YouTube Unreal Engine 官方频道</a></li>
      <li><a href="https://forums.unrealengine.com/" target="_blank" style="color:#2563eb;">Unreal Engine 官方论坛</a></li>
      <li><a href="https://www.zhihu.com/topic/20727423/hot" target="_blank" style="color:#2563eb;">知乎 UE5 热门问答</a></li>
      <li><a href="https://github.com/EpicGames/UnrealEngine" target="_blank" style="color:#2563eb;">Unreal Engine GitHub 源码</a></li>
    </ul>
    <div style="text-align:center;color:#888;font-size:14px;margin-top:12px;">持续补充更多优质学习资源，欢迎留言推荐！</div>
  </div>

  <!-- 渲染文章列表 -->
  
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/22/GAS%E7%B3%BB%E7%BB%9FAPI%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-by_Zoomi_%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E6%88%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zoomi">
      <meta itemprop="description" content="欢迎来到我的虚幻个人博客，不定期更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zoomi的虚幻世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/22/GAS%E7%B3%BB%E7%BB%9FAPI%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-by_Zoomi_%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E6%88%91/" class="post-title-link" itemprop="url">GAS系统API百科全书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-22 22:00:54 / 修改时间：22:01:04" itemprop="dateCreated datePublished" datetime="2025-04-22T22:00:54+08:00">2025-04-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">虚幻引擎</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">游戏开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAS系统简介-什么是GAS系统"><a href="#GAS系统简介-什么是GAS系统" class="headerlink" title="GAS系统简介-什么是GAS系统"></a>GAS系统简介-什么是GAS系统</h1><p><strong>GAS​</strong>​ 即 ​<strong>​Gameplay Ability System​</strong>​（游戏玩法能力系统），是 ​<strong>​Epic Games​</strong>​ 在 ​<strong>​Unreal Engine（虚幻引擎）​</strong>​ 中开发的一套功能强大且灵活的框架，用于管理和实现复杂的游戏玩法机制。​</p>
<h3 id="GAS-的核心组件"><a href="#GAS-的核心组件" class="headerlink" title="GAS 的核心组件"></a>GAS 的核心组件</h3><p>GAS 主要由以下三个核心组件构成：</p>
<ol>
<li><p>​<strong>​Ability System Component (ASC)​</strong>​:</p>
<ul>
<li>​<strong>​作用​</strong>​：作为 GAS 的核心，ASC 负责管理角色的能力、属性和效果。每个拥有 GAS 的角色通常都有一个 ASC 实例。</li>
<li>​<strong>​功能​</strong>​：<ul>
<li>管理和激活能力（Abilities）。</li>
<li>处理属性（Attributes）的增减和查询。</li>
<li>应用和管理效果（Effects），如增益、减益、伤害等。</li>
<li>提供输入绑定和能力激活的接口。</li>
</ul>
</li>
</ul>
</li>
<li><p>​<strong>​Abilities（能力）​</strong>​:</p>
<ul>
<li>​<strong>​定义​</strong>​：能力代表角色可以执行的特定动作或行为，如攻击、跳跃、治疗等。</li>
<li>​<strong>​实现​</strong>​：通过继承 <code>UGameplayAbility</code> 类来创建自定义能力，定义能力的激活条件、执行逻辑和冷却时间等。</li>
</ul>
</li>
<li><p>​<strong>​Attributes（属性）​</strong>​:</p>
<ul>
<li>​<strong>​定义​</strong>​：属性代表角色的各种数值特征，如生命值、法力值、攻击力等。</li>
<li>​<strong>​实现​</strong>​：通过继承 <code>UAttributeSet</code> 类来创建自定义属性集，定义角色的基础属性和衍生属性。</li>
</ul>
</li>
<li><p>​<strong>​Effects（效果）​</strong>​:</p>
<ul>
<li>​<strong>​定义​</strong>​：效果用于修改角色的属性或状态，如增加攻击力、减少移动速度、施加中毒效果等。</li>
<li>​<strong>​实现​</strong>​：通过创建 <code>GameplayEffect</code> 子类来定义各种效果，设置效果的类型、持续时间、数值变化等。</li>
</ul>
</li>
</ol>
<h3 id="GAS-的优势与使用步骤"><a href="#GAS-的优势与使用步骤" class="headerlink" title="GAS 的优势与使用步骤"></a>GAS 的优势与使用步骤</h3><ul>
<li>​<strong>​模块化设计​</strong>​：GAS 将能力、属性和效果分离，使得系统更加清晰和易于维护。</li>
<li>​<strong>​高度可扩展​</strong>​：开发者可以根据项目需求自定义能力、属性和效果，满足各种复杂的游戏玩法需求。</li>
<li>​<strong>​灵活的激活机制​</strong>​：支持基于输入、状态或其他条件的能力激活，适应不同的游戏设计模式。</li>
<li>​<strong>​网络同步​</strong>​：内置的网络同步机制，确保在多人游戏中能力、属性和效果的一致性和实时性。</li>
<li>​<strong>​可视化编辑​</strong>​：通过蓝图系统，开发者可以在编辑器中直观地配置和调试 GAS 组件，提高开发效率。</li>
<li><h3 id="如何在项目中启用-GAS"><a href="#如何在项目中启用-GAS" class="headerlink" title="如何在项目中启用 GAS"></a>如何在项目中启用 GAS</h3></li>
</ul>
<ol>
<li><p>​<strong>​启用 GAS 插件​</strong>​：</p>
<ul>
<li>在 Unreal Engine 编辑器中，导航到 <code>编辑</code> &gt; <code>插件</code>。</li>
<li>搜索并启用 <code>Gameplay Ability System</code> 插件。</li>
<li>重启编辑器以应用更改。</li>
</ul>
</li>
<li><p>​<strong>​创建 Ability System Component (ASC)​</strong>​：</p>
<ul>
<li>在角色类中添加一个 <code>UAbilitySystemComponent</code> 类型的成员变量。</li>
<li>初始化并绑定 ASC 到角色。</li>
</ul>
</li>
<li><p>​<strong>​定义 Attributes​</strong>​：</p>
<ul>
<li>创建继承自 <code>UAttributeSet</code> 的自定义属性集类。</li>
<li>定义所需的属性，如生命值、法力值等。</li>
</ul>
</li>
<li><p>​<strong>​创建 Abilities​</strong>​：</p>
<ul>
<li>创建继承自 <code>UGameplayAbility</code> 的自定义能力类。</li>
<li>实现能力的激活逻辑、执行过程和冷却机制。</li>
</ul>
</li>
<li><p>​<strong>​配置 Effects​</strong>​：</p>
<ul>
<li>创建继承自 <code>UGameplayEffect</code> 的自定义效果类。</li>
<li>定义效果的类型、数值变化和应用逻辑。</li>
</ul>
</li>
<li><p>​<strong>​绑定输入和激活能力​</strong>​：</p>
<ul>
<li>在角色或控制器中绑定输入事件，调用 ASC 的能力激活函数。</li>
<li>根据游戏逻辑决定何时激活特定能力。</li>
</ul>
</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的示例，展示如何在角色类中初始化 GAS 组件并激活一个能力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYGAME_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IAbilitySystemInterface 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// ASC 实例</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Abilities&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UAbilitySystemComponent</span>* AbilitySystemComponent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 激活特定能力</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityHandle)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAbilitySet.h&quot;</span> <span class="comment">// 自定义属性集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameplayAbility.h&quot;</span> <span class="comment">// 自定义能力</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建并附加 ASC</span></span><br><span class="line">    AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilitySystemComponent&quot;</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">AMyCharacter::GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AbilitySystemComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化属性集</span></span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载并赋予基础能力（假设在蓝图中配置）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent &amp;&amp; NewController)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以在这里根据控制器类型进行额外的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::ActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">TryActivateAbility</span>(AbilityHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="API百科"><a href="#API百科" class="headerlink" title="API百科"></a>API百科</h1><h2 id="virtual-void-UAibilitySystemComponent-InitAbilityActorInfo-AActor-InOwnerActor-AActor-InAvatarActor-函数说明"><a href="#virtual-void-UAibilitySystemComponent-InitAbilityActorInfo-AActor-InOwnerActor-AActor-InAvatarActor-函数说明" class="headerlink" title="virtual void UAibilitySystemComponent::InitAbilityActorInfo(AActor *InOwnerActor, AActor *InAvatarActor) 函数说明"></a><code>virtual void UAibilitySystemComponent::InitAbilityActorInfo(AActor *InOwnerActor, AActor *InAvatarActor)</code> 函数说明</h2><ul>
<li>​<strong>​功能​</strong>​：初始化能力的 Actor 信息——用于保存关于我们作用于谁以及谁控制我们的信息的结构体。</li>
<li>​<strong>​参数​</strong>​：<ul>
<li><code>InOwnerActor</code>：从逻辑上拥有此组件的 Actor。</li>
<li><code>InAvatarActor</code>：我们在世界中实际作用的物理 Actor。通常是 Pawn，但也可能是 Tower、Building、Turret 等，可能与 <code>InOwnerActor</code> 是同一个对象。</li>
</ul>
</li>
</ul>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>在虚幻引擎的 Gameplay Ability System（GAS）中，这个函数起着关键作用。它确保了能力系统能够正确识别和管理与角色相关的 Actor 信息。<code>OwnerActor</code> 帮助确定逻辑上的所属关系，而 <code>InAvatarActor</code> 则明确了实际进行交互操作的对象，这对于能力的触发、效果应用等方面都非常重要。</p>
<h3 id="示例代码（假设在自定义组件中调用该函数进行初始化）"><a href="#示例代码（假设在自定义组件中调用该函数进行初始化）" class="headerlink" title="示例代码（假设在自定义组件中调用该函数进行初始化）"></a>示例代码（假设在自定义组件中调用该函数进行初始化）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设在某个自定义组件类中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/ActorComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAbilitySystemComponent.h&quot;</span> <span class="comment">// 引入你的 Ability System Component 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCustomComponent.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> UMyCustomComponent : <span class="keyword">public</span> UActorComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Sets default values for this component&#x27;s properties</span></span><br><span class="line">    <span class="built_in">UMyCustomComponent</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Called when the game starts</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;AbilitySystem&quot;</span>)</span><br><span class="line">    UAbilitySystemComponent* AbilitySystemComp; <span class="comment">// 假设你有一个 Ability System Component 成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Actors&quot;</span>)</span><br><span class="line">    AActor* OwnerActor; <span class="comment">// 可以设置逻辑拥有者 Actor</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Actors&quot;</span>)</span><br><span class="line">    AActor* AvatarActor; <span class="comment">// 可以设置实际作用的 Actor</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 其他私有成员变量和函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 BeginPlay 函数，在其中调用 InitAbilityActorInfo 进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyCustomComponent::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComp &amp;&amp; OwnerActor &amp;&amp; AvatarActor)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComp-&gt;<span class="built_in">InitAbilityActorInfo</span>(OwnerActor, AvatarActor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景说明"><a href="#使用场景说明" class="headerlink" title="使用场景说明"></a>使用场景说明</h3><p>在游戏开发中，当你需要使用 GAS 来管理角色的能力时，通常会在角色或相关组件的初始化阶段调用 <code>InitAbilityActorInfo</code> 函数。例如，在角色生成时，或者在自定义组件初始化时，确保 GAS 能够正确关联到对应的 Actor 信息，以便后续进行能力的激活、效果的管理等操作。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>确保 <code>AbilitySystemComp</code>、<code>OwnerActor</code> 和 <code>AvatarActor</code> 在调用函数时都已经正确初始化且不为空，否则可能会导致运行时错误。</li>
<li>根据实际游戏逻辑，合理设置 <code>OwnerActor</code> 和 <code>AvatarActor</code> 的值，以准确反映角色之间的所属和交互关系。</li>
<li>如果在多人联机环境下，要注意这些 Actor 信息的同步问题，确保客户端和服务器端的一致性。</li>
</ul>
<h2 id="PossessedBy-AController-NewController-函数详解"><a href="#PossessedBy-AController-NewController-函数详解" class="headerlink" title="PossessedBy(AController* NewController) 函数详解"></a><code>PossessedBy(AController* NewController)</code> 函数详解</h2><h4 id="核心内容分析"><a href="#核心内容分析" class="headerlink" title="核心内容分析"></a>核心内容分析</h4><p><code>PossessedBy(AController* NewController)</code> 是 Unreal Engine（虚幻引擎）中 <code>ACharacter</code> 类的一个重要虚函数，用于处理控制器（Controller）拥有（Possess）角色（Character）时的逻辑。在游戏开发中，控制器负责管理玩家的输入或 AI 的决策，而角色则是游戏中实际执行动作的实体。当控制器拥有一个角色时，<code>PossessedBy</code> 函数会被调用，允许开发者在角色被控制时进行必要的初始化和设置。</p>
<h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>​<strong>​<code>PossessedBy</code>​</strong>​: 虚函数，用于响应控制器拥有角色的事件。</li>
<li>​<strong>​<code>AController* NewController</code>​</strong>​: 指向新拥有该角色的控制器的指针。</li>
</ul>
<h4 id="在-GAS-中的作用"><a href="#在-GAS-中的作用" class="headerlink" title="在 GAS 中的作用"></a>在 GAS 中的作用</h4><p>在 ​<strong>​Gameplay Ability System (GAS)​</strong>​ 中，<code>PossessedBy</code> 函数的作用尤为重要，因为它涉及到 ​<strong>​Ability System Component (ASC)​</strong>​ 的初始化和管理。ASC 是 GAS 的核心组件，负责管理角色的能力（Abilities）、属性（Attributes）和效果（Effects）。当控制器拥有角色时，需要确保 ASC 能够正确地与控制器关联，并进行必要的初始化操作。</p>
<h4 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h4><ol>
<li><p>​<strong>​初始化 Ability System Component (ASC)​</strong>​:<br> 当控制器拥有一个角色时，通常需要确保该角色的 ASC 被正确初始化。这包括绑定与控制器相关的输入、设置默认的游戏玩法标签（Gameplay Tags）等。</p>
</li>
<li><p>​<strong>​绑定输入和能力激活​</strong>​:<br> 控制器可能负责处理玩家的输入，这些输入用于激活角色的能力。通过在 <code>PossessedBy</code> 中设置适当的绑定，可以确保当控制器发出指令时，ASC 能够正确响应并激活相应的能力。</p>
</li>
<li><p>​<strong>​管理游戏玩法标签和效果​</strong>​:<br> 控制器的拥有关系变化可能会影响角色的游戏玩法标签或应用的效果。例如，当 AI 控制器拥有角色时，可能需要应用特定的效果或标签，以反映 AI 的行为模式。</p>
</li>
</ol>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个示例，展示如何在自定义的 Character 类中重写 <code>PossessedBy</code> 函数，并在其中初始化 GAS 相关的逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYGAME_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IAbilitySystemInterface 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// ASC 实例</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Abilities&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UMyAbilitySystemComponent</span>* AbilitySystemComponent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnPossess</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 可选：处理控制器失去控制的情况</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAbilitySystemComponent.h&quot;</span> <span class="comment">// 假设你有一个自定义的 ASC 类</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建并附加 ASC</span></span><br><span class="line">    AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UMyAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilitySystemComponent&quot;</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">AMyCharacter::GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AbilitySystemComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent &amp;&amp; NewController)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化 ASC，例如绑定输入、设置默认标签等</span></span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有玩家控制器，可以进一步初始化与玩家相关的内容</span></span><br><span class="line">        APlayerController* PlayerController = <span class="built_in">Cast</span>&lt;APlayerController&gt;(NewController);</span><br><span class="line">        <span class="keyword">if</span> (PlayerController)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 例如，绑定输入映射</span></span><br><span class="line">            <span class="comment">// AbilitySystemComponent-&gt;BindToInput(PlayerController);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 激活默认能力（如果需要）</span></span><br><span class="line">        <span class="comment">// AbilitySystemComponent-&gt;ActivateAbility(FGameplayAbilitySpecHandle());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::UnPossess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">UnPossess</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清理与控制器相关的逻辑，例如清除输入绑定、重置状态等</span></span><br><span class="line">        <span class="comment">// AbilitySystemComponent-&gt;ClearBindings();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键步骤解释"><a href="#关键步骤解释" class="headerlink" title="关键步骤解释"></a>关键步骤解释</h4><ol>
<li><p>​<strong>​调用父类函数​</strong>​:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Super::<span class="built_in">PossessedBy</span>(NewController);</span><br></pre></td></tr></table></figure>
<p> 确保基类的 <code>PossessedBy</code> 逻辑被执行，以处理默认的拥有行为。</p>
</li>
<li><p>​<strong>​初始化 ASC​</strong>​:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p> 这一步将角色和控制器信息绑定到 ASC，使其能够正确管理角色的能力和属性。</p>
</li>
<li><p>​<strong>​处理特定类型的控制器​</strong>​:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">APlayerController* PlayerController = <span class="built_in">Cast</span>&lt;APlayerController&gt;(NewController);</span><br><span class="line"><span class="keyword">if</span> (PlayerController)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 绑定输入或其他玩家特定逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 根据控制器的类型（玩家控制器或 AI 控制器），执行不同的初始化逻辑。</p>
</li>
<li><p>​<strong>​激活默认能力​</strong>​:<br> 根据需要，可以在控制器拥有角色时激活某些默认的能力，确保角色在拥有后立即具备所需的行为。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbilitySystemComponent-&gt;ActivateAbility(FGameplayAbilitySpecHandle());</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>​<strong>​处理失去控制的情况​</strong>​（可选）:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::UnPossess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">UnPossess</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清理与控制器相关的逻辑，例如清除输入绑定、重置状态等</span></span><br><span class="line">        <span class="comment">// AbilitySystemComponent-&gt;ClearBindings();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在控制器失去对角色的控制时，进行必要的清理工作，确保角色状态的一致性。</p>
</li>
</ol>
<h4 id="使用场景说明-1"><a href="#使用场景说明-1" class="headerlink" title="使用场景说明"></a>使用场景说明</h4><p>在游戏开发中，<code>PossessedBy</code> 函数通常用于以下场景：</p>
<ul>
<li>​<strong>​角色初始化​</strong>​: 当玩家或 AI 控制器首次拥有角色时，进行必要的初始化设置，如绑定输入、激活默认能力等。</li>
<li>​<strong>​控制器切换​</strong>​: 当控制器在运行时切换（例如，玩家死亡后重新控制另一个角色），确保新控制器正确地与角色关联。</li>
<li>​<strong>​状态管理​</strong>​: 根据控制器的类型（玩家或 AI），调整角色的行为和状态，以适应不同的游戏逻辑。</li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>​<strong>​避免重复初始化​</strong>​: 确保 <code>PossessedBy</code> 中的初始化逻辑不会在每次控制器切换时重复执行不必要的操作，可以通过标志位或其他机制来管理初始化状态。</p>
</li>
<li><p>​<strong>​处理失去控制的情况​</strong>​: 除了 <code>PossessedBy</code>，还需要重写 <code>UnPossess</code> 函数，以处理控制器失去对角色控制时的清理工作，确保角色状态的一致性。</p>
</li>
<li><p>​<strong>​同步问题​</strong>​: 在多人联机环境下，要注意这些 Actor 信息的同步问题，确保客户端和服务器端的一致性，特别是在激活能力和应用效果时。</p>
</li>
<li><p>​<strong>​输入绑定​</strong>​: 确保输入绑定与控制器的类型匹配，避免在 AI 控制器上绑定不必要的玩家输入逻辑。</p>
</li>
</ul>
<hr>
<h2 id="​​FGameplayAbilitySpec​​"><a href="#​​FGameplayAbilitySpec​​" class="headerlink" title="​​FGameplayAbilitySpec​​"></a>​<strong>​FGameplayAbilitySpec​</strong>​</h2><blockquote>
<p>​<strong>​是Unreal Engine (UE)​</strong>​ 中 ​<strong>​Gameplay Ability System (GAS)​</strong>​ 的核心结构体，用于定义和管理单个游戏玩法能力实例。</p>
</blockquote>
<hr>
<h2 id="​​1-主要组成部分​​"><a href="#​​1-主要组成部分​​" class="headerlink" title="​​1. 主要组成部分​​"></a>​<strong>​1. 主要组成部分​</strong>​</h2><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>​<strong>​<code>Ability</code>​</strong>​</td>
<td><code>TSubclassOf&lt;UGameplayAbility&gt;</code></td>
<td>具体的能力类（如 <code>UMyGameplayAbility</code>）。</td>
</tr>
<tr>
<td>​<strong>​<code>InputID</code>​</strong>​</td>
<td><code>int32</code></td>
<td>输入绑定 ID（如键盘按键或手柄按钮）。</td>
</tr>
<tr>
<td>​<strong>​<code>Level</code>​</strong>​</td>
<td><code>int32</code></td>
<td>能力等级（影响强度或效果）。</td>
</tr>
<tr>
<td>​<strong>​<code>ActivationBlockedBy</code>​</strong>​</td>
<td><code>FGameplayTagContainer</code></td>
<td>阻止激活的标签（如“眩晕”状态）。</td>
</tr>
<tr>
<td>​<strong>​<code>GrantedTags</code>​</strong>​</td>
<td><code>FGameplayTagContainer</code></td>
<td>激活时授予的标签（影响其他能力）。</td>
</tr>
<tr>
<td>​<strong>​<code>SourceObject</code>​</strong>​</td>
<td><code>UObject*</code></td>
<td>能力来源（如角色、道具）。</td>
</tr>
<tr>
<td>​<strong>​<code>StartTime</code>​</strong>​</td>
<td><code>float</code></td>
<td>激活时间（用于计算持续时间&#x2F;冷却）。</td>
</tr>
<tr>
<td>​<strong>​<code>Duration</code>​</strong>​</td>
<td><code>float</code></td>
<td>持续时间（持续型能力）。</td>
</tr>
<tr>
<td>​<strong>​<code>CooldownTimeRemaining</code>​</strong>​</td>
<td><code>float</code></td>
<td>剩余冷却时间。</td>
</tr>
<tr>
<td>​<strong>​<code>bIsActive</code>​</strong>​</td>
<td><code>bool</code></td>
<td>是否处于激活状态。</td>
</tr>
</tbody></table>
<hr>
<h2 id="​​2-创建与管理​​"><a href="#​​2-创建与管理​​" class="headerlink" title="​​2. 创建与管理​​"></a>​<strong>​2. 创建与管理​</strong>​</h2><h3 id="​​2-1-创建-FGameplayAbilitySpec​​"><a href="#​​2-1-创建-FGameplayAbilitySpec​​" class="headerlink" title="​​2.1 创建 FGameplayAbilitySpec​​"></a>​<strong>​2.1 创建 <code>FGameplayAbilitySpec</code>​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 AbilitySystemComponent</span></span><br><span class="line">UAbilitySystemComponent* ASC = xxx<span class="comment">/* 获取或初始化 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义能力类和等级</span></span><br><span class="line">TSubclassOf&lt;UGameplayAbility&gt; AbilityClass = UMyGameplayAbility::<span class="built_in">StaticClass</span>();</span><br><span class="line">int32 Level = <span class="number">1</span>;</span><br><span class="line">int32 InputID = <span class="number">0</span>; <span class="comment">// 绑定输入（如按键）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Spec</span></span><br><span class="line"><span class="function">FGameplayAbilitySpec <span class="title">Spec</span><span class="params">(AbilityClass, Level, InputID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到 AbilitySystemComponent</span></span><br><span class="line">ASC-&gt;<span class="built_in">GiveAbility</span>(Spec);</span><br></pre></td></tr></table></figure>

<h3 id="​​3-1-激活-取消能力​​"><a href="#​​3-1-激活-取消能力​​" class="headerlink" title="​​3.1 激活&#x2F;取消能力​​"></a>​<strong>​3.1 激活&#x2F;取消能力​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活能力</span></span><br><span class="line">ASC-&gt;<span class="built_in">ActivateAbility</span>(Spec.Handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消能力</span></span><br><span class="line">ASC-&gt;<span class="built_in">CancelAbility</span>(Spec.Handle, Spec.ActivationInfo, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>



<h1 id="GAS-通知蓝图-很重要必须看！"><a href="#GAS-通知蓝图-很重要必须看！" class="headerlink" title="GAS-通知蓝图-很重要必须看！"></a>GAS-通知蓝图-很重要必须看！</h1><p>看不到图片请联系我，我会给你发本地文档，因为本人很懒，暂时不想添加图片显示。</p>
<h2 id="Pasted-image-20250422172242-png"><a href="#Pasted-image-20250422172242-png" class="headerlink" title="![[Pasted image 20250422172242.png]]"></a>![[Pasted image 20250422172242.png]]</h2><p>通知蓝图中有个接受通知事件，节点如下<br>该节点发送通知给角色，接受一个角色标签<br>![[Pasted image 20250422172549.png]]<br>通知的的原理：一定要使得游戏标签可见，使用send gameplayevent to actor 节点将通知通过游戏标签发送给角色，Event gameplay enent节点用于接受通知并执行<br>![[Pasted image 20250422173850.png]]<br>那么可以利用在动画蓝图中放置自定义通知，一旦动画播放完，收到通知则将武器绑定到手部，实现或者实现其它任意功能了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/15/2025-04-15-%E8%99%9A%E5%B9%BBCpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zoomi">
      <meta itemprop="description" content="欢迎来到我的虚幻个人博客，不定期更新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zoomi的虚幻世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/15/2025-04-15-%E8%99%9A%E5%B9%BBCpp/" class="post-title-link" itemprop="url">虚幻C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-15 13:00:00 / 修改时间：13:04:44" itemprop="dateCreated datePublished" datetime="2025-04-15T13:00:00+08:00">2025-04-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">虚幻引擎</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UE5-调试-API-常用"><a href="#UE5-调试-API-常用" class="headerlink" title="UE5 调试 API-常用"></a>UE5 调试 API-常用</h1><h2 id="基础调试输出"><a href="#基础调试输出" class="headerlink" title="基础调试输出"></a>基础调试输出</h2><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础日志</span></span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;This is a log message&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;This is a warning&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;This is an error&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带变量的输出</span></span><br><span class="line"><span class="type">float</span> Health = <span class="number">75.0f</span>;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Player health: %f&quot;</span>), Health);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带分类的日志（需先在头文件声明）</span></span><br><span class="line"><span class="built_in">DECLARE_LOG_CATEGORY_EXTERN</span>(LogMyGame, Log, All);</span><br><span class="line"><span class="built_in">DEFINE_LOG_CATEGORY</span>(LogMyGame);</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogMyGame, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Custom category log&quot;</span>));</span><br><span class="line"><span class="comment">// 屏幕输出（默认显示2秒）</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">2.0f</span>, FColor::White, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带Key的屏幕输出（可更新）</span></span><br><span class="line"><span class="type">static</span> int32 MyDebugKey = <span class="number">0</span>;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(MyDebugKey, <span class="number">5.0f</span>, FColor::Green, </span><br><span class="line">    FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Health: %.2f&quot;</span>), Health));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试球体</span></span><br><span class="line"><span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), Location, Radius, Segments, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试盒子</span></span><br><span class="line"><span class="built_in">DrawDebugBox</span>(<span class="built_in">GetWorld</span>(), Center, Extent, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试线条</span></span><br><span class="line"><span class="built_in">DrawDebugLine</span>(<span class="built_in">GetWorld</span>(), Start, End, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试点</span></span><br><span class="line"><span class="built_in">DrawDebugPoint</span>(<span class="built_in">GetWorld</span>(), Location, Size, Color, bPersistentLines, LifeTime, DepthPriority)；</span><br></pre></td></tr></table></figure>




<h2 id="Unreal-Engine-5-常用宏速查表"><a href="#Unreal-Engine-5-常用宏速查表" class="headerlink" title="Unreal Engine 5 常用宏速查表"></a>Unreal Engine 5 常用宏速查表</h2><h3 id="1-类声明宏"><a href="#1-类声明宏" class="headerlink" title="1. 类声明宏"></a><strong>1. 类声明宏</strong></h3><table>
<thead>
<tr>
<th>宏</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>UCLASS()</code></td>
<td>声明一个 UE 反射类</td>
<td><code>UCLASS(Blueprintable, meta=(DisplayName=&quot;My Actor&quot;))</code></td>
</tr>
<tr>
<td><code>UINTERFACE()</code></td>
<td>声明一个 UE 反射接口</td>
<td><code>UINTERFACE(MinimalAPI, Blueprintable)</code></td>
</tr>
<tr>
<td><code>UGENERATED_BODY()</code></td>
<td>自动生成类反射代码（必须放在类体内）</td>
<td><code>GENERATED_BODY()</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-属性宏-UPROPERTY"><a href="#2-属性宏-UPROPERTY" class="headerlink" title="2. 属性宏 (UPROPERTY)"></a><strong>2. 属性宏 (<code>UPROPERTY</code>)</strong></h3><table>
<thead>
<tr>
<th>宏</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>BlueprintReadOnly</code></td>
<td>蓝图只读</td>
<td><code>UPROPERTY(BlueprintReadOnly)</code></td>
</tr>
<tr>
<td><code>BlueprintReadWrite</code></td>
<td>蓝图可读写</td>
<td><code>UPROPERTY(BlueprintReadWrite)</code></td>
</tr>
<tr>
<td><code>EditAnywhere</code></td>
<td>在编辑器任意位置可编辑</td>
<td><code>UPROPERTY(EditAnywhere)</code></td>
</tr>
<tr>
<td><code>EditDefaultsOnly</code></td>
<td>仅可在默认值（CDO）编辑</td>
<td><code>UPROPERTY(EditDefaultsOnly)</code></td>
</tr>
<tr>
<td><code>VisibleAnywhere</code></td>
<td>在编辑器可见但不可编辑</td>
<td><code>UPROPERTY(VisibleAnywhere)</code></td>
</tr>
<tr>
<td><code>Category=&quot;CategoryName&quot;</code></td>
<td>在编辑器分类</td>
<td><code>UPROPERTY(Category=&quot;Movement&quot;)</code></td>
</tr>
<tr>
<td><code>meta=(DisplayName=&quot;Nice Name&quot;)</code></td>
<td>显示更友好的名称</td>
<td><code>UPROPERTY(meta=(DisplayName=&quot;Health&quot;))</code></td>
</tr>
<tr>
<td><code>Replicated</code></td>
<td>网络同步（需在 <code>GetLifetimeReplicatedProps</code> 处理）</td>
<td><code>UPROPERTY(Replicated)</code></td>
</tr>
<tr>
<td><code>Transient</code></td>
<td>不保存到磁盘（临时变量）</td>
<td><code>UPROPERTY(Transient)</code></td>
</tr>
<tr>
<td><code>SaveGame</code></td>
<td>可序列化到存档</td>
<td><code>UPROPERTY(SaveGame)</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-函数宏-UFUNCTION"><a href="#3-函数宏-UFUNCTION" class="headerlink" title="3. 函数宏 (UFUNCTION)"></a><strong>3. 函数宏 (<code>UFUNCTION</code>)</strong></h3><table>
<thead>
<tr>
<th>宏</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>BlueprintCallable</code></td>
<td>可在蓝图中调用</td>
<td><code>UFUNCTION(BlueprintCallable)</code></td>
</tr>
<tr>
<td><code>BlueprintPure</code></td>
<td>纯函数（无副作用）</td>
<td><code>UFUNCTION(BlueprintPure)</code></td>
</tr>
<tr>
<td><code>BlueprintImplementableEvent</code></td>
<td>蓝图可覆盖的虚函数（无 C++ 实现）</td>
<td><code>UFUNCTION(BlueprintImplementableEvent)</code></td>
</tr>
<tr>
<td><code>BlueprintNativeEvent</code></td>
<td>蓝图可覆盖的虚函数（有默认 C++ 实现）</td>
<td><code>UFUNCTION(BlueprintNativeEvent)</code></td>
</tr>
<tr>
<td><code>Server</code></td>
<td>仅在服务器执行（RPC）</td>
<td><code>UFUNCTION(Server, Reliable)</code></td>
</tr>
<tr>
<td><code>Client</code></td>
<td>仅在客户端执行（RPC）</td>
<td><code>UFUNCTION(Client, Reliable)</code></td>
</tr>
<tr>
<td><code>NetMulticast</code></td>
<td>多播（所有客户端执行）</td>
<td><code>UFUNCTION(NetMulticast, Reliable)</code></td>
</tr>
<tr>
<td><code>WithValidation</code></td>
<td>RPC 参数验证</td>
<td><code>UFUNCTION(Server, WithValidation)</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-结构体宏-USTRUCT"><a href="#4-结构体宏-USTRUCT" class="headerlink" title="4. 结构体宏 (USTRUCT)"></a><strong>4. 结构体宏 (<code>USTRUCT</code>)</strong></h3><table>
<thead>
<tr>
<th>宏</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>USTRUCT()</code></td>
<td>声明反射结构体</td>
<td><code>USTRUCT(BlueprintType)</code></td>
</tr>
<tr>
<td><code>GENERATED_BODY()</code></td>
<td>生成结构体反射代码</td>
<td><code>GENERATED_BODY()</code></td>
</tr>
<tr>
<td><code>BlueprintType</code></td>
<td>可在蓝图中使用</td>
<td><code>USTRUCT(BlueprintType)</code></td>
</tr>
<tr>
<td><code>meta=(BlueprintInternalUseOnly)</code></td>
<td>仅限内部使用</td>
<td><code>USTRUCT(meta=(BlueprintInternalUseOnly))</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-枚举宏-UENUM"><a href="#5-枚举宏-UENUM" class="headerlink" title="5. 枚举宏 (UENUM)"></a><strong>5. 枚举宏 (<code>UENUM</code>)</strong></h3><table>
<thead>
<tr>
<th>宏</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>UENUM()</code></td>
<td>声明反射枚举</td>
<td><code>UENUM(BlueprintType)</code></td>
</tr>
<tr>
<td><code>BlueprintType</code></td>
<td>可在蓝图中使用</td>
<td><code>UENUM(BlueprintType)</code></td>
</tr>
<tr>
<td><code>meta=(DisplayName=&quot;Nice Name&quot;)</code></td>
<td>显示友好名称</td>
<td><code>UENUM(meta=(DisplayName=&quot;Weapon Type&quot;))</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="6-其他常用宏"><a href="#6-其他常用宏" class="headerlink" title="6. 其他常用宏"></a><strong>6. 其他常用宏</strong></h3><table>
<thead>
<tr>
<th>宏</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code></td>
<td>声明动态多播委托</td>
<td><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMyDelegate);</code></td>
</tr>
<tr>
<td><code>DECLARE_DELEGATE</code></td>
<td>声明单播委托</td>
<td><code>DECLARE_DELEGATE(FMySimpleDelegate);</code></td>
</tr>
<tr>
<td><code>UE_LOG</code></td>
<td>打印日志</td>
<td><code>UE_LOG(LogTemp, Warning, TEXT(&quot;Hello&quot;));</code></td>
</tr>
<tr>
<td><code>ensure()</code></td>
<td>运行时检查（不崩溃）</td>
<td><code>ensure(MyPointer != nullptr);</code></td>
</tr>
<tr>
<td><code>check()</code></td>
<td>运行时断言（崩溃）</td>
<td><code>check(MyPointer != nullptr);</code></td>
</tr>
<tr>
<td><code>GEngine-&gt;AddOnScreenDebugMessage</code></td>
<td>屏幕打印调试信息</td>
<td><code>GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(&quot;Hello&quot;));</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="UCapsuleComponent-胶囊体-常用-API-速查表"><a href="#UCapsuleComponent-胶囊体-常用-API-速查表" class="headerlink" title="UCapsuleComponent 胶囊体 常用 API 速查表"></a>UCapsuleComponent 胶囊体 常用 API 速查表</h2><h3 id="1-基础属性设置"><a href="#1-基础属性设置" class="headerlink" title="1. 基础属性设置"></a><strong>1. 基础属性设置</strong></h3><table>
<thead>
<tr>
<th><strong>API</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>SetCapsuleSize(float Radius, float HalfHeight, bool bUpdateOverlaps)</code></td>
<td>设置胶囊体的半径和半高</td>
<td><code>CapsuleComp-&gt;SetCapsuleSize(50.f, 100.f);</code></td>
</tr>
<tr>
<td><code>GetScaledCapsuleRadius()</code></td>
<td>获取当前缩放后的半径</td>
<td><code>float Radius = CapsuleComp-&gt;GetScaledCapsuleRadius();</code></td>
</tr>
<tr>
<td><code>GetScaledCapsuleHalfHeight()</code></td>
<td>获取当前缩放后的半高</td>
<td><code>float HalfHeight = CapsuleComp-&gt;GetScaledCapsuleHalfHeight();</code></td>
</tr>
<tr>
<td><code>GetCapsuleAxis()</code></td>
<td>获取胶囊体的朝向轴（默认 <code>Z</code> 轴）</td>
<td><code>FVector Axis = CapsuleComp-&gt;GetCapsuleAxis();</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-碰撞与物理"><a href="#2-碰撞与物理" class="headerlink" title="2. 碰撞与物理"></a><strong>2. 碰撞与物理</strong></h3><table>
<thead>
<tr>
<th><strong>API</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>SetCollisionEnabled(ECollisionEnabled::Type NewType)</code></td>
<td>启用&#x2F;禁用碰撞</td>
<td><code>CapsuleComp-&gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);</code></td>
</tr>
<tr>
<td><code>SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse Response)</code></td>
<td>设置对特定通道的碰撞响应</td>
<td><code>CapsuleComp-&gt;SetCollisionResponseToChannel(ECC_Pawn, ECR_Ignore);</code></td>
</tr>
<tr>
<td><code>SetGenerateOverlapEvents(bool bGenerate)</code></td>
<td>是否生成重叠事件</td>
<td><code>CapsuleComp-&gt;SetGenerateOverlapEvents(true);</code></td>
</tr>
<tr>
<td><code>OnComponentBeginOverlap.AddDynamic()</code></td>
<td>绑定重叠开始事件</td>
<td><code>CapsuleComp-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AMyActor::OnCapsuleBeginOverlap);</code></td>
</tr>
<tr>
<td><code>OnComponentEndOverlap.AddDynamic()</code></td>
<td>绑定重叠结束事件</td>
<td><code>CapsuleComp-&gt;OnComponentEndOverlap.AddDynamic(this, &amp;AMyActor::OnCapsuleEndOverlap);</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-位置与变换"><a href="#3-位置与变换" class="headerlink" title="3. 位置与变换"></a><strong>3. 位置与变换</strong></h3><table>
<thead>
<tr>
<th><strong>API</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>GetComponentLocation()</code></td>
<td>获取胶囊体中心位置</td>
<td><code>FVector Location = CapsuleComp-&gt;GetComponentLocation();</code></td>
</tr>
<tr>
<td><code>GetComponentRotation()</code></td>
<td>获取胶囊体旋转</td>
<td><code>FRotator Rotation = CapsuleComp-&gt;GetComponentRotation();</code></td>
</tr>
<tr>
<td><code>SetWorldLocation(FVector NewLocation)</code></td>
<td>设置世界坐标位置</td>
<td><code>CapsuleComp-&gt;SetWorldLocation(FVector(0, 0, 100));</code></td>
</tr>
<tr>
<td><code>AddLocalOffset(FVector DeltaLocation)</code></td>
<td>局部坐标偏移</td>
<td><code>CapsuleComp-&gt;AddLocalOffset(FVector(10, 0, 0));</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-调试与可视化"><a href="#4-调试与可视化" class="headerlink" title="4. 调试与可视化"></a><strong>4. 调试与可视化</strong></h3><table>
<thead>
<tr>
<th><strong>API</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>SetHiddenInGame(bool bHidden)</code></td>
<td>隐藏&#x2F;显示胶囊体</td>
<td><code>CapsuleComp-&gt;SetHiddenInGame(false);</code></td>
</tr>
<tr>
<td><code>ShapeColor</code></td>
<td>设置调试颜色（编辑器可见）</td>
<td><code>CapsuleComp-&gt;ShapeColor = FColor::Green;</code></td>
</tr>
<tr>
<td><code>bDrawOnlyIfSelected</code></td>
<td>仅在选中时显示</td>
<td><code>CapsuleComp-&gt;bDrawOnlyIfSelected = true;</code></td>
</tr>
<tr>
<td><code>MarkRenderStateDirty()</code></td>
<td>强制刷新渲染状态</td>
<td><code>CapsuleComp-&gt;MarkRenderStateDirty();</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-射线检测与几何查询"><a href="#5-射线检测与几何查询" class="headerlink" title="5. 射线检测与几何查询"></a><strong>5. 射线检测与几何查询</strong></h3><table>
<thead>
<tr>
<th><strong>API</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>IsOverlappingComponent(UPrimitiveComponent* OtherComp)</code></td>
<td>检查是否与其他组件重叠</td>
<td><code>bool bOverlapping = CapsuleComp-&gt;IsOverlappingComponent(OtherActor-&gt;GetMesh());</code></td>
</tr>
<tr>
<td><code>SweepComponent(FHitResult&amp; OutHit, FVector Start, FVector End, FRotator Rotation)</code></td>
<td>胶囊体扫描检测</td>
<td><code>CapsuleComp-&gt;SweepComponent(OutHit, Start, End, FQuat::Identity);</code></td>
</tr>
<tr>
<td><code>GetOverlappingActors(TArray&lt;AActor*&gt;&amp; OutActors)</code></td>
<td>获取所有重叠的 Actor</td>
<td><code>CapsuleComp-&gt;GetOverlappingActors(OverlappingActors);</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="零散重要api"><a href="#零散重要api" class="headerlink" title="零散重要api"></a>零散重要api</h1><p>**AutoPossessPlayer &#x3D;EAutoReceiveInput::player0;     设置玩家控制器</p>
<h1 id="UE5-5-增强输入系统使用指南-C-实现"><a href="#UE5-5-增强输入系统使用指南-C-实现" class="headerlink" title="UE5.5 增强输入系统使用指南 (C++ 实现)"></a>UE5.5 增强输入系统使用指南 (C++ 实现)</h1><p>以下是在 Unreal Engine 5.5 中使用增强输入系统(Enhanced Input System)的完整 C++ 实现方式<br>关键数据结构：输入映射上下文   输入映射</p>
<p>![[Pasted image 20250414102551.png]]</p>
<h2 id="输入映射中的触发器和修改器"><a href="#输入映射中的触发器和修改器" class="headerlink" title="输入映射中的触发器和修改器"></a>输入映射中的触发器和修改器</h2><p>虚幻中的轴映射以X轴的右方为正方向！</p>
<p>一旦开启&#x3D;&#x3D;拌合输入轴值&#x3D;&#x3D;，则意味着可以交换坐标轴的位置<br>YXZ意味着交换X与Y轴的位置，交换后相当于在使用Y轴的正方向  比如W键前进</p>
<p>![[Pasted image 20250414102006.png]]<br>因为默认是X的右方是正方向，所以只需要否定X轴就是反方向</p>
<h1 id="增强输入组件"><a href="#增强输入组件" class="headerlink" title="增强输入组件"></a>增强输入组件</h1><h3 id="​​-什么是增强输入组件？​​"><a href="#​​-什么是增强输入组件？​​" class="headerlink" title="​​ 什么是增强输入组件？​​"></a>​<strong>​ 什么是增强输入组件？​</strong>​</h3><p>增强输入组件是虚幻引擎中用于处理玩家输入的组件，属于 ​<strong>​增强输入系统​</strong>​ 的一部分。它取代了传统的输入系统，提供了更强大的功能，如输入动作（Input Actions）、输入映射上下文（Input Mapping Contexts）、修饰器（Modifiers）等，使开发者能够更灵活地定义和管理输入逻辑。</p>
<h2 id="增强输入组件的核心概念​​"><a href="#增强输入组件的核心概念​​" class="headerlink" title=". 增强输入组件的核心概念​​"></a><strong>. 增强输入组件的核心概念​</strong>​</h2><h3 id="​​输入动作（Input-Actions）​​"><a href="#​​输入动作（Input-Actions）​​" class="headerlink" title="​​输入动作（Input Actions）​​"></a>​<strong>​输入动作（Input Actions）​</strong>​</h3><ul>
<li>​<strong>​定义​</strong>​：输入动作代表具体的操作，如“跳跃”、“攻击”、“移动”等。</li>
<li>​<strong>​用途​</strong>​：用于绑定具体的游戏逻辑，便于在不同场景中复用和调整。</li>
</ul>
<h3 id="​-输入映射上下文（Input-Mapping-Contexts）​-​"><a href="#​-输入映射上下文（Input-Mapping-Contexts）​-​" class="headerlink" title="​ 输入映射上下文（Input Mapping Contexts）​**​"></a>​ 输入映射上下文（Input Mapping Contexts）​**​</h3><ul>
<li>​<strong>​定义​</strong>​：输入映射上下文将物理输入（如键盘按键、鼠标按钮、手柄按键）映射到输入动作。</li>
<li>​<strong>​用途​</strong>​：允许为不同的玩家配置、设备或场景设置不同的输入映射，增强项目的适应性。</li>
</ul>
<h3 id="​​-修饰器（Modifiers）​​"><a href="#​​-修饰器（Modifiers）​​" class="headerlink" title="​​ 修饰器（Modifiers）​​"></a>​<strong>​ 修饰器（Modifiers）​</strong>​</h3><ul>
<li>​<strong>​定义​</strong>​：修饰器用于修改输入行为，如按住时间、双击检测、输入反转等。</li>
<li>​<strong>​用途​</strong>​：增强输入的灵活性，实现复杂的输入逻辑。</li>
</ul>
<h3 id="​​-输入子系统（Input-Subsystem）​​"><a href="#​​-输入子系统（Input-Subsystem）​​" class="headerlink" title="​​ 输入子系统（Input Subsystem）​​"></a>​<strong>​ 输入子系统（Input Subsystem）​</strong>​</h3><ul>
<li>​<strong>​定义​</strong>​：管理所有输入组件和映射上下文，负责处理输入事件的分发和处理。</li>
<li>​<strong>​用途​</strong>​：确保输入系统的高效运行和统一管理。</li>
</ul>
<h3 id="​​-增强输入组件的优势​​"><a href="#​​-增强输入组件的优势​​" class="headerlink" title="​​ 增强输入组件的优势​​"></a>​<strong>​ 增强输入组件的优势​</strong>​</h3><ul>
<li>​<strong>​模块化设计​</strong>​：通过输入动作和映射上下文分离输入逻辑与具体实现，便于管理和维护。</li>
<li>​<strong>​灵活性高​</strong>​：支持多种输入设备（键盘、鼠标、手柄等），并允许动态切换和组合输入方式。</li>
<li>​<strong>​丰富的功能​</strong>​：支持输入修饰器（如组合键、按住时间等）、轴映射（Axis Mappings）和动作映射（Action Mappings），满足复杂输入需求。</li>
<li>​<strong>​易于扩展​</strong>​：便于集成自定义逻辑，适应不同项目和平台的需求。</li>
</ul>
<h2 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1. 基本设置"></a>1. 基本设置</h2><h3 id="1-1-启用增强输入模块"><a href="#1-1-启用增强输入模块" class="headerlink" title="1.1 启用增强输入模块"></a>1.1 启用增强输入模块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先在项目的 `Build.cs` 文件中添加依赖：</span><br><span class="line">PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; </span><br><span class="line">    <span class="string">&quot;Core&quot;</span>, </span><br><span class="line">    <span class="string">&quot;CoreUObject&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Engine&quot;</span>, </span><br><span class="line">    <span class="string">&quot;InputCore&quot;</span>, </span><br><span class="line">    <span class="string">&quot;EnhancedInput&quot;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="1-2-创建输入动作-Input-Actions"><a href="#1-2-创建输入动作-Input-Actions" class="headerlink" title="1.2 创建输入动作(Input Actions)"></a>1.2 创建输入动作(Input Actions)</h3><p>在内容浏览器中右键创建 <code>Input Actions</code> 资源：</p>
<ul>
<li><p><code>IA_Jump</code></p>
</li>
<li><p><code>IA_Move</code></p>
</li>
<li><p><code>IA_Look</code></p>
</li>
<li><p><code>IA_Fire</code></p>
</li>
</ul>
<h2 id="2-C-利用增强输入系统实现输入映射"><a href="#2-C-利用增强输入系统实现输入映射" class="headerlink" title="2. C++ 利用增强输入系统实现输入映射"></a>2. C++ 利用增强输入系统实现输入映射</h2><h3 id="2-1-玩家控制器头文件-MyPlayerController-h"><a href="#2-1-玩家控制器头文件-MyPlayerController-h" class="headerlink" title="2.1 玩家控制器头文件 (MyPlayerController.h)"></a>2.1 玩家控制器头文件 (MyPlayerController.h)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InputActionValue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPlayerController.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputMappingContext</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputAction</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYPROJECT_API</span> AMyPlayerController : <span class="keyword">public</span> APlayerController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupInputComponent</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入映射上下文</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputMappingContext* DefaultMappingContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入动作</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* JumpAction;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* MoveAction;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* LookAction;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* FireAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 输入回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnJump</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMove</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnLook</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnFire</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-玩家控制器实现文件-MyPlayerController-cpp"><a href="#2-2-玩家控制器实现文件-MyPlayerController-cpp" class="headerlink" title="2.2 玩家控制器实现文件 (MyPlayerController.cpp)"></a>2.2 玩家控制器实现文件 (MyPlayerController.cpp)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EnhancedInputComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EnhancedInputSubsystems.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地玩家增强输入子系统并添加映射上下文</span></span><br><span class="line">    <span class="keyword">if</span> (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::<span class="built_in">GetSubsystem</span>&lt;UEnhancedInputLocalPlayerSubsystem&gt;(<span class="built_in">GetLocalPlayer</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        Subsystem-&gt;<span class="built_in">AddMappingContext</span>(DefaultMappingContext, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::SetupInputComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupInputComponent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置增强输入组件</span></span><br><span class="line">    <span class="keyword">if</span> (UEnhancedInputComponent* EnhancedInputComponent = <span class="built_in">CastChecked</span>&lt;UEnhancedInputComponent&gt;(InputComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(JumpAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnJump);</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(MoveAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnMove);</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(LookAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnLook);</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(FireAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnFire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnJump</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ACharacter* Character = <span class="built_in">GetCharacter</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Character-&gt;<span class="built_in">Jump</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnMove</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FVector2D MovementVector = Value.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ACharacter* Character = <span class="built_in">GetCharacter</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FRotator Rotation = <span class="built_in">GetControlRotation</span>();</span><br><span class="line">        <span class="function"><span class="type">const</span> FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0</span>, Rotation.Yaw, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> FVector ForwardDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X);</span><br><span class="line">        <span class="type">const</span> FVector RightDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::Y);</span><br><span class="line">        </span><br><span class="line">        Character-&gt;<span class="built_in">AddMovementInput</span>(ForwardDirection, MovementVector.Y);</span><br><span class="line">        Character-&gt;<span class="built_in">AddMovementInput</span>(RightDirection, MovementVector.X);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnLook</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FVector2D LookAxisVector = Value.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsLookInputIgnored</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AddYawInput</span>(LookAxisVector.X);</span><br><span class="line">    <span class="built_in">AddPitchInput</span>(LookAxisVector.Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnFire</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实现射击逻辑</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Fire!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如何获取控制器的旋转角度并转换成向量-常用"><a href="#如何获取控制器的旋转角度并转换成向量-常用" class="headerlink" title="如何获取控制器的旋转角度并转换成向量-常用"></a>如何获取控制器的旋转角度并转换成向量-常用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ABird::Move</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;MoveForward&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (Value != <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//根据控制器旋转获取移动方向</span></span><br><span class="line">        FRotator Rotation = <span class="built_in">GetControlRotation</span>();</span><br><span class="line">        <span class="function">FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0</span>, Rotation.Yaw, <span class="number">0</span>)</span></span>;<span class="comment">//获取旋转的Yaw角度</span></span><br><span class="line">        FVector Direction = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X);<span class="comment">//通过旋转矩阵获取方向向量</span></span><br><span class="line">        <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></figure>


<h1 id="虚幻添加模块的办法-常用"><a href="#虚幻添加模块的办法-常用" class="headerlink" title="虚幻添加模块的办法-常用"></a>虚幻添加模块的办法-常用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.<span class="built_in">AddRange</span>(</span><br><span class="line">    <span class="keyword">new</span> string[] &#123;</span><br><span class="line">        <span class="string">&quot;Core&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CoreUObject&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">        <span class="string">&quot;GroomComponent&quot;</span>  <span class="comment">// 添加毛发组件模块</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="虚幻枚举"><a href="#虚幻枚举" class="headerlink" title="虚幻枚举"></a>虚幻枚举</h1><p>![[Pasted image 20250412151930.png]]<br>在虚幻引擎（Unreal Engine，简称UE）中，​<strong>​枚举（Enum）​</strong>​是一种非常有用的数据类型，用于定义一组命名的常量。使用枚举可以提高代码的可读性和可维护性，避免使用魔法数字（magic numbers），并简化逻辑判断。以下是关于虚幻引擎中枚举的详细介绍，包括其定义、使用方法、类型以及在蓝图和C++中的具体应用。</p>
<hr>
<h2 id="​​1-枚举的基本概念​​"><a href="#​​1-枚举的基本概念​​" class="headerlink" title="​​1. 枚举的基本概念​​"></a>​<strong>​1. 枚举的基本概念​</strong>​</h2><p>​<strong>​枚举​</strong>​（Enumeration）是一种用户定义的数据类型，它包含了一组命名的整数常量。通过枚举，可以为这些常量赋予有意义的名字，使代码更加直观和易于理解。<br>​<strong>​示例：​</strong>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EWeekDays</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">`</span><br><span class="line">在上述示例中，`EWeekDays` 是一个枚举类型，包含了一周的七天。每个枚举值（如 `Monday`、`Tuesday` 等）都对应一个整数值，默认情况下从<span class="number">0</span>开始递增。</span><br><span class="line">---</span><br><span class="line">虚幻引擎支持两种主要的枚举类型：</span><br><span class="line"></span><br><span class="line">在C++中定义枚举时，推荐使用 `<span class="keyword">enum</span> <span class="title class_">class</span>`，因为它提供了更好的类型安全和作用域控制。</span><br><span class="line">​**​定义枚举：​**​</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="title">UENUM</span><span class="params">(BlueprintType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> <span class="keyword">class</span> ECharacterClass : uint8</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="function">GUARDIAN <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Guardian&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    WARRIOR  <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Warrior&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    MAGE     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Mage&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    ROGUE    <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Rogue&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>​<strong>​说明：​</strong>​</p>
<ul>
<li><code>UENUM(BlueprintType)</code> 宏用于将枚举暴露给蓝图系统，使其在蓝图中可用。</li>
<li><code>UMETA(DisplayName = &quot;Guardian&quot;)</code> 提供了枚举编辑器中的显示名称，增强可读性。</li>
<li>使用 <code>enum class</code> 而不是传统的 <code>enum</code>，以避免命名冲突和类型隐式转换的问题。</li>
</ul>
<h3 id="​​2-2-蓝图枚举（Blueprint-Enum）​​"><a href="#​​2-2-蓝图枚举（Blueprint-Enum）​​" class="headerlink" title="​​2.2 蓝图枚举（Blueprint Enum）​​"></a>​<strong>​2.2 蓝图枚举（Blueprint Enum）​</strong>​</h3><p>蓝图枚举是专门在蓝图中创建和使用的枚举类型，适用于不需要复杂C++逻辑的场景。<br>​<strong>​创建蓝图枚举的步骤：​</strong>​</p>
<ol>
<li>在内容浏览器中，右键点击空白区域，选择 <code>Blueprint Class</code>。</li>
<li>在弹出的窗口中，选择 <code>Enumeration</code> 作为父类。</li>
<li>命名并创建蓝图枚举。</li>
<li>双击打开蓝图枚举，添加和命名各个枚举值。</li>
</ol>
<h2 id="​​优点：​​-易于在蓝图中创建和使用，无需编写C-代码。-适用于快速原型设计和逻辑简单的项目。​​缺点：​​-功能上不如C-枚举灵活，特别是在需要复杂逻辑或与其他C-系统集成时。"><a href="#​​优点：​​-易于在蓝图中创建和使用，无需编写C-代码。-适用于快速原型设计和逻辑简单的项目。​​缺点：​​-功能上不如C-枚举灵活，特别是在需要复杂逻辑或与其他C-系统集成时。" class="headerlink" title="​​优点：​​- 易于在蓝图中创建和使用，无需编写C++代码。- 适用于快速原型设计和逻辑简单的项目。​​缺点：​​- 功能上不如C++枚举灵活，特别是在需要复杂逻辑或与其他C++系统集成时。"></a>​<strong>​优点：​</strong>​<br>- 易于在蓝图中创建和使用，无需编写C++代码。<br>- 适用于快速原型设计和逻辑简单的项目。<br>​<strong>​缺点：​</strong>​<br>- 功能上不如C++枚举灵活，特别是在需要复杂逻辑或与其他C++系统集成时。</h2><h2 id="​​3-枚举的使用方法​​"><a href="#​​3-枚举的使用方法​​" class="headerlink" title="​​3. 枚举的使用方法​​"></a>​<strong>​3. 枚举的使用方法​</strong>​</h2><h3 id="​​3-1-在C-中使用枚举​​"><a href="#​​3-1-在C-中使用枚举​​" class="headerlink" title="​​3.1 在C++中使用枚举​​"></a>​<strong>​3.1 在C++中使用枚举​</strong>​</h3><h4 id="​​定义枚举变量​​"><a href="#​​定义枚举变量​​" class="headerlink" title="​​定义枚举变量​​"></a>​<strong>​定义枚举变量​</strong>​</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E CharacterClass = ECharacterClass::Warrior;</span><br></pre></td></tr></table></figure>
<h4 id="​​在函数中使用枚举​​"><a href="#​​在函数中使用枚举​​" class="headerlink" title="​​在函数中使用枚举​​"></a>​<strong>​在函数中使用枚举​</strong>​</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::SetCharacterClass</span><span class="params">(ECharacterClass NewClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CharacterClass = NewClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (CharacterClass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Guardian:</span><br><span class="line">            <span class="comment">// 守护者逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Warrior:</span><br><span class="line">            <span class="comment">// 战士逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Mage:</span><br><span class="line">            <span class="comment">// 法师逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Rogue:</span><br><span class="line">            <span class="comment">// 潜行侠逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="​​枚举与蓝图交互​​"><a href="#​​枚举与蓝图交互​​" class="headerlink" title="​​枚举与蓝图交互​​"></a>​<strong>​枚举与蓝图交互​</strong>​</h4><p>通过 <code>UENUM(BlueprintType)</code> 宏，可以在蓝图中访问和修改C++中定义的枚举变量。</p>
<p>​<strong>​示例：在蓝图中设置角色的职业​</strong>​</p>
<ol>
<li><p>在角色类中定义一个公开的枚举变量：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;Character&quot;</span>)</span><br><span class="line">ECharacterClass CharacterClass;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在蓝图中，可以通过细节面板直接选择或通过节点修改 <code>CharacterClass</code> 的值。</p>
</li>
</ol>
<h3 id="​​3-2-在蓝图中使用枚举​​"><a href="#​​3-2-在蓝图中使用枚举​​" class="headerlink" title="​​3.2 在蓝图中使用枚举​​"></a>​<strong>​3.2 在蓝图中使用枚举​</strong>​</h3><h4 id="​​创建和使用蓝图枚举​​"><a href="#​​创建和使用蓝图枚举​​" class="headerlink" title="​​创建和使用蓝图枚举​​"></a>​<strong>​创建和使用蓝图枚举​</strong>​</h4><ol>
<li>​<strong>​创建蓝图枚举​</strong>​：<ul>
<li>按照前述步骤在内容浏览器中创建一个蓝图枚举，例如 <code>EBP_WeaponType</code>，包含 <code>Pistol</code>、<code>Rifle</code>、<code>Shotgun</code> 等枚举值。</li>
</ul>
</li>
<li>​<strong>​在蓝图中使用枚举变量​</strong>​：<ul>
<li>在蓝图中添加一个枚举类型的变量，选择刚刚创建的 <code>EBP_WeaponType</code>。</li>
<li>使用 ​<strong>​Switch on Enum​</strong>​ 节点根据枚举值执行不同的逻辑。<br>​<strong>​示例：根据武器类型播放不同的声音​</strong>​</li>
</ul>
</li>
<li>添加一个 <code>_WeaponType</code> 类型的变量 <code>CurrentWeapon</code>。</li>
<li>使用 ​<strong>​Switch on Enum​</strong>​ 节点，输入 <code>CurrentWeapon</code>。</li>
<li>为每个枚举值（如 <code>Pistol</code>、<code>Rifle</code>、<code>Shotgun</code>）添加对应的分支，并连接播放相应声音的节点。</li>
</ol>
<hr>
<h2 id="​​4-枚举的高级用法​​"><a href="#​​4-枚举的高级用法​​" class="headerlink" title="​​4. 枚举的高级用法​​"></a>​<strong>​4. 枚举的高级用法​</strong>​</h2><h3 id="​​4-1-枚举与位掩码（Bitmask）​​"><a href="#​​4-1-枚举与位掩码（Bitmask）​​" class="headerlink" title="​​4.1 枚举与位掩码（Bitmask）​​"></a>​<strong>​4.1 枚举与位掩码（Bitmask）​</strong>​</h3><p>有时需要将多个枚举值组合在一起使用，这时可以使用位掩码。虚幻引擎支持通过设置 <code>Meta</code> 参数来启用位掩码功能。<br>​<strong>​定义位掩码枚举：​</strong>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EPermissions</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    None        = <span class="number">0</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;None&quot;</span>),</span><br><span class="line">    Read        = <span class="number">1</span> &lt;&lt; <span class="number">0</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Read&quot;</span>),</span><br><span class="line">    Write       = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Write&quot;</span>),</span><br><span class="line">    Execute     = <span class="number">1</span> &lt;&lt; <span class="number">2</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Execute&quot;</span>),</span><br><span class="line">    All         = Read | Write | Execute <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;All&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​<strong>​使用位掩码枚举：​</strong>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EPermissions UserPermissions = EPermissions::Read | EPermissions::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UserPermissions &amp; EPermissions::Read)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户有读取权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((UserPermissions &amp; EPermissions::All) == EPermissions::All)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户拥有所有权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<strong>​说明：​</strong>​</p>
<ul>
<li>使用位移运算符 <code>&lt;&lt;</code> 定义每个权限的独立位。</li>
<li>使用按位与 <code>&amp;</code> 和按位或 <code>|</code> 运算符进行权限的组合和检查。</li>
</ul>
<h3 id="​​4-2-枚举参数​​"><a href="#​​4-2-枚举参数​​" class="headerlink" title="​​4.2 枚举参数​​"></a>​<strong>​4.2 枚举参数​</strong>​</h3><p>枚举常用于函数参数，以增强函数的灵活性和可读性。<br>​<strong>​示例：​</strong>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerformAttack</span><span class="params">(EAttackType AttackType)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​<strong>​调用方式：​</strong>​<br>在蓝图中调用 <code>PerformAttack</code> 函数时，可以通过下拉菜单选择具体的攻击类型（如 <code>Melee</code>、<code>Ranged</code>、<code>Magic</code>），无需记住具体的数值。</p>
<h3 id="​​4-3-枚举与数据表（Data-Tables）​​"><a href="#​​4-3-枚举与数据表（Data-Tables）​​" class="headerlink" title="​​4.3 枚举与数据表（Data Tables）​​"></a>​<strong>​4.3 枚举与数据表（Data Tables）​</strong>​</h3><p>枚举可以与数据表结合使用，数据驱动的设计中管理大量相关数据。</p>
<p>​<strong>​步骤：​</strong>​</p>
<ol>
<li>定义一个枚举，表示不同的数据类别。</li>
<li>创建一个结构体，包含该枚举作为成员变量。</li>
<li>在编辑器中创建并填充数据表，使用该结构体作为行类型。</li>
<li>在代码或蓝图中读取数据表，并根据枚举值处理相应的数据。</li>
</ol>
<p>​<strong>​示例：​</strong>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FWeaponData</span> : <span class="keyword">public</span> FTableRowBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">    EWeaponType WeaponType;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">    <span class="type">float</span> Damage;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">    <span class="type">float</span> Range;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="​​5-常见问题与解决方案​​"><a href="#​​5-常见问题与解决方案​​" class="headerlink" title="​​5. 常见问题与解决方案​​"></a>​<strong>​5. 常见问题与解决方案​</strong>​</h2><h3 id="​​5-1-枚举值在蓝图中不显示​​"><a href="#​​5-1-枚举值在蓝图中不显示​​" class="headerlink" title="​​5.1 枚举值在蓝图中不显示​​"></a>​<strong>​5.1 枚举值在蓝图中不显示​</strong>​</h3><p>​<strong>​原因：​</strong>​</p>
<ul>
<li>枚举未正确暴露给蓝图，或者缺少必要的元数据。</li>
</ul>
<p>​<strong>​解决方法：​</strong>​</p>
<ul>
<li>确保在C++中使用 <code>UENUM(BlueprintType)</code> 宏定义枚举。</li>
<li>检查枚举值是否正确添加了 <code>UMName)</code>，以增强在蓝图中的可读性。</li>
</ul>
<h3 id="​​5-2-枚举值在不同平台上的兼容性​​"><a href="#​​5-2-枚举值在不同平台上的兼容性​​" class="headerlink" title="​​5.2 枚举值在不同平台上的兼容性​​"></a>​<strong>​5.2 枚举值在不同平台上的兼容性​</strong>​</h3><p>​<strong>​原因：​</strong>​</p>
<ul>
<li>不同平台对枚举大小的默认处理可能不同，导致跨平台数据传输时出现问题。</li>
</ul>
<p>​<strong>​解决方法：​</strong>​</p>
<ul>
<li><p>明确定义枚举的基础类型，如 <code>uint8</code>，以确保在所有平台上的一致性。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EExampleEnum</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    Value1,</span><br><span class="line">    Value2,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="​​5-3-枚举与序列化问题​​"><a href="#​​5-3-枚举与序列化问题​​" class="headerlink" title="​​5.3 枚举与序列化问题​​"></a>​<strong>​5.3 枚举与序列化问题​</strong>​</h3><p>​<strong>​原因：​</strong>​</p>
<ul>
<li>在保存和加载过程中，枚举值可能因为版本变更或未正确处理而导致数据丢失或错误。<br>​<strong>​解决方法：​</strong>​</li>
<li>确保在序列化相关的数据结构时，枚举值被正确处理。</li>
<li>使用版本控制机制，以应对枚举值的变更。</li>
</ul>
<hr>
<h2 id="​​6-最佳实践​​"><a href="#​​6-最佳实践​​" class="headerlink" title="​​6. 最佳实践​​"></a>​<strong>​6. 最佳实践​</strong>​</h2><ol>
<li>​<strong>​使用 <code>enum class</code> 而非传统 <code>enum</code>​</strong>​：<ul>
<li>提供更好的类型安全和作用域控制，避免命名冲突和隐式转换。</li>
</ul>
</li>
<li>​<strong>​为枚举值添加有意义的名称​</strong>​：<ul>
<li>使用描述性强的名称，增强代码的可读性和可维护性。</li>
</ul>
</li>
<li>​<strong>​暴露必要的枚举给蓝图​</strong>​：<ul>
<li>通过 <code>UENUM(BlueprintType)</code> 将需要在蓝图中使用的枚举暴露出来，并合理使用 <code>UMETA</code> 元数据增强其可用性。</li>
</ul>
</li>
<li>​<strong>​考虑枚举的可扩展性​</strong>​：<ul>
<li>在设计枚举时，预留一定的空间以备将来可能的扩展，避免频繁修改已有的枚举值。</li>
</ul>
</li>
<li>​<strong>​文档和注释​</strong>​：<ul>
<li>为枚举及其值添加详细的文档和注释，帮助团队成员理解其用途和含义。</li>
</ul>
</li>
<li>​<strong>​避免使用魔法数字​</strong>​：<ul>
<li>始终使用枚举替代硬编码的数字，提高代码的可读性和可维护性。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="​​7-示例项目​​"><a href="#​​7-示例项目​​" class="headerlink" title="​​7. 示例项目​​"></a>​<strong>​7. 示例项目​</strong>​</h2><p>以下是一个简单的示例，展示如何在虚幻枚举来管理角色的状态。</p>
<h3 id="​​7-1-定义枚举​​"><a href="#​​7-1-定义枚举​​" class="headerlink" title="​​7.1 定义枚举​​"></a>​<strong>​7.1 定义枚举​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterStateEnum.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CharacterStateEnum.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ECharacterState</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Idle        <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Idle&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Walking     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Walking&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Running     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Running&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Jumping     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Jumping&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Attacking   <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Attacking&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Dead        <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dead&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="​​7-2-在角色类中使用枚举​​"><a href="#​​7-2-在角色类中使用枚举​​" class="headerlink" title="​​7.2 在角色类中使用枚举​​"></a>​<strong>​7.2 在角色类中使用枚举​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CharacterStateEnum.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYGAME_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 角色当前状态</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;State&quot;</span>)</span><br><span class="line">    ECharacterState CurrentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换状态函数</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;State&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(ECharacterState NewState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    CurrentState = ECharacterState::Idle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">    <span class="built_in">HandleState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::SetState</span><span class="params">(ECharacterState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CurrentState = NewState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::HandleState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (CurrentState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Idle:</span><br><span class="line">            <span class="comment">// 执行闲置逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Walking:</span><br><span class="line">            <span class="comment">// 执行行走逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Running:</span><br><span class="line">            <span class="comment">// 执行奔跑逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Jumping:</span><br><span class="line">            <span class="comment">// 执行跳跃逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Attacking:</span><br><span class="line">            <span class="comment">// 执行攻击逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Dead:</span><br><span class="line">            <span class="comment">// 执行死亡逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="​​7-3-在蓝图中使用枚举​​"><a href="#​​7-3-在蓝图中使用枚举​​" class="headerlink" title="​​7.3 在蓝图中使用枚举​​"></a>​<strong>​7.3 在蓝图中使用枚举​</strong>​</h3><ol>
<li><p>​<strong>​创建角色蓝图​</strong>​：</p>
<ul>
<li>基于 <code>AMyCharacter</code> 创建一个蓝图类 <code>BP_MyCharacter</code>。</li>
</ul>
</li>
<li><p>​<strong>​设置状态变量​</strong>​：</p>
<ul>
<li>在蓝图的细节面板中，可以看到 <code>CurrentState</code> 变量，可以直接选择不同的状态。</li>
</ul>
</li>
<li><p>​<strong>​调用状态切换函数​</strong>​：</p>
<ul>
<li>使用事件图表中的节点调用 <code>SetState</code> 函数，动态改变角色的状态。</li>
</ul>
</li>
<li><p>​<strong>​扩展状态逻辑​</strong>​：</p>
<ul>
<li>在蓝图中，可以进一步扩展 <code>HandleState</code> 的逻辑，使用 ​<strong>​Switch on Enum​</strong>​ 节点根据 <code>CurrentState</code> 执行不同的行为。</li>
</ul>
</li>
</ol>
<h1 id="硬引用和软引用-性能相关"><a href="#硬引用和软引用-性能相关" class="headerlink" title="硬引用和软引用- 性能相关"></a>硬引用和软引用- 性能相关</h1><p>在虚幻引擎（Unreal Engine）中，<strong>软引用（Soft Reference）</strong>和<strong>硬引用（Hard Reference）</strong>是资源加载和管理的核心概念，直接影响内存使用、加载性能和项目维护。以下是它们的详细对比和用法：</p>
<hr>
<h3 id="1-硬引用（Hard-Reference）"><a href="#1-硬引用（Hard-Reference）" class="headerlink" title="1. 硬引用（Hard Reference）"></a><strong>1. 硬引用（Hard Reference）</strong></h3><p><strong>定义</strong>：<br>硬引用表示资源在运行时<strong>强制加载</strong>到内存中。只要引用者存在，被引用的资源会一直驻留内存。<br><strong>特点</strong>：</p>
<ul>
<li><p><strong>自动加载</strong>：资源随引用它的对象（如蓝图、关卡）一起加载。</p>
</li>
<li><p><strong>内存占用高</strong>：可能导致不必要的内存消耗，尤其是引用大型资源（如纹理、模型）。</p>
</li>
<li><p><strong>强依赖性</strong>：若被引用的资源丢失，会导致运行时错误（如红色错误提示）。<br><strong>常见场景</strong>：</p>
</li>
<li><p>直接拖放资源到蓝图或关卡中（例如：在蓝图中直接指定一个静态网格或材质）。</p>
</li>
<li><p>使用 <code>UPROPERTY</code> 声明时未指定特殊修饰符：</p>
<p>  UPROPERTY()<br>  UTexture2D* HardTextureRef; &#x2F;&#x2F; 硬引用</p>
</li>
</ul>
<p>&#x3D;&#x3D;硬引用&#x3D;&#x3D;    这也是一个硬引用<br>![[Pasted image 20250412160904.png]]<br>&#x3D;&#x3D;创建软引用&#x3D;&#x3D;<br>软引用的好处是资产仅在需要时加载，这可以节省内存。我们对暂时不需要的不关键资产用软引用<br>但是不适合![[Pasted image 20250412161333.png]]</p>
<p>![[Pasted image 20250412160946.png]]</p>
<h1 id="虚幻智能指针"><a href="#虚幻智能指针" class="headerlink" title="虚幻智能指针"></a>虚幻智能指针</h1><h2 id="TObjectPtr"><a href="#TObjectPtr" class="headerlink" title="TObjectPtr"></a>TObjectPtr</h2><p>支持访问跟踪和延迟加载<br>访问跟踪：知道对象何时被加载或者访问<br>延迟加载：只在需要时加载资源<br>缺点：主要适用于成员变量，仅仅在编辑器中有效，在发布版本中会被转换成原始指针，所以不会让游戏变得更快，仅仅提供一种编辑体验</p>
<h1 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h1><h2 id="要获取父类的数据要使用强制转换，将子类对象转换为父类对象-这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。"><a href="#要获取父类的数据要使用强制转换，将子类对象转换为父类对象-这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。" class="headerlink" title="要获取父类的数据要使用强制转换，将子类对象转换为父类对象   这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。"></a>要获取父类的数据要使用强制转换，将子类对象转换为父类对象   这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。</h2><p>tips:&#x3D;&#x3D;使用C++指定动画蓝图父类&#x3D;&#x3D;时一定要关闭编辑器！&#x3D;&#x3D;<strong>Animinstance</strong>&#x3D;&#x3D;是所有动画蓝图的基础蓝图类！可以重写它以实现动画蓝图的功能！<br>![[Pasted image 20250331162306.png]]<br>上图所示表示动画开始时获取角色组件，&#x3D;&#x3D;<code>TryGetPawnOwner（）</code>&#x3D;&#x3D; 用于尝试获取当前动画蓝图实例所关联的Pawn（角色）对象。因为character是Pawn的子类，所以也能获取，但是需要Cast&lt;&gt;()进行类型转换</p>
<h3 id="使用多个动画蓝图控制动画"><a href="#使用多个动画蓝图控制动画" class="headerlink" title="使用多个动画蓝图控制动画"></a>使用多个动画蓝图控制动画</h3><p>创建一个新蓝图，在另一个类中使用链接图表将蓝图链接。intputpose节点设置在需要姿势的动画蓝图里可以链接另一个蓝图的姿势</p>
<h1 id="动画蒙太奇-一种动画分组容器"><a href="#动画蒙太奇-一种动画分组容器" class="headerlink" title="动画蒙太奇-一种动画分组容器"></a>动画蒙太奇-一种动画分组容器</h1><p>使用标签指定动画播放的顺序，创建插槽将蒙太奇动画关联到插槽<br>![[Pasted image 20250402141713.png]]<br>网格体可以获取到动画示例，并使用动画蒙太奇。</p>
<blockquote>
<p>****** &#x3D;&#x3D;<strong>要想使用蒙太奇，必须在动画蓝图中启用插槽！</strong>&#x3D;&#x3D;</p>
</blockquote>
<h2 id="UE5-C-动画蓝图关键API：重写动画开始与每帧更新"><a href="#UE5-C-动画蓝图关键API：重写动画开始与每帧更新" class="headerlink" title="UE5 C++动画蓝图关键API：重写动画开始与每帧更新"></a>UE5 C++动画蓝图关键API：重写动画开始与每帧更新</h2><p>以下是Unreal Engine 5中动画系统两个重要API的C++实现方式，分别用于动画开始执行和每帧执行逻辑，和动画蓝图一致,需要重写Animainstace</p>
<p>![[Pasted image 20250402142248.png]]在角色的.h文件中申明一个攻击蒙太奇变量，通过网格体访问动画实例，然后使用其中的蒙太奇播放函数<br>![[Pasted image 20250402142750.png]]</p>
<p>关键api:   Montage_JumpToSection()    Montage_Play()</p>
<h2 id="动画通知事件"><a href="#动画通知事件" class="headerlink" title="动画通知事件"></a>动画通知事件</h2><p>右键在蒙太奇中添加通知，通知是一种事件，动画播放完时可以执行自定义事件，播放音效等。</p>
<h2 id="Kismet数学库"><a href="#Kismet数学库" class="headerlink" title="Kismet数学库"></a>Kismet数学库</h2><h3 id="具有向量运算等强大功能，详情查询UE帮助手册"><a href="#具有向量运算等强大功能，详情查询UE帮助手册" class="headerlink" title="具有向量运算等强大功能，详情查询UE帮助手册"></a>具有向量运算等强大功能，详情查询UE帮助手册</h3><p>![[Pasted image 20250331162234.png]]</p>
<h1 id="反向动力学-IK-inverse-kinematics"><a href="#反向动力学-IK-inverse-kinematics" class="headerlink" title="反向动力学-IK    inverse kinematics"></a>反向动力学-IK    inverse kinematics</h1><h2 id="球体追踪-一种定位距离办法"><a href="#球体追踪-一种定位距离办法" class="headerlink" title="球体追踪-一种定位距离办法"></a>球体追踪-一种定位距离办法</h2><h3 id="控制骨架-animation动画"><a href="#控制骨架-animation动画" class="headerlink" title="控制骨架-animation动画"></a>控制骨架-animation动画</h3><p>可以根据末端执行器移动骨骼位置，指定末端骨骼，IK骨骼，或者添加虚拟骨骼，<br>一：导入骨架<br>二：创建足部追踪函数<br>三：添加新参数：rig element key<br>四：添加get transform函数<br>![[Pasted image 20250331180247.png]]<br>![[Pasted image 20250331180347.png]]<br>![[Pasted image 20250331180436.png]]</p>
<h2 id="添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置"><a href="#添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置" class="headerlink" title="添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置"></a>添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置</h2><p>经常使用插值来使变量平滑过渡</p>
<h2 id="全身IK-UE5新增-难点"><a href="#全身IK-UE5新增-难点" class="headerlink" title="全身IK-UE5新增(难点)"></a>全身IK-UE5新增(难点)</h2><p>对身体的任意一串骨骼指定末端执行器</p>
<h1 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h1><p>所有网格体都具有碰撞属性<br>1.无碰撞<br>2.仅仅查询-无物理模拟（用于射线检测之类…）<br>3.物理模拟<br>4.开启碰撞-支持物理模拟和射线检测，性能成本最高</p>
<p>简单碰撞与复杂碰撞</p>
<p>支持重力与推力….需要手动启用</p>
<h1 id="重叠事件"><a href="#重叠事件" class="headerlink" title="重叠事件"></a>重叠事件</h1><p>使用前必须将角色和角色身上的组件重叠事件设为true</p>
<p>球体组件 </p>
<p>当两个物体重叠时就会触发这个事件，可以</p>
<p>组件开始重叠（用得最多）</p>
<p>虚幻5中的委托</p>
<p>观察者模式-</p>
<p>委托是一种特殊的类，组件对象旗下有许多的委托，比如组件重叠事件，组件开始重叠，组件结束重叠，可以储存观察者列表，可以为某一个特定对象创造委托。并广播这个委托。<br>![[Pasted image 20250401165837.png]]<br>组件继承关系↑</p>
<p>C++实现：<br>需要创建一个回调函数，这个回调函数可以提供许多关于回调函数的信息，绑定到动态多播委托，要绑定必须对反射系统可见，需要加上UFUNCTION()，因为这种类型的委托可以被蓝图访问</p>
<p>访问&#x3D;&#x3D;组件对象&#x3D;&#x3D;下面的oncomponentBeginOverlap函数下的AddDynamic(用户对象，回调函数的地址)</p>
<p>然后回调函数就会在组件重叠的时候被触发。<br>Tips:在虚幻5中要重写继承的虚函数，需要移除UFUCTION等宏，因为会隐式继承一个宏。super常用于保留原函数的功能</p>
<h1 id="骨骼插槽"><a href="#骨骼插槽" class="headerlink" title="骨骼插槽"></a>骨骼插槽</h1><h1 id="动画重定向-反向目标定位"><a href="#动画重定向-反向目标定位" class="headerlink" title="动画重定向-反向目标定位"></a>动画重定向-反向目标定位</h1><p>1.根据导入的骨骼创建IK骨架，设置反相目标根节点（是所有骨骼中联系其它骨骼的核心节点），<br>根据设置的根节点新建链条，指定起始骨骼。从选定骨骼创建新的重新定位链。<br>2.根据需要替换的骨骼创建IK骨架<br>3.创建IK反向目标</p>
<p>tips:强制内联，FORCEINLINE</p>
<h1 id="虚幻引擎拾取系统实现方案总结"><a href="#虚幻引擎拾取系统实现方案总结" class="headerlink" title="虚幻引擎拾取系统实现方案总结"></a>虚幻引擎拾取系统实现方案总结</h1><h2 id="基于重叠事件的拾取系统实现"><a href="#基于重叠事件的拾取系统实现" class="headerlink" title="基于重叠事件的拾取系统实现"></a>基于重叠事件的拾取系统实现</h2><h3 id="核心实现步骤"><a href="#核心实现步骤" class="headerlink" title="核心实现步骤"></a>核心实现步骤</h3><ol>
<li><p><strong>物品基类(AItem)创建</strong></p>
<ul>
<li>继承自<code>AActor</code></li>
<li>包含<code>USphereComponent</code>用于碰撞检测</li>
<li>实现<code>PickUp</code>虚函数供子类重写</li>
</ul>
</li>
<li><p><strong>关键代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item.h关键部分</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere) </span><br><span class="line">USphereComponent* CollisionSphere;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnBeginOverlap</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item.cpp关键部分</span></span><br><span class="line">CollisionSphere-&gt;OnComponentBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AItem::OnBeginOverlap);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AItem::OnBeginOverlap</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(APawn* Picker = <span class="built_in">Cast</span>&lt;APawn&gt;(OtherActor))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PickUp</span>(Picker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line"># 虚幻引擎枚举</span><br><span class="line">在普通枚举中加E，枚举变量前加ECS_   ，枚举后面限定枚举变量的数据结构大小以避免额外开销</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250402083301.</span>png]]</span><br><span class="line">在蓝图中指定显示属性</span><br><span class="line">![[Pasted image <span class="number">20250402083446.</span>png]]</span><br><span class="line"></span><br><span class="line"># 在动画实例中更新角色持有武器的状态</span><br><span class="line">![[Pasted image <span class="number">20250402084241.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250402084722.</span>png]]利用枚举选择动画状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 音效</span><br><span class="line"></span><br><span class="line">sound_cue功能可以修改音效，而不改动原本的音频资源</span><br><span class="line"></span><br><span class="line">虚幻<span class="number">5</span>中mate-sounds也可以，优于sound_cue。SFX格式，可以制作随机音效等程序化音效</span><br><span class="line">![[Pasted image <span class="number">20250402160539.</span>png]]![[Pasted image <span class="number">20250402161158.</span>png]]混洗功能</span><br><span class="line"></span><br><span class="line"># UE5的接口类-实际上是一个虚基类</span><br><span class="line">* 将自定义的函数暴露给作用类，而不用考虑类型，使用时作用类继承接口类重写虚函数即可，接口可以实现各个类进行通信，下面是个例子，</span><br><span class="line">![[Pasted image <span class="number">20250404092303.</span>png]]</span><br><span class="line">如果检测碰撞返回的类被成功转换为接口类，则执行接口函数，因为接口类本身就是传递对象的父类，所以能转换成功。然后调用其中的函数将数据传输给另一个类，实现通信。</span><br><span class="line">![[Pasted image <span class="number">20250404092750.</span>png]]</span><br><span class="line"></span><br><span class="line"># 向量点积-求两个向量之间的夹角-返回的是标量无方向</span><br><span class="line">![[Pasted image <span class="number">20250404094522.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 向量归一化</span><br><span class="line">![[Pasted image <span class="number">20250404094726.</span>png]]</span><br><span class="line"></span><br><span class="line">打击点位置-物体位置=指向打击点位置的向量，下面使用UE5的点积式求解角度，此时DotProduct为Cosθ</span><br><span class="line">![[Pasted image <span class="number">20250404095327.</span>png]]</span><br><span class="line">然后计算反余弦即可求出角度θ![[Pasted image <span class="number">20250404110709.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404113610.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 向量叉积</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404114917.</span>png]]</span><br><span class="line">![[Pasted image <span class="number">20250404115350.</span>png]]</span><br><span class="line"></span><br><span class="line">虚幻采用左手坐标系</span><br><span class="line"></span><br><span class="line"># Cascade特效与Niagara</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cascade特效系统</span><br><span class="line">![[Pasted image <span class="number">20250404144744.</span>png]]![[Pasted image <span class="number">20250404145002.</span>png]]</span><br><span class="line">Niagara：</span><br><span class="line">至少需要一个发射器，可以直接挂载在物体上</span><br><span class="line"><span class="number">1.</span>发射器</span><br><span class="line"><span class="number">2.</span>精灵图：会自动面向玩家</span><br><span class="line"><span class="number">3.</span></span><br><span class="line"></span><br><span class="line">在角色身上生成特效：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C++方法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可破坏网格体</span><br><span class="line">场系统：是一个ACtor类</span><br><span class="line">![[Pasted image <span class="number">20250404151132.</span>png]]![[Pasted image <span class="number">20250404151214.</span>png]]</span><br><span class="line">径向衰减，</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404151704.</span>png]]</span><br><span class="line">线性力能打飞物体![[Pasted image <span class="number">20250404151742.</span>png]]</span><br><span class="line">需要一个向量来获取</span><br><span class="line"></span><br><span class="line">C++可以创建一个临时立场，并暴露给蓝图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建一个可破坏物体，并将其挂载在ACTOR上</span><br><span class="line">![[Pasted image <span class="number">20250404153252.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404153622.</span>png]]![[Pasted image <span class="number">20250404153729.</span>png]]</span><br><span class="line">必须包含此模块</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 蓝图原生事件</span><br><span class="line">![[Pasted image <span class="number">20250404154338.</span>png]]</span><br><span class="line"></span><br><span class="line">一旦使用，可以在蓝图和C++中同时使用接口类的接口函数，但是你的虚函数会加上特殊后缀，这样就能将接口暴露给策划或者美术使用![[Pasted image <span class="number">20250404154538.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面一行是加上后缀后的新方法![[Pasted image <span class="number">20250404154728.</span>png]]</span><br><span class="line"></span><br><span class="line">从指定位置生成物体</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404160134.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404160412.</span>png]]一旦发生事件重叠，则消除物品</span><br><span class="line"></span><br><span class="line">C++实现生成物品：</span><br><span class="line">![[Pasted image <span class="number">20250404160912.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先声明一个UClass类暴露给编辑器，然后去编辑器指定蓝图类，则可以用C++生成一个蓝图类（非常重要！）</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404161558.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404161755.</span>png]]</span><br><span class="line">限定修饰器，取代UClass,可以限定继承蓝图类。最好使用它。</span><br><span class="line"></span><br><span class="line">tips:蓝图也可以继承</span><br><span class="line"></span><br><span class="line"># 自定义组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 伤害</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以在任何角色类中重写伤害函数，这是虚幻自带的伤害函数</span><br><span class="line">![[Pasted image <span class="number">20250405132812.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250405133835.</span>png]]</span><br><span class="line">将健康值限制到<span class="number">0</span>和最大生命之间</span><br><span class="line">![[Pasted image <span class="number">20250405134525.</span>png]]![[Pasted image <span class="number">20250405134850.</span>png]]</span><br><span class="line">![[Pasted image <span class="number">20250405140837.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 追踪角色</span><br><span class="line">利用takedamage函数可以获取攻击对象，将攻击对象存入指针，这样就你能访问攻击对象的属性和方法</span><br><span class="line">![[Pasted image <span class="number">20250406102654.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406102830.</span>png]]</span><br><span class="line">例如判断攻击角色与被攻击角色的距离</span><br><span class="line">![[Pasted image <span class="number">20250406102949.</span>png]]</span><br><span class="line">设置默认半径</span><br><span class="line">![[Pasted image <span class="number">20250406103010.</span>png]]</span><br><span class="line">如果距离大于攻击半径，将攻击对象置空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AI-导航网格</span><br><span class="line"></span><br><span class="line">## 首先需要创建导航网格体网格![[Pasted image <span class="number">20250406113807.</span>png]]</span><br><span class="line">show navigation控制台开启显示导航命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 混合空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406121727.</span>png]]</span><br><span class="line">这个是动画蓝图中的状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">混合空间可以组合多种动画，并根据变量大小执行相应过渡动画。</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406122450.</span>png]]</span><br><span class="line">设置这个之后可以将移动交给AI托管，</span><br><span class="line">![[Pasted image <span class="number">20250406122537.</span>png]]</span><br><span class="line">必须包含这个头文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 导航目标</span><br><span class="line">![[Pasted image <span class="number">20250406123934.</span>png]]</span><br><span class="line"></span><br><span class="line">可以利用一个角色指针数组将导航点存在里面，需要开启AI模块，并包含相关头文件</span><br><span class="line">![[Pasted image <span class="number">20250406124514.</span>png]]![[Pasted image <span class="number">20250406124901.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406124934.</span>png]]</span><br><span class="line">创建一个AI控制器，并将目标设为导航点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406125423.</span>png]]</span><br><span class="line"># UE5 AI移动请求代码总结</span><br><span class="line"></span><br><span class="line">## 代码功能</span><br><span class="line">实现AI导航移动并在路径点上绘制调试球体</span><br><span class="line">前面将导航点暴露给了蓝图，所以能直接用蓝图添加导航点</span><br><span class="line">## 代码解析</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">FAIMoveRequest MoveRequest;</span><br><span class="line">MoveRequest.<span class="built_in">SetGoalActor</span>(PatrolTarget);</span><br><span class="line">MoveRequest.<span class="built_in">SetAcceptanceRadius</span>(<span class="number">15.f</span>);</span><br><span class="line">FNavPathSharedPtr NavPath;</span><br><span class="line">EnemyController-&gt;<span class="built_in">MoveTo</span>(MoveRequest, &amp;NavPath);</span><br><span class="line">TArray&lt;FNavPathPoint&gt;&amp; PathPoints = NavPath-&gt;<span class="built_in">GetPathPoints</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Point : PathPoints)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FVector&amp; Location = Point.Location;</span><br><span class="line">    <span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), Location, <span class="number">12.f</span>, <span class="number">12</span>, FColor::Green, <span class="literal">false</span>, <span class="number">10.f</span>);</span><br><span class="line">&#125;```</span><br><span class="line">### <span class="number">1.</span> 创建移动请求</span><br><span class="line"></span><br><span class="line">- `FAIMoveRequest` - AI移动请求类</span><br><span class="line">### <span class="number">2.</span> 设置移动目标</span><br><span class="line">- `<span class="built_in">SetGoalActor</span>(PatrolTarget)` - 设置目标Actor</span><br><span class="line">- `PatrolTarget` - 要移动到的目标(AActor指针)</span><br><span class="line">### <span class="number">3.</span> 设置接受半径</span><br><span class="line">- `<span class="built_in">SetAcceptanceRadius</span>(<span class="number">15.f</span>)` - 到达判定半径(<span class="number">15</span>厘米)</span><br><span class="line">### <span class="number">4.</span>执行移动命令</span><br><span class="line"></span><br><span class="line">- `FNavPathSharedPtr` - 导航路径共享指针</span><br><span class="line">- `EnemyController-&gt;<span class="built_in">MoveTo</span>()` - 执行移动</span><br><span class="line">    - 参数<span class="number">1</span>: 配置好的移动请求  </span><br><span class="line">    - 参数<span class="number">2</span>: 输出导航路径信息    </span><br><span class="line">### <span class="number">5.</span> 获取路径点</span><br><span class="line">- `<span class="built_in">GetPathPoints</span>()` - 获取路径点数组</span><br><span class="line">- `TArray&lt;FNavPathPoint&gt;` - 路径点动态数组</span><br><span class="line">### <span class="number">6.</span> 绘制调试球体</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">DrawDebugSphere</span>()`参数:</span><br><span class="line">    <span class="number">1.</span> 世界上下文</span><br><span class="line">    <span class="number">2.</span> 球体位置(FVector)</span><br><span class="line">    <span class="number">3.</span> 半径(<span class="number">12</span>厘米)</span><br><span class="line">    <span class="number">4.</span> 细分段数(<span class="number">12</span>)</span><br><span class="line">    <span class="number">5.</span> 颜色(FColor::Green)</span><br><span class="line">    <span class="number">6.</span> 是否持久化(<span class="literal">false</span>)</span><br><span class="line">    <span class="number">7.</span> 显示时间(<span class="number">10</span>秒</span><br><span class="line"></span><br><span class="line">这段代码用于在Unreal Engine <span class="number">5</span>中可视化显示AI的导航路径点，通过在每一个路径点位置绘制绿色球体来辅助调试。</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Point : PathPoints)  <span class="comment">// 遍历导航路径中的所有点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FVector&amp; Location = Point.Location;  <span class="comment">// 获取当前路径点的3D位置坐标</span></span><br><span class="line">    <span class="built_in">DrawDebugSphere</span>(           <span class="comment">// 绘制调试球体函数</span></span><br><span class="line">        <span class="built_in">GetWorld</span>(),            <span class="comment">// 参数1：获取当前游戏世界上下文</span></span><br><span class="line">        Location,              <span class="comment">// 参数2：球体中心位置(使用路径点坐标)</span></span><br><span class="line">        <span class="number">12.f</span>,                  <span class="comment">// 参数3：球体半径(12厘米)</span></span><br><span class="line">        <span class="number">12</span>,                    <span class="comment">// 参数4：球体细分精度(12个分段)</span></span><br><span class="line">        FColor::Green,         <span class="comment">// 参数5：球体颜色(绿色)</span></span><br><span class="line">        <span class="literal">false</span>,                 <span class="comment">// 参数6：是否持久化(false=仅当前帧显示)</span></span><br><span class="line">        <span class="number">10.f</span>                  <span class="comment">// 参数7：显示持续时间(10秒)</span></span><br><span class="line">    );</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406173827.</span>png]]</span><br><span class="line">如果距离小于等于半径返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406175408.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">巡逻点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定时器</span><br><span class="line">![[Pasted image <span class="number">20250407212016.</span>png]]</span><br><span class="line"></span><br><span class="line">需要回调函数，回调函数就是需要执行的函数</span><br><span class="line">定义一个计时器： ==FTimerHandle TimerHandle;==</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类型转换</span><br><span class="line">![[Pasted image <span class="number">20250408184925.</span>png]]</span><br><span class="line"></span><br><span class="line"># HUD</span><br><span class="line">![[Pasted image <span class="number">20250408190840.</span>png]]</span><br><span class="line"></span><br><span class="line">用CPP管理UI</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250408192040.</span>png]]</span><br><span class="line"></span><br><span class="line">通过玩家控制器访问HUD然后访问UI里的方法</span><br><span class="line"></span><br><span class="line"># 标签</span><br><span class="line">![[Pasted image <span class="number">20250408193302.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抛射物组件</span><br><span class="line">![[Pasted image <span class="number">20250410203011.</span>png]]![[Pasted image <span class="number">20250410213746.</span>png]]</span><br><span class="line">![[Pasted image <span class="number">20250410214212.</span>png]]</span><br><span class="line">获取手部插槽位置并生成物体</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 常用蓝图技巧</span><br><span class="line">![[Pasted image <span class="number">20250411111248.</span>png]]挂载一个物体给径向力，一旦被几种则应用这个力</span><br><span class="line">![[Pasted image <span class="number">20250411140025.</span>png]]</span><br><span class="line">这个函数会将你传进去的向量赋值控制器视口的位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250411140620.</span>png]]</span><br><span class="line">这段C++ 代码定义了一个名为 `PrimaryInteract` 的函数，属于 `UInteractionComponent`-Actor组件类。其主要功能是实现一个基本的交互逻辑：从拥有该组件的Actor的视角发射一条射线，检测是否与动态世界类型的物体发生碰撞，如果碰撞到了实现了 `ISGameplayInterface` 接口的Actor，则调用该Actor的 `Execute_Interact` 函数来执行交互操作。</span><br><span class="line"></span><br><span class="line">### 代码逐行解析</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> ​**​函数声明​**​：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">void</span> UInteractionComponent::<span class="built_in">PrimaryInteract</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这是 <code>UInteractionComponent</code> 类中的 <code>PrimaryInteract</code> 函数声明，返回类型为 <code>void</code>，表示该函数不返回任何值。</p>
<ol start="2">
<li>​<strong>​设置碰撞查询参数​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FCollisionObjectQueryParams ObjectQueryParams;</span><br><span class="line">ObjectQueryParams.<span class="built_in">AddObjectTypesToQuery</span>(ECC_WorldDynamic);</span><br></pre></td></tr></table></figure>

<p>创建一个 <code>FCollisionObjectQueryParams</code> 类型的对象 <code>ObjectQueryParams</code>，用于设置射线检测时要查询的对象类型，这里添加了 <code>ECC_WorldDynamic</code> 类型，即动态世界类型的物体。</p>
<ol start="3">
<li>​<strong>​获取拥有者Actor的相关信息​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AActor* MyOwner = <span class="built_in">GetOwner</span>();</span><br><span class="line">FVector EyeLocation;</span><br><span class="line">FRotator EyeRotation;</span><br><span class="line">MyOwner-&gt;<span class="built_in">GetActorEyesViewPoint</span>(EyeLocation, EyeRotation);</span><br></pre></td></tr></table></figure>

<p>通过 <code>GetOwner()</code> 获取拥有该组件的Actor，并将其存储在 <code>MyOwner</code> 中。然后调用 <code>GetActorEyesViewPoint</code> 函数获取该Actor的视角位置 <code>EyeLocation</code> 和视角旋转 <code>EyeRotation</code>。</p>
<ol start="4">
<li>​<strong>​计算射线终点​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FVector End = EyeLocation + (EyeRotation.<span class="built_in">Vector</span>()) * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>根据视角位置 <code>EyeLocation</code> 和视角方向（通过 <code>EyeRotation.Vector()</code> 获取方向向量），计算出射线延伸1000单位长度后的终点 <code>End</code>。</p>
<ol start="5">
<li>​<strong>​进行射线检测​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FHitResult Hit;</span><br><span class="line"><span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByObjectType</span>(Hit, EyeLocation, End, ObjectQueryParams);</span><br></pre></td></tr></table></figure>

<p>使用 <code>GetWorld()-&gt;LineTraceSingleByObjectType</code> 函数进行一次基于对象类型的射线检测，将检测结果存储在 <code>Hit</code> 中。<code>Hit</code> 是一个 <code>FHitResult</code> 类型的变量，用于存储射线与物体碰撞的详细信息。</p>
<ol start="6">
<li>​<strong>​获取碰撞到的Actor并执行交互​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AActor* HitActor = Hit.<span class="built_in">GetActor</span>();</span><br><span class="line"><span class="keyword">if</span> (HitActor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (HitActor-&gt;<span class="built_in">Implements</span>&lt;ISGameplayInterface&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        APawn* MyPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(MyOwner);</span><br><span class="line">        ISGameplayInterface::<span class="built_in">Execute_Interact</span>(HitActor, MyPawn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 <code>Hit.GetActor()</code> 获取碰撞到的Actor，并存储在 <code>HitActor</code> 中。如果 <code>HitActor</code> 不为空，则检查该Actor是否实现了 <code>ISGameplayInterface</code> 接口。如果实现了，将拥有该组件的Actor转换为 <code>APawn</code> 类型（存储在 <code>MyPawn</code> 中），然后调用 <code>ISGameplayInterface::Execute_Interact</code> 函数，传入碰撞到的Actor和拥有者的Pawn，以执行交互操作。</p>
<h3 id="可能的改进方向或注意事项"><a href="#可能的改进方向或注意事项" class="headerlink" title="可能的改进方向或注意事项"></a>可能的改进方向或注意事项</h3><ol>
<li>​<strong>​错误处理​</strong>​：目前代码没有对 <code>Cast&lt;APawn&gt;(MyOwner)</code> 可能失败的情况进行处理。如果 <code>MyOwner</code> 不是 <code>APawn</code> 类型，<code>Cast</code> 将返回 <code>nullptr</code>，后续调用 <code>Execute_Interact</code> 可能会导致崩溃，应该添加相应的错误处理逻辑。</li>
<li>​<strong>​射线长度​</strong>​：射线长度固定为1000单位，这可能不适用于所有场景，可以考虑将其设置为可配置的参数，以便根据具体需求进行调整。</li>
<li>​<strong>​接口检查​</strong>​：在调用 <code>Implements&lt;ISGameplayInterface&gt;()</code> 之前，可以考虑先检查 <code>HitActor</code> 是否为 <code>nullptr</code>，以避免潜在的空指针异常。</li>
</ol>
<p>![[Pasted image 20250411141402.png]]<br>主要功能是进行射线检测（这里使用的是<code>SweepMultiByObjectType</code>，检测特定类型对象），并在检测到碰撞时执行一些交互逻辑，同时绘制调试信息来可视化检测结果。</p>
<h3 id="代码详细解释"><a href="#代码详细解释" class="headerlink" title="代码详细解释"></a>代码详细解释</h3><ol>
<li>​<strong>​变量声明与初始化​</strong>​：<ul>
<li><code>TArray&lt;FHitResult&gt; Hits;</code>：声明一个数组<code>Hits</code>，用于存储射线检测到的碰撞结果。</li>
<li><code>float Radius = 30.f;</code>：定义一个浮点数变量<code>Radius</code>，表示检测形状（这里是球体）的半径为30个单位。</li>
<li><code>FCollisionShape Shape;</code>：声明一个碰撞形状对象<code>Shape</code>。</li>
<li><code>Shape.SetSphere(Radius);</code>：将<code>Shape</code>设置为一个半径为<code>Radius</code>的球体形状。</li>
</ul>
</li>
<li>​<strong>​射线检测​</strong>​：<ul>
<li><code>bool bBlockingHit = GetWorld()-&gt;SweepMultiByObjectType(Hits, EyeLocation, End, FQuat::Identity, ObjectQueryParams, Shape);</code></li>
<li>使用<code>SweepMultiByObjectType</code>函数在游戏世界中进行射线检测。它从<code>EyeLocation</code>位置开始，到<code>End</code>位置结束，使用单位四元数（表示没有旋转）<code>FQuat::Identity</code>，根据<code>ObjectQueryParams</code>指定的对象类型查询参数，以及前面定义的球体形状<code>Shape</code>，将检测到的碰撞结果存储在<code>Hits</code>数组中，并返回是否发生了阻挡碰撞（即是否有物体完全挡住了射线），结果存储在<code>bBlockingHit</code>中。</li>
</ul>
</li>
<li>​<strong>​设置线条颜色​</strong>​：<ul>
<li><code>FColor LineColor = bBlockingHit? FColor::Green : FColor::Red;</code>：根据是否有阻挡碰撞（<code>bBlockingHit</code>）来设置线条颜色，如果有阻挡碰撞则为绿色，否则为红色。</li>
</ul>
</li>
<li>​<strong>​遍历碰撞结果并执行交互逻辑​</strong>​：<ul>
<li><code>for (FHitResult Hit : Hits)</code>：遍历<code>Hits</code>数组中的每一个碰撞结果。</li>
<li><code>AActor* HitActor = Hit.GetActor();</code>：获取碰撞到的Actor对象。</li>
<li><code>if (HitActor)</code>：检查碰撞到的Actor是否存在。</li>
<li><code>if (HitActor-&gt;Implements&lt;USGameplayInterface&gt;())</code>：检查碰撞到的Actor是否实现了<code>USGameplayInterface</code>接口。</li>
<li>如果上述条件都满足：<ul>
<li><code>APawn* MyPawn = Cast&lt;APawn&gt;(MyOwner);</code>：尝试将<code>MyOwner</code>转换为<code>APawn</code>类型（假设<code>MyOwner</code>是一个有效的指针，这里可能是当前Actor的拥有者之类的对象）。</li>
<li><code>ISGameplayInterface::Execute_Interact(HitActor, MyPawn);</code>：调用实现了<code>USGameplayInterface</code>接口的Actor的<code>Interact</code>函数，传入碰撞到的Actor和当前Pawn对象，执行交互逻辑。</li>
</ul>
</li>
</ul>
</li>
<li>​<strong>​绘制调试信息​</strong>​：<ul>
<li><code>DrawDebugSphere(GetWorld(), Hit.ImpactPoint, Radius, 32, LineColor, false, 2.0f);</code>：在碰撞点（<code>Hit.ImpactPoint</code>）处绘制一个半径为<code>Radius</code>的球体作为调试可视化，使用<code>LineColor</code>颜色，不持久化（<code>false</code>），线条宽度为2.0个单位。</li>
<li><code>DrawDebugLine(GetWorld(), EyeLocation, End, LineColor, false, 2.0f, 0, 2.0f);</code>：绘制一条从<code>EyeLocation</code>到<code>End</code>的线条作为调试可视化，使用<code>LineColor</code>颜色，不持久化，线条宽度为2.0个单位，线条的生命周期为2.0秒（最后一个参数<code>2.0f</code>表示生命周期）。</li>
</ul>
</li>
</ol>
<p><code>SweepMultiByObjectType</code> 是一个用于进行多对象类型射线检测的函数，以下是对它的详细解释：</p>
<h3 id="SweepMultiByObjectType多对象检测函数原型"><a href="#SweepMultiByObjectType多对象检测函数原型" class="headerlink" title="SweepMultiByObjectType多对象检测函数原型"></a>SweepMultiByObjectType多对象检测函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SweepMultiByObjectType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TArray&lt;FHitResult&gt;&amp; OutHits,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FVector&amp; Start,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FVector&amp; End,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FQuat&amp; Rot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FCollisionQueryParams&amp; Params,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FCollisionObjectQueryParams&amp; ObjectParams,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FCollisionShape&amp; Shape</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol>
<li>​<strong>​<code>OutHits</code>​</strong>​：<ul>
<li>类型：<code>TArray&lt;FHitResult&gt;&amp;</code>，这是一个引用类型的数组，用于存储检测到的碰撞结果。每个 <code>FHitResult</code> 结构体包含了关于碰撞的详细信息，比如碰撞点的位置（<code>ImpactPoint</code>）、法线（<code>ImpactNormal</code>）、碰撞的 Actor（<code>GetActor()</code>）等。函数执行完毕后，会将所有检测到的碰撞结果填充到这个数组中。</li>
</ul>
</li>
<li>​<strong>​<code>Start</code>​</strong>​：<ul>
<li>类型：<code>const FVector&amp;</code>，表示射线的起始位置，即射线从哪里开始发射。</li>
</ul>
</li>
<li>​<strong>​<code>End</code>​</strong>​：<ul>
<li>类型：<code>const FVector&amp;</code>，表示射线的结束位置，射线从起始点沿着直线方向延伸到这个位置。</li>
</ul>
</li>
<li>​<strong>​<code>Rot</code>​</strong>​：<ul>
<li>类型：<code>const FQuat&amp;</code>，四元数，用于表示射线的旋转方向。如果射线是沿着世界坐标系的某个轴向（比如X轴、Y轴、Z轴）或者没有旋转，通常可以使用 <code>FQuat::Identity</code> 来表示没有旋转（单位四元数）。四元数是一种在三维空间中表示旋转的数学结构，它能够避免万向节锁等问题。</li>
</ul>
</li>
<li>​<strong>​<code>Params</code>​</strong>​：<ul>
<li>类型：<code>const FCollisionQueryParams&amp;</code>，这是一个结构体，用于配置射线检测的一些参数。它可以设置诸如是否忽略特定的 Actor、是否进行复杂的碰撞测试（如考虑物理材质等）、检测的层次结构等相关选项。例如，可以通过设置 <code>Params.AddIgnoredActor(SomeActor)</code> 来让检测忽略某个特定的 Actor。</li>
</ul>
</li>
<li>​<strong>​<code>ObjectParams</code>​</strong>​：<ul>
<li>类型：<code>const FCollisionObjectQueryParams&amp;</code>，这个结构体用于指定要检测的对象类型。可以设置检测哪些类别的对象，比如只检测静态网格体（Static Meshes）、角色（Characters）、可移动的平台（Movable Platforms）等。常见的用法有 <code>FCollisionObjectQueryParams::AllObjects</code> 表示检测所有类型的对象，或者通过构造函数指定特定的对象类型集合，如 <code>FCollisionObjectQueryParams(ECollisionChannel::ECC_WorldStatic | ECollisionChannel::ECC_WorldDynamic)</code> 表示检测静态和动态的世界对象。</li>
</ul>
</li>
<li>​<strong>​<code>Shape</code>​</strong>​：<ul>
<li>类型：<code>const FCollisionShape&amp;</code>，表示用于检测的形状。可以是球体（通过 <code>SetSphere</code> 方法设置半径）、胶囊体（<code>SetCapsule</code> 方法设置半径和高度等参数）、盒子（<code>SetBox</code> 方法设置尺寸）等多种形状。在给定的代码中，就是使用球体形状进行检测。</li>
</ul>
</li>
</ol>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>类型：<code>bool</code>，如果射线在检测过程中遇到了阻挡（即有对象完全挡住了射线），则返回 <code>true</code>；如果没有遇到阻挡（射线一直畅通无阻地到达了终点），则返回 <code>false</code>。</li>
</ul>
<p>![[Pasted image 20250411142213.png]]</p>
<h2 id="虚幻定时器"><a href="#虚幻定时器" class="headerlink" title="虚幻定时器"></a>虚幻定时器</h2><p>![[Pasted image 20250411142913.png]]<br>这段代码是使用C++在虚幻引擎（Unreal Engine）中进行定时器的设置操作。具体来说：</p>
<ul>
<li><code>GetWorldTimerManager()</code> 用于获取当前世界上下文对象关联的定时器管理器（<code>FTimerManager</code>），它是虚幻引擎中用于管理定时任务的一个重要组件，可以用来启动、停止、重置定时器等操作。</li>
<li><code>SetTimer()</code> 是 <code>FTimerManager</code> 的一个成员函数，用于设置一个新的定时器。这里设置的定时器相关信息如下：<ul>
<li><code>TimerHandle_PrimaryAttack</code>：这是一个定时器句柄（<code>FTimerHandle</code> 类型），用于唯一标识这个定时器，后续可以通过这个句柄来对定时器进行操作（比如停止它等）。</li>
<li><code>this</code>：表示定时器回调函数的调用者，即当前对象本身，当定时器到期触发回调时，会在这个对象的上下文中执行回调函数。</li>
<li><code>ASCharacter::PrimaryAttack_TimeElapsed</code>：这是一个指向成员函数的指针，指定定时器到期时要调用的函数，从命名来看，它应该是 <code>ASCharacter</code> 类中的一个成员函数，功能可能是处理角色主攻击的时间流逝相关逻辑。</li>
<li><code>0.2f</code>：表示定时器的延迟时间，单位是秒，即从调用 <code>SetTimer</code> 函数开始，经过 0.2 秒后，<code>ASCharacter::PrimaryAttack_TimeElapsed</code> 这个函数将会被调用。</li>
</ul>
</li>
</ul>
<h3 id="属性组件常用方法"><a href="#属性组件常用方法" class="headerlink" title="属性组件常用方法"></a>属性组件常用方法</h3><p>![[Pasted image 20250411152529.png]]</p>
<ol>
<li>首先检查 <code>OtherActor</code> 是否存在（即不为 <code>nullptr</code>）。</li>
<li>如果 <code>OtherActor</code> 存在，尝试从 <code>OtherActor</code> 上通过 <code>GetComponentByClass</code> 方法获取一个类型为 <code>USAttributeComponent</code> 的组件，并使用 <code>Cast</code> 函数将其转换为 <code>USAttributeComponent*</code> 类型的指针 <code>AttributeComp</code>。</li>
<li>接着检查 <code>AttributeComp</code> 是否成功获取到（即不为 <code>nullptr</code>）。</li>
<li>如果 <code>AttributeComp</code> 存在，调用其 <code>ApplyHealthChange</code> 方法，传入参数 <code>-20.0f</code>，这很可能是用于减少某个角色或对象的健康值（例如在游戏中让目标掉血20点</li>
</ol>
<p>![[Pasted image 20250411173007.png]]</p>
<p>这段C++ 代码定义了一个名为 <code>ApplyHealthChange</code> 的函数，属于 <code>USAAttributeComponent</code> 类。该函数的主要功能是处理角色（由 <code>AActor</code> 指针 <code>InstigatorActor</code> 表示）的健康值变化。</p>
<h3 id="代码详细解释-1"><a href="#代码详细解释-1" class="headerlink" title="代码详细解释"></a>代码详细解释</h3><ol>
<li>​<strong>​伤害可行性检查​</strong>​：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetOwner</span>()-&gt;<span class="built_in">CanBeDamaged</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这部分代码检查拥有该属性组件的对象（通过 <code>GetOwner()</code> 获取）是否可以被伤害。如果不能被伤害，函数直接返回 <code>false</code>，表示健康值不会发生变化。<br>2. ​<strong>​记录旧健康值并更新健康值​</strong>​：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> OldHealth = Health;</span><br><span class="line">Health = FMath::<span class="built_in">Clamp</span>(Health + Delta, <span class="number">0.0f</span>, HealthMax);</span><br></pre></td></tr></table></figure>

<p>首先记录当前的健康值到 <code>OldHealth</code> 变量中。然后，通过 <code>FMath::Clamp</code> 函数将当前健康值加上 <code>Delta</code>（传入的健康变化值），并限制在 <code>0.0f</code> 到 <code>HealthMax</code>（最大健康值）之间，更新当前的健康值。</p>
<ol start="3">
<li>​<strong>​计算实际健康变化值并广播事件​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> ActualDelta = Health - OldHealth;</span><br><span class="line">OnHealthChanged.<span class="built_in">Broadcast</span>(InstigatorActor, <span class="keyword">this</span>, Health, ActualDelta);</span><br></pre></td></tr></table></figure>

<p>计算实际的健康变化值 <code>ActualDelta</code>，并通过 <code>OnHealthChanged</code> 事件广播这个变化，将 <code>InstigatorActor</code>、当前的 <code>USAAttributeComponent</code> 对象、当前健康值以及实际变化值作为参数传递出去。</p>
<ol start="4">
<li>​<strong>​处理角色死亡情况​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ActualDelta &lt; <span class="number">0.0f</span> &amp;&amp; Health == <span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ASGameModeBase* GM = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetAuthGameMode</span>&lt;ASGameModeBase&gt;();</span><br><span class="line">    <span class="keyword">if</span> (GM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里可以添加角色死亡后的处理逻辑，目前为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当实际健康变化值为负（即健康值减少）且当前健康值变为 <code>0</code> 时，获取当前世界的授权游戏模式对象 <code>GM</code>（类型为 <code>ASGameModeBase</code>）。如果获取成功，可以在这个条件块中添加角色死亡后的处理逻辑，目前这部分代码块为空。</p>
<ol start="5">
<li>​<strong>​返回结果​</strong>​：</li>
</ol>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ActualDelta != <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>函数最后返回一个布尔值，表示实际健康值是否发生了变化（即 <code>ActualDelta</code> 是否不等于 <code>0</code>）。</p>
<h2 id="虚幻调试方法"><a href="#虚幻调试方法" class="headerlink" title="虚幻调试方法"></a>虚幻调试方法</h2><p>在虚幻引擎（Unreal Engine）中，<code>ensure</code> 是一个用于调试和错误处理的宏，其主要目的是在开发过程中帮助开发者捕捉和验证代码中的假设条件是否成立。与 <code>check</code> 宏不同，<code>ensure</code> 在条件不满足时不会立即中断程序执行，而是记录错误并继续运行，从而允许开发者在不影响用户体验的情况下识别和修复潜在的问题。</p>
<h3 id="ensure-的作用"><a href="#ensure-的作用" class="headerlink" title="ensure 的作用"></a><code>ensure</code> 的作用</h3><ol>
<li><p>​<strong>​条件验证​</strong>​：</p>
<ul>
<li><code>ensure</code> 用于验证某个条件是否为真。如果条件为假，<code>ensure</code> 会记录一条错误日志，并可能触发一些调试行为（如断点），但不会像 <code>check</code> 那样强制终止程序。</li>
</ul>
</li>
<li><p>​<strong>​调试辅助​</strong>​：</p>
<ul>
<li>在开发和测试阶段，<code>ensure</code> 可以帮助开发者捕捉代码中的潜在问题，如未预期的状态、无效的指针引用等，而不会立即中断游戏或应用程序的执行。</li>
</ul>
</li>
<li><p>​<strong>​性能考虑​</strong>​：</p>
<ul>
<li>由于 <code>ensure</code> 在条件不满足时不会立即终止程序，因此在发布版本中，<code>ensure</code> 的开销通常比 <code>check</code> 小。不过，虚幻引擎通常会在发布版本中移除或优化掉 <code>ensure</code> 相关的代码，以减少性能影响。</li>
</ul>
</li>
</ol>
<h3 id="ensure-与-check-的区别"><a href="#ensure-与-check-的区别" class="headerlink" title="ensure 与 check 的区别"></a><code>ensure</code> 与 <code>check</code> 的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>check</code></th>
<th><code>ensure</code></th>
</tr>
</thead>
<tbody><tr>
<td>​<strong>​行为​</strong>​</td>
<td>如果条件为假，立即终止程序并抛出错误。</td>
<td>如果条件为假，记录错误日志，但继续执行程序。</td>
</tr>
<tr>
<td>​<strong>​用途​</strong>​</td>
<td>用于确保程序在关键点上的不变量，确保代码逻辑的正确性。</td>
<td>用于捕捉潜在的问题，但不希望立即中断程序执行。</td>
</tr>
<tr>
<td>​<strong>​适用场景​</strong>​</td>
<td>关键逻辑验证，如函数前置条件、后置条件等。</td>
<td>非关键逻辑验证，如状态检查、可选条件等。</td>
</tr>
<tr>
<td>​<strong>​性能影响​</strong>​</td>
<td>在发布版本中通常被优化掉，但在调试版本中开销较大。</td>
<td>在发布版本中通常被移除或优化，对性能影响较小。</td>
</tr>
</tbody></table>
<h3 id="ensure-的使用示例"><a href="#ensure-的使用示例" class="headerlink" title="ensure 的使用示例"></a><code>ensure</code> 的使用示例</h3><p>以下是一些在虚幻引擎中使用 <code>ensure</code> 的示例：</p>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 1：检查指针是否有效</span></span><br><span class="line">AActor* MyActor = <span class="built_in">GetOwner</span>();</span><br><span class="line"><span class="built_in">ensure</span>(MyActor != <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (MyActor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行需要 MyActor 有效的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2：检查变量范围</span></span><br><span class="line">int32 Health = <span class="built_in">GetHealth</span>();</span><br><span class="line"><span class="built_in">ensure</span>(Health &gt;= <span class="number">0</span> &amp;&amp; Health &lt;= <span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (Health &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Health = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Health &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Health = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 3：检查函数返回值</span></span><br><span class="line"><span class="type">bool</span> bSuccess = <span class="built_in">SomeFunction</span>();</span><br><span class="line"><span class="built_in">ensure</span>(bSuccess);</span><br><span class="line"><span class="keyword">if</span> (!bSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理失败情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ensure-的工作原理"><a href="#ensure-的工作原理" class="headerlink" title="ensure 的工作原理"></a><code>ensure</code> 的工作原理</h3><p>在调试模式下，当 <code>ensure</code> 的条件为假时，虚幻引擎会：</p>
<ol>
<li>​<strong>​记录错误日志​</strong>​：将 <code>ensure</code> 失败的信息记录到日志文件中，包括文件名、行号和失败的条件。</li>
<li>​<strong>​触发调试行为​</strong>​：在某些情况下，可能会触发断点或弹出调试窗口，帮助开发者立即定位问题。</li>
<li>​<strong>​继续执行​</strong>​：不会终止程序，允许开发者观察程序在错误状态下的行为，以便进一步调试。</li>
</ol>
<p>在发布模式下，<code>ensure</code> 通常会被优化掉，因此不会对性能产生影响。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>​<strong>​用于非关键性检查​</strong>​：<code>ensure</code> 应该用于那些即使失败也不会导致严重问题的情况。对于关键的不变量，应该使用 <code>check</code> 来确保代码的正确性。</li>
<li>​<strong>​提供有意义的错误信息​</strong>​：在使用 <code>ensure</code> 时，可以结合 <code>UE_LOG</code> 或其他日志机制，提供更详细的错误信息，帮助快速定位问题。</li>
<li>​<strong>​避免滥用​</strong>​：过度使用 <code>ensure</code> 可能会导致日志文件膨胀，增加调试难度。应根据实际需要合理使用。</li>
</ol>
<h3 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h3><ul>
<li><p>​<strong>​<code>check</code>​</strong>​：用于确保条件为真，否则立即终止程序。</p>
</li>
<li><p>​<strong>​<code>ensureMsgf</code>​</strong>​：类似于 <code>ensure</code>，但允许自定义错误消息，便于提供更多上下文信息。</p>
<p>  cpp</p>
<p>  复制</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ensureMsgf</span>(Health &gt;= <span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Health is negative: %d&quot;</span>), Health);</span><br></pre></td></tr></table></figure>
</li>
<li><p>​<strong>​<code>verify</code>​</strong>​：类似于 <code>check</code>，但在发布版本中不会被移除，仍然会执行检查。</p>
</li>
</ul>
<h3 id="动态多播委托"><a href="#动态多播委托" class="headerlink" title="动态多播委托"></a>动态多播委托</h3><p>这段代码是在虚幻引擎（Unreal Engine）中使用C++语言定义的一个动态多播委托（Dynamic Multicast Delegate）。它声明了一个名为 <code>FOnHealthChanged</code> 的委托类型，该委托可以携带四个参数：</p>
<ol>
<li><code>InstigatorActor</code>：类型为 <code>AActor*</code>，表示引发健康值变化的Actor。</li>
<li><code>USAttributeComponent*</code>：类型为 <code>USAttributeComponent*</code>，可能是一个自定义的用于管理角色属性（比如生命值等）的组件指针。</li>
<li><code>float NewHealth</code>：类型为 <code>float</code>，表示变化后的新生命值。</li>
<li><code>float Delta</code>：类型为 <code>float</code>，表示生命值的变化量（增加或减少的数值）。</li>
</ol>
<h3 id="可能的用途及解答思路"><a href="#可能的用途及解答思路" class="headerlink" title="可能的用途及解答思路"></a>可能的用途及解答思路</h3><p>这种委托通常用于在游戏开发中实现当角色或其他对象的健康值发生变化时，通知多个相关的对象或系统进行相应的处理。例如：</p>
<ul>
<li>​<strong>​UI更新​</strong>​：当角色生命值改变时，通过绑定到这个委托，通知HUD（Heads - Up Display，平视显示器）等UI组件更新显示的生命值条。</li>
<li>​<strong>​音效播放​</strong>​：可以在生命值变化时触发特定的音效，比如受到伤害时的痛苦音效或回复生命值时的恢复音效。</li>
<li>​<strong>​游戏逻辑响应​</strong>​：例如当角色生命值降为0时，触发游戏结束逻辑等。</li>
</ul>
<p>如果要在代码中使用这个委托，一般需要进行以下步骤：</p>
<ol>
<li>​<strong>​声明委托实例​</strong>​：在需要使用该委托的类中声明一个 <code>FOnHealthChanged</code> 类型的成员变量，例如 <code>DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnHealthChanged, ...);</code> 之后，</li>
<li>在类中 &#96;UPROPERTY(BlueprintAssignable, Category &#x3D; “Health”) </li>
<li>FOnHealthChanged OnHealthChanged;<code>（这里使用 </code>BlueprintAssignable<code> 是为了在蓝图中也能绑定函数，</code>Category&#96; 用于在编辑器中分类显示）。</li>
<li>​<strong>​绑定函数​</strong>​：可以在蓝图或者C++代码中通过 <code>OnHealthChanged.AddUFunction(this, FName(&quot;YourFunctionName&quot;));</code> （C++中绑定类内函数）或者蓝图节点来将特定的函数绑定到这个委托上。</li>
<li>​<strong>​调用委托​</strong>​：当角色健康值确实发生变化时，在相应的代码逻辑中调用 <code>OnHealthChanged.Broadcast(InstigatorActor, AttributeComponent, NewHealth, Delta);</code> 来触发所有绑定的函数执行。</li>
</ol>
<h1 id="AI行为树"><a href="#AI行为树" class="headerlink" title="AI行为树"></a>AI行为树</h1><p>需要重写Beginplay()<br>头文件中也需要创建AI行为树对象，在beginpaly中运行<br>![[Pasted image 20250411161843.png]]</p>
<p>![[Pasted image 20250411162416.png]]</p>
<h3 id="行为树节点状态预览"><a href="#行为树节点状态预览" class="headerlink" title="行为树节点状态预览"></a>行为树节点状态预览</h3><p>![[Pasted image 20250411164703.png]]</p>
<p>![[Pasted image 20250411164444.png]]<br>这段代码是一个行为树服务（<code>UBTService</code>）的 <code>TickNode</code> 函数实现，主要用于在行为树执行过程中检查AI控制的棋子（Pawn）与目标Actor之间的距离，并将是否在攻击范围内的结果存储到黑板（Blackboard）组件中。</p>
<p>以下是在虚幻引擎蓝图中使用上述C++代码逻辑的步骤：</p>
<h3 id="1-创建行为树"><a href="#1-创建行为树" class="headerlink" title="1. 创建行为树"></a>1. 创建行为树</h3><p>在虚幻编辑器中，打开内容浏览器，右键点击并选择 <code>AI</code> -&gt; <code>行为树</code> 来创建一个新的行为树资产。命名为例如 <code>MyAITree</code>。</p>
<h3 id="2-创建黑板"><a href="#2-创建黑板" class="headerlink" title="2. 创建黑板"></a>2. 创建黑板</h3><p>同样在内容浏览器中，右键点击并选择 <code>AI</code> -&gt; <code>黑板</code> 来创建一个新的黑板资产。命名为例如 <code>MyBlackboard</code>。</p>
<h3 id="3-在行为树中使用黑板"><a href="#3-在行为树中使用黑板" class="headerlink" title="3. 在行为树中使用黑板"></a>3. 在行为树中使用黑板</h3><p>打开刚才创建的行为树 <code>MyAITree</code>，在行为树的根节点属性中，将 <code>黑板</code> 属性指定为刚刚创建的 <code>MyBlackboard</code>。</p>
<h3 id="4-创建AI控制器类"><a href="#4-创建AI控制器类" class="headerlink" title="4. 创建AI控制器类"></a>4. 创建AI控制器类</h3><p>在内容浏览器中，右键点击并选择 <code>C++类</code> -&gt; 选择或创建一个合适的父类（比如 <code>AIController</code>），命名为例如 <code>MyAIController</code>。编译项目，确保C++代码编译通过。</p>
<h3 id="5-在AI控制器类中关联黑板"><a href="#5-在AI控制器类中关联黑板" class="headerlink" title="5. 在AI控制器类中关联黑板"></a>5. 在AI控制器类中关联黑板</h3><p>打开 <code>MyAIController</code> 的头文件（<code>.h</code> 文件），添加以下代码来声明黑板组件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AIController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAIController.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> AMyAIController : <span class="keyword">public</span> AAIController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    UBlackboardComponent* BlackBoardComp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>MyAIController</code> 的源文件（<code>.cpp</code> 文件）的构造函数或 <code>BeginPlay</code> 函数中初始化黑板组件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAIController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyAIController::<span class="built_in">AMyAIController</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    BlackBoardComp = <span class="built_in">CreateDefaultSubobject</span>&lt;UBlackboardComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BlackBoardComp&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-创建行为树服务类"><a href="#6-创建行为树服务类" class="headerlink" title="6. 创建行为树服务类"></a>6. 创建行为树服务类</h3><p>在内容浏览器中，右键点击并选择 <code>C++类</code> -&gt; 选择或创建一个合适的父类（比如 <code>BTService</code>），命名为例如 <code>S8TService</code>。编译项目。</p>
<h3 id="7-在行为树服务类中关联黑板键"><a href="#7-在行为树服务类中关联黑板键" class="headerlink" title="7. 在行为树服务类中关联黑板键"></a>7. 在行为树服务类中关联黑板键</h3><p>打开 <code>S8TService</code> 的头文件，确保 <code>AttackRangeKey</code> 是一个已声明的成员变量，并且类型合适（比如 <code>FName</code> 类型），例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BehaviorTree/BTService.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;S8TService.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> US8TService : <span class="keyword">public</span> UBTService</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    FName AttackRangeKey;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TickNode</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, <span class="type">float</span> DeltaSeconds)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在源文件中实现 <code>TickNode</code> 函数，就是你提供的那段C++代码（注意修正代码中的语法错误，比如一些乱码和不规范的写法）。</p>
<h3 id="8-在行为树中使用服务"><a href="#8-在行为树中使用服务" class="headerlink" title="8. 在行为树中使用服务"></a>8. 在行为树中使用服务</h3><p>回到行为树 <code>MyAITree</code>，右键点击行为树的节点区域，搜索并添加 <code>S8TService</code> 服务节点。将其放置在合适的位置（比如在根节点下作为子节点）。</p>
<h3 id="9-设置黑板键"><a href="#9-设置黑板键" class="headerlink" title="9. 设置黑板键"></a>9. 设置黑板键</h3><p>选中添加的 <code>S8TService</code> 节点，在细节面板中找到 <code>AttackRangeKey</code> 属性，设置其值为黑板中用于存储是否在攻击范围内的布尔键的名称（例如命名为 <code>bIsInAttackRange</code>）。</p>
<h3 id="10-在黑板中设置初始值"><a href="#10-在黑板中设置初始值" class="headerlink" title="10. 在黑板中设置初始值"></a>10. 在黑板中设置初始值</h3><p>打开 <code>MyBlackboard</code>，创建一个新的布尔类型的键，命名为刚才在服务节点中设置的名称（如 <code>bIsInAttackRange</code>），并设置其初始值为 <code>false</code>。</p>
<h3 id="11-在AI控制器中使用行为树"><a href="#11-在AI控制器中使用行为树" class="headerlink" title="11. 在AI控制器中使用行为树"></a>11. 在AI控制器中使用行为树</h3><p>打开 <code>MyAIController</code> 的源文件，在 <code>Possess</code> 函数中启动行为树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyAIController::Possess</span><span class="params">(APawn* InPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Possess</span>(InPawn);</span><br><span class="line">    <span class="built_in">RunBehaviorTree</span>(MyBTTree); <span class="comment">// 假设MyBTTree是行为树资产的引用，在头文件中声明并赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在头文件中添加相应的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AIController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAIController.generated.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyBTTree.h&quot;</span> <span class="comment">// 引入行为树资产的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> AMyAIController : <span class="keyword">public</span> AAIController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    UBlackboardComponent* BlackBoardComp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    UBehaviorTree* MyBTTree;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Possess</span><span class="params">(APawn* InPawn)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完成以上步骤后，在游戏运行时，AI控制器会按照行为树的逻辑，通过 <code>S8TService</code> 服务节点定期检查AI控制的Pawn与目标Actor之间的距离，并将结果存储在黑板的指定布尔键中，供后续的行为树节点使用。</p>
<h3 id="代码详细解析"><a href="#代码详细解析" class="headerlink" title="代码详细解析"></a>代码详细解析</h3><ol>
<li>​<strong>​调用父类的 <code>TickNode</code> 函数​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Super::<span class="built_in">TickNode</span>(OwnerComp, NodeMemory, DeltaSeconds);</span><br></pre></td></tr></table></figure>

<p>这一步确保行为树服务的父类逻辑也能正常执行，维持行为树系统的基本运行流程。</p>
<ol start="2">
<li>​<strong>​获取黑板组件​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBlackboardComponent* BlackBoardComp = OwnerComp.<span class="built_in">GetBlackboardComponent</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ensure</span>(BlackBoardComp))</span><br></pre></td></tr></table></figure>

<p>通过 <code>OwnerComp</code> 获取与之关联的黑板组件，并使用 <code>ensure</code> 宏进行有效性检查。如果黑板组件不存在，<code>ensure</code> 宏会触发断言（在开发环境下）或进行适当的错误处理（在发布环境下）。</p>
<ol start="3">
<li>​<strong>​获取目标Actor​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AActor* TargetActor = <span class="built_in">Cast</span>&lt;AActor&gt;(BlackBoardComp-&gt;<span class="built_in">GetValueAsObject</span>(<span class="string">&quot;TargetActor&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (TargetActor)</span><br></pre></td></tr></table></figure>
<p>从黑板组件中获取键为 <code>&quot;TargetActor&quot;</code> 的值，并尝试将其转换为 <code>AActor</code> 类型。如果转换成功且目标Actor存在，则继续后续操作。<br>4. ​<strong>​获取AI控制器和其控制的Pawn​</strong>​：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AAIController* MyController = OwnerComp.<span class="built_in">GetAIOwner</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ensure</span>(MyController))</span><br><span class="line">&#123;</span><br><span class="line">    APawn* AIPawn = MyController-&gt;<span class="built_in">GetPawn</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ensure</span>(AIPawn))</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>

<p>首先从 <code>OwnerComp</code> 获取AI的所有者（即AI控制器），然后确保控制器存在。接着通过控制器获取其控制的Pawn，并对Pawn的存在性进行有效性检查。</p>
<ol start="5">
<li>​<strong>​计算距离并判断是否在攻击范围内​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> DistanceTo = FVector::<span class="built_in">Distance</span>(TargetActor-&gt;<span class="built_in">GetActorLocation</span>(), AIPawn-&gt;<span class="built_in">GetActorLocation</span>());</span><br><span class="line"><span class="type">bool</span> bWithinRange = DistanceTo &lt; <span class="number">2000.0f</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>FVector::Distance</code> 函数计算目标Actor和AI控制的Pawn之间的距离，并将距离与设定的阈值 <code>2000.0f</code> 进行比较，判断目标是否在攻击范围内。</p>
<ol start="6">
<li>​<strong>​将结果存储到黑板组件​</strong>​：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlackBoardComp-&gt;<span class="built_in">SetValueAsBool</span>(AttackRangeKey.SelectedKeyName, bWithinRange);</span><br></pre></td></tr></table></figure>

<p>将判断结果（是否在攻击范围内）以布尔值的形式存储到黑板组件中，使用 <code>AttackRangeKey.SelectedKeyName</code> 作为键。</p>
<p>![[Pasted image 20250411170301.png]]<br>这段代码是一个行为树任务（<code>UBTTask</code>）的<code>ExecuteTask</code>函数实现，用于在虚幻引擎（Unreal Engine）中执行一个范围攻击任务。其主要目的是让AI角色从枪口位置向目标角色发射一个投射物（如子弹等）。</p>
<h3 id="代码详细解析-1"><a href="#代码详细解析-1" class="headerlink" title="代码详细解析"></a>代码详细解析</h3><ol>
<li>​<strong>​获取AI控制器和所属角色​</strong>​</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AAIController* MyController = OwnerComp.<span class="built_in">GetAIOwner</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ensure</span>(MyController))</span><br><span class="line">&#123;</span><br><span class="line">    ACharacter* MyPawn = <span class="built_in">Cast</span>&lt;ACharacter&gt;(MyController-&gt;<span class="built_in">GetPawn</span>());</span><br><span class="line">    <span class="keyword">if</span> (MyPawn == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> EBTNodeResult::Failed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 首先通过`OwnerComp.GetAIOwner()`获取行为树组件的AI控制器。</span><br><span class="line">- 使用`ensure`宏检查AI控制器是否有效。如果有效，再通过`MyController-&gt;GetPawn()`获取AI角色所控制的角色（`ACharacter`类型），并检查该角色是否存在。如果角色不存在，直接返回任务失败。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>​<strong>​获取枪口位置和目标角色​</strong>​</li>
</ol>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FVector MuzzleLocation = MyPawn-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetSocketLocation</span>(<span class="string">&quot;Muzzle_01&quot;</span>);</span><br><span class="line">AActor* TargetActor = <span class="built_in">Cast</span>&lt;AActor&gt;(OwnerComp.<span class="built_in">GetBlackboardComponent</span>()-&gt;<span class="built_in">GetValueAsObject</span>(<span class="string">&quot;TargetActor&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (TargetActor == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> EBTNodeResult::Failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 通过`MyPawn-&gt;GetMesh()-&gt;GetSocketLocation(&quot;Muzzle_01&quot;)`获取角色模型上名为`&quot;Muzzle_01&quot;`的插槽位置，即枪口位置。</span><br><span class="line">- 从黑板组件（`BlackboardComponent`）中获取名为`&quot;TargetActor&quot;`的对象，并尝试将其转换为`AActor`类型，得到目标角色。如果目标角色不存在，返回任务失败。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>​<strong>​计算发射方向和旋转​</strong>​</li>
</ol>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FVector Direction = TargetActor-&gt;<span class="built_in">GetActorLocation</span>() - MuzzleLocation;</span><br><span class="line">FRotator MuzzleRotation = Direction.<span class="built_in">Rotation</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 计算从枪口位置到目标角色位置的方向向量`Direction`。</span><br><span class="line">- 根据该方向向量获取对应的旋转`MuzzleRotation`。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>​<strong>​生成投射物​</strong>​</li>
</ol>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FActorSpawnParameters Params;</span><br><span class="line">Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">AActor* NewProj = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, Params);</span><br><span class="line"><span class="keyword">return</span> NewProj? EBTNodeResult::Succeeded : EBTNodeResult::Failed;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 创建一个`FActorSpawnParameters`对象`Params`，并设置其碰撞处理方式为总是生成（`ESpawnActorCollisionHandlingMethod::AlwaysSpawn`）。</span><br><span class="line">- 使用`GetWorld()-&gt;SpawnActor&lt;AActor&gt;`在世界中生成一个指定类（`ProjectileClass`）的投射物，位置为枪口位置，旋转为计算得到的枪口旋转，同时传入生成参数`Params`。如果生成成功，返回任务成功；否则返回任务失败。</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>​<strong>​默认返回失败​</strong>​</li>
</ol>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> EBTNodeResult::Failed;</span><br></pre></td></tr></table></figure>

<p>如果在上述过程中没有提前返回成功或失败，最后返回任务失败。</p>
<h1 id="C-与UMG案例"><a href="#C-与UMG案例" class="headerlink" title="C++与UMG案例"></a>C++与UMG案例</h1><p>在Unreal Engine中使用C++创建一个简单的3D UI伤害数字，通常涉及以下几个步骤：</p>
<ol>
<li>​<strong>​创建UI组件​</strong>​：<ul>
<li>使用UMG（Unreal Motion Graphics）创建一个UI小部件，用于显示伤害数字。UMG允许你设计UI元素并在游戏中使用它们。</li>
</ul>
</li>
<li>​<strong>​绑定UI事件​</strong>​：<ul>
<li>在C++中，你需要创建一个UI控件类，并将其与UMG小部件绑定。这通常涉及到创建一个继承自<code>UUserWidget</code>的C++类。</li>
</ul>
</li>
<li>​<strong>​处理伤害事件​</strong>​：<ul>
<li>在游戏逻辑中，当角色受到伤害时，触发一个事件来显示伤害数字。</li>
</ul>
</li>
<li>​<strong>​动画和显示​</strong>​：<ul>
<li>实现伤害数字的动画效果，例如从屏幕外飞入并逐渐消失。</li>
</ul>
</li>
</ol>
<p>下面是一个简化的示例，展示如何在C++中创建一个基本的伤害数字UI：</p>
<h3 id="步骤1：创建UMG小部件"><a href="#步骤1：创建UMG小部件" class="headerlink" title="步骤1：创建UMG小部件"></a>步骤1：创建UMG小部件</h3><ol>
<li>打开Unreal Editor，创建一个新的UMG小部件。</li>
<li>添加一个<code>TextBlock</code>控件，并设置其属性，如字体大小、颜色和位置。</li>
<li>将UMG小部件保存为一个蓝图类（例如<code>UDamageNumberWidget</code>）。</li>
</ol>
<h3 id="步骤2：创建C-UI控件类"><a href="#步骤2：创建C-UI控件类" class="headerlink" title="步骤2：创建C++ UI控件类"></a>步骤2：创建C++ UI控件类</h3><p>在你的C++项目中，创建一个新的C++类，继承自<code>UUserWidget</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/UMG.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/Slate/SObjectWidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/IUMGModule.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/UMGStyle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/Core/Public/Misc/Paths.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/Core/Public/Misc/FileHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/Core/Public/GenericPlatform/GenericPlatformFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJECT_API</span> UDamageNumberWidget : <span class="keyword">public</span> UUserWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line">    UTextBlock* DamageText;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Damage UI&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDamageText</span><span class="params">(<span class="type">const</span> FString&amp; Text)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3：实现C-UI控件类"><a href="#步骤3：实现C-UI控件类" class="headerlink" title="步骤3：实现C++ UI控件类"></a>步骤3：实现C++ UI控件类</h3><p>在<code>.cpp</code>文件中实现<code>SetDamageText</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DamageNumberWidget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDamageNumberWidget::SetDamageText</span><span class="params">(<span class="type">const</span> FString&amp; Text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DamageText)</span><br><span class="line">    &#123;</span><br><span class="line">        DamageText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(Text));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤4：在游戏中使用UI控件"><a href="#步骤4：在游戏中使用UI控件" class="headerlink" title="步骤4：在游戏中使用UI控件"></a>步骤4：在游戏中使用UI控件</h3><p>在你的游戏逻辑中，创建并显示UI控件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DamageNumberWidget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AYourCharacter::TakeDamage</span><span class="params">(<span class="type">float</span> DamageAmount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建UI控件实例</span></span><br><span class="line">    UDamageNumberWidget* DamageWidget = <span class="built_in">CreateWidget</span>&lt;UDamageNumberWidget&gt;(<span class="built_in">GetWorld</span>(), UDamageNumberWidget::<span class="built_in">StaticClass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DamageWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置伤害文本</span></span><br><span class="line">        DamageWidget-&gt;<span class="built_in">SetDamageText</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d&quot;</span>), FMath::<span class="built_in">RoundToInt</span>(DamageAmount)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将UI控件添加到视口</span></span><br><span class="line">        <span class="keyword">if</span> (GEngine &amp;&amp; GEngine-&gt;GameViewport)</span><br><span class="line">        &#123;</span><br><span class="line">            DamageWidget-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以添加动画效果，例如淡出或移动</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="虚幻5自定义控制台函数"><a href="#虚幻5自定义控制台函数" class="headerlink" title="虚幻5自定义控制台函数"></a>虚幻5自定义控制台函数</h1><p>在Unreal Engine（UE）中，你可以通过使用控制台命令（Console Commands）将函数暴露给控制台，从而便于在游戏运行时调用这些函数。这在调试、测试或实现作弊功能时非常有用。以下是详细的步骤和示例，帮助你实现这一目标：</p>
<h2 id="步骤一：创建一个控制台命令"><a href="#步骤一：创建一个控制台命令" class="headerlink" title="步骤一：创建一个控制台命令"></a>步骤一：创建一个控制台命令</h2><h3 id="1-在C-中创建控制台命令"><a href="#1-在C-中创建控制台命令" class="headerlink" title="1. 在C++中创建控制台命令"></a>1. 在C++中创建控制台命令</h3><p>如果你使用的是C++，可以通过以下步骤创建一个控制台命令：</p>
<h4 id="a-在头文件中声明函数和命令"><a href="#a-在头文件中声明函数和命令" class="headerlink" title="a. 在头文件中声明函数和命令"></a>a. 在头文件中声明函数和命令</h4><p>假设你有一个类 <code>MyGameInstance</code>，你希望在其中添加一个控制台命令来调用某个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/GameInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameInstance.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJECT_API</span> UMyGameInstance : <span class="keyword">public</span> UGameInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">UMyGameInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 初始化时注册控制台命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 控制台命令调用的函数</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Exec)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheatFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="b-在源文件中实现函数"><a href="#b-在源文件中实现函数" class="headerlink" title="b. 在源文件中实现函数"></a>b. 在源文件中实现函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">UMyGameInstance::<span class="built_in">UMyGameInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置此GameInstance在游戏开始时自动创建</span></span><br><span class="line">    bAutoInitialize = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以添加初始化代码</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;MyGameInstance Initialized&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::CheatFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在这里编写你希望执行的作弊逻辑</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Cheat Function Called&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：给玩家增加生命值（假设玩家有一个SetHealth的方法）</span></span><br><span class="line">    APlayerController* PlayerController = <span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line">    <span class="keyword">if</span> (PlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        ACharacter* Character = PlayerController-&gt;<span class="built_in">GetCharacter</span>();</span><br><span class="line">        <span class="keyword">if</span> (Character)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 假设Character有一个SetHealth方法</span></span><br><span class="line">            <span class="comment">// Character-&gt;SetHealth(Character-&gt;GetHealth() + 100);</span></span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Player Health Increased by 100&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​<strong>​说明：​</strong>​</p>
<ul>
<li><code>UFUNCTION(Exec)</code> 宏用于将函数暴露给控制台，使其可以通过控制台命令调用。</li>
<li>确保你的 <code>GameInstance</code> 类在项目设置中被正确设置为默认的 <code>GameInstance</code> 类。</li>
</ul>
<h2 id="步骤二：确保控制台命令可用"><a href="#步骤二：确保控制台命令可用" class="headerlink" title="步骤二：确保控制台命令可用"></a>步骤二：确保控制台命令可用</h2><ol>
<li>​<strong>​启用控制台：​</strong>​<ul>
<li>默认情况下，UE的控制台可以通过按下 <code>~</code> 键（位于 <code>Tab</code> 键上方）打开。如果无法打开，可以在项目设置中检查输入设置，确保没有禁用控制台。</li>
</ul>
</li>
<li>​<strong>​注册控制台命令：​</strong>​<ul>
<li>使用 <code>UFUNCTION(Exec)</code> 宏声明的函数会自动注册为控制台命令。确保你的类（如 <code>GameInstance</code>）在游戏启动时被正确初始化。</li>
</ul>
</li>
</ol>
<h2 id="步骤三：测试控制台命令"><a href="#步骤三：测试控制台命令" class="headerlink" title="步骤三：测试控制台命令"></a>步骤三：测试控制台命令</h2><ol>
<li>​<strong>​运行游戏：​</strong>​<ul>
<li>启动你的游戏，确保 <code>GameInstance</code> 已正确初始化。</li>
</ul>
</li>
<li>​<strong>​打开控制台：​</strong>​<ul>
<li>按下 <code>~</code> 键打开控制台。</li>
</ul>
</li>
<li>​<strong>​输入命令：​</strong>​<ul>
<li>输入 <code>CheatFunction</code>（假设你的函数名为 <code>CheatFunction</code>），然后按下 <code>Enter</code> 键。</li>
</ul>
</li>
<li>​<strong>​查看结果：​</strong>​<ul>
<li>如果一切设置正确，你应该在输出日志中看到 <code>Cheat Function Called</code> 的日志信息，并且作弊逻辑（如增加生命值）应被执行。</li>
</ul>
</li>
</ol>
<h2 id="示例：完整实现增加玩家生命值的作弊功能"><a href="#示例：完整实现增加玩家生命值的作弊功能" class="headerlink" title="示例：完整实现增加玩家生命值的作弊功能"></a>示例：完整实现增加玩家生命值的作弊功能</h2><p>假设你有一个玩家角色类 <code>MyCharacter</code>，其中包含一个 <code>SetHealth</code> 方法：</p>
<h3 id="1-在-MyCharacter-h-中定义方法"><a href="#1-在-MyCharacter-h-中定义方法" class="headerlink" title="1. 在 MyCharacter.h 中定义方法"></a>1. 在 <code>MyCharacter.h</code> 中定义方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJECT_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Health&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetHealth</span><span class="params">(<span class="type">float</span> NewHealth)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Health&quot;</span>)</span><br><span class="line">    <span class="type">float</span> CurrentHealth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-在-MyCharacter-cpp-中实现方法"><a href="#2-在-MyCharacter-cpp-中实现方法" class="headerlink" title="2. 在 MyCharacter.cpp 中实现方法"></a>2. 在 <code>MyCharacter.cpp</code> 中实现方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    CurrentHealth = <span class="number">100.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::SetHealth</span><span class="params">(<span class="type">float</span> NewHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CurrentHealth = FMath::<span class="built_in">Clamp</span>(NewHealth, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Health set to %f&quot;</span>), CurrentHealth);</span><br><span class="line">    <span class="comment">// 这里可以添加更新UI或其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-修改-MyGameInstance-CheatFunction-来调用-SetHealth"><a href="#3-修改-MyGameInstance-CheatFunction-来调用-SetHealth" class="headerlink" title="3. 修改 MyGameInstance::CheatFunction 来调用 SetHealth"></a>3. 修改 <code>MyGameInstance::CheatFunction</code> 来调用 <code>SetHealth</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Engine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::CheatFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Cheat Function Called&quot;</span>));</span><br><span class="line"></span><br><span class="line">    APlayerController* PlayerController = <span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line">    <span class="keyword">if</span> (PlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        ACharacter* Character = PlayerController-&gt;<span class="built_in">GetCharacter</span>();</span><br><span class="line">        <span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsA</span>&lt;AMyCharacter&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            AMyCharacter* MyCharacter = <span class="built_in">Cast</span>&lt;AMyCharacter&gt;(Character);</span><br><span class="line">            <span class="keyword">if</span> (MyCharacter)</span><br><span class="line">            &#123;</span><br><span class="line">                MyCharacter-&gt;<span class="built_in">SetHealth</span>(<span class="number">200.0f</span>); <span class="comment">// 设置生命值为200</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<strong>​注意：​</strong>​</p>
<ul>
<li>确保你的玩家角色类是 <code>AMyCharacter</code> 或者根据实际情况调整类型转换。</li>
<li>你可以根据需要扩展作弊功能，如添加更多控制台命令，调用不同的函数等。</li>
</ul>
<h3 id="额外提示"><a href="#额外提示" class="headerlink" title="额外提示"></a>额外提示</h3><ul>
<li><p>​<strong>​安全性考虑：​</strong>​ 控制台命令可以用于调试和开发，但在发布版本中应谨慎使用，避免被恶意利用。你可以通过编译条件（如 <code>UE_BUILD_SHIPPING</code>）来移除或禁用作弊相关的控制台命令。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !UE_BUILD_SHIPPING</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Exec)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheatFunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>​<strong>​命令参数：​</strong>​ 你可以为控制台命令添加参数，以增加灵活性。例如，允许玩家输入要增加的生命值数量。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Exec)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheatAddHealth</span><span class="params">(<span class="type">float</span> Amount)</span></span>;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::CheatAddHealth</span><span class="params">(<span class="type">float</span> Amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Cheat Add Health Called with Amount: %f&quot;</span>), Amount);</span><br><span class="line"></span><br><span class="line">    APlayerController* PlayerController = <span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line">    <span class="keyword">if</span> (PlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        ACharacter* Character = PlayerController-&gt;<span class="built_in">GetCharacter</span>();</span><br><span class="line">        <span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsA</span>&lt;AMyCharacter&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            AMyCharacter* MyCharacter = <span class="built_in">Cast</span>&lt;AMyCharacter&gt;(Character);</span><br><span class="line">            <span class="keyword">if</span> (MyCharacter)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> NewHealth = MyCharacter-&gt;<span class="built_in">GetCurrentHealth</span>() + Amount;</span><br><span class="line">                MyCharacter-&gt;<span class="built_in">SetHealth</span>(NewHealth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样，你可以在控制台中输入 <code>CheatAddHealth 50</code> 来增加50点生命值。</p>
</li>
<li><p>​<strong>​文档与调试：​</strong>​ 为你的控制台命令编写文档，确保团队成员了解可用的作弊命令及其用途。同时，利用UE的日志系统记录命令调用，便于调试和监控。</p>
</li>
</ul>
<h2 id="继承gamemode并管理角色死亡等事件"><a href="#继承gamemode并管理角色死亡等事件" class="headerlink" title="继承gamemode并管理角色死亡等事件"></a>继承gamemode并管理角色死亡等事件</h2><p>![[Pasted image 20250411174105.png]]<br>这段C++ 代码是基于虚幻引擎（Unreal Engine）的，主要实现了游戏中玩家死亡后的重生逻辑以及记录玩家被击杀的相关日志信息。</p>
<h3 id="具体函数功能分析"><a href="#具体函数功能分析" class="headerlink" title="具体函数功能分析"></a>具体函数功能分析</h3><ol>
<li>​<strong>​<code>ASGameModeBase::RespawnPlayerElapsed</code> 函数​</strong>​<ul>
<li>​<strong>​功能​</strong>​：负责在合适的时机让玩家角色重新生成。</li>
<li>​<strong>​代码细节​</strong>​：<ul>
<li>首先使用 <code>ensure(controller)</code> 来确保传入的 <code>controller</code>（玩家控制器指针）是有效的。如果有效，调用 <code>Controller-&gt;UnPossess()</code> 方法，这会解除玩家控制器与当前所控制的角色之间的关联。</li>
<li>然后调用 <code>RestartPlayer(controller)</code> 方法，该方法会重新生成玩家角色，让玩家可以重新回到游戏中。</li>
</ul>
</li>
</ul>
</li>
<li>​<strong>​<code>ASGameModeBase::OnActorKilled</code> 函数​</strong>​<ul>
<li>​<strong>​功能​</strong>​：当一个 <code>Actor</code>（这里主要关注玩家角色被击杀的情况）被击杀时被调用，处理玩家被击杀后的重生延迟以及记录击杀日志等操作。</li>
<li>​<strong>​代码细节​</strong>​：<ul>
<li>首先将 <code>VictimActor</code> 尝试转换为 <code>ASCharacter</code> 类型的指针 <code>player</code>，因为只有玩家角色才需要进行后续的重生等处理。如果转换成功（即 <code>player</code> 不为空）：<ul>
<li>声明一个 <code>FTimerHandle</code> 类型的变量 <code>TimerHandle_RespawnDelay</code>，用于管理重生延迟定时器。</li>
<li>声明一个 <code>FTimerDelegate</code> 类型的变量 <code>Delegate</code>，并通过 <code>BindUFunction</code> 将当前对象的 <code>RespawnPlayerElapsed</code> 函数绑定到该委托上，同时传入被击杀玩家的控制器指针作为参数。这样在定时器触发时就会调用 <code>RespawnPlayerElapsed</code> 函数来重生玩家。</li>
<li>定义一个 <code>float</code> 类型的变量 <code>RespawnDelay</code> 并赋值为 <code>2.0f</code>，表示重生延迟时间为2秒。</li>
<li>最后通过 <code>GetWorldTimerManager().SetTimer</code> 方法设置一个定时器，当指定的延迟时间（<code>RespawnDelay</code>）到达时，会触发绑定的委托函数 <code>Delegate</code>，并且设置 <code>false</code> 表示该定时器只触发一次。</li>
</ul>
</li>
<li>使用 <code>UE_LOG</code> 宏记录玩家被击杀的日志信息，包括被击杀玩家的名字和击杀者的名字。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="可能的改进或扩展方向"><a href="#可能的改进或扩展方向" class="headerlink" title="可能的改进或扩展方向"></a>可能的改进或扩展方向</h3><ul>
<li>​<strong>​可配置的重生时间​</strong>​：目前重生延迟时间 <code>RespawnDelay</code> 是硬编码为 <code>2.0f</code>，可以考虑从配置文件或游戏设置中读取该值，以便在不同场景或游戏模式下灵活调整。</li>
<li>​<strong>​更多的击杀日志信息​</strong>​：除了记录玩家名字，还可以记录击杀发生的地点、使用的武器等信息，以提供更详细的击杀分析数据。</li>
<li>​<strong>​错误处理优化​</strong>​：对于 <code>Cast</code> 操作，目前只是简单判断是否成功，可以考虑在转换失败时进行更详细的错误记录或处理，比如记录一个警告日志说明转换失败的原因。</li>
</ul>
<h1 id="继承蓝图函数库添加自定义静态函数"><a href="#继承蓝图函数库添加自定义静态函数" class="headerlink" title="继承蓝图函数库添加自定义静态函数"></a>继承蓝图函数库添加自定义静态函数</h1><p>![[Pasted image 20250411174833.png]]</p>
<ol>
<li><p>​<strong>​<code>ApplyDamage</code>函数​</strong>​：</p>
<ul>
<li>​<strong>​功能​</strong>​：对目标角色（<code>TargetActor</code>）应用伤害，伤害由伤害施加者（<code>DamageCauser</code>）造成，伤害量为<code>DamageAmount</code>。</li>
<li>​<strong>​实现逻辑​</strong>​：<ul>
<li>首先通过<code>USAttributeComponent::GetAttributes(TargetActor)</code>获取目标角色的属性组件（<code>AttributeComp</code>）。</li>
<li>如果成功获取到属性组件（即<code>AttributeComp</code>不为空），则调用属性组件的<code>ApplyHealthChange</code>方法，传入伤害施加者和伤害量，来应用健康值的变化，并返回该操作的结果（布尔值）。</li>
<li>如果没有获取到属性组件，则直接返回<code>false</code>，表示伤害应用失败。</li>
</ul>
</li>
</ul>
</li>
<li><p>​<strong>​<code>ApplyDirectionalDamage</code>函数​</strong>​：</p>
<ul>
<li>​<strong>​功能​</strong>​：对目标角色应用带有方向性的伤害，除了伤害施加者、目标角色和伤害量外，还考虑了碰撞结果（<code>HitResult</code>），用于在特定方向上施加冲力。</li>
<li>​<strong>​实现逻辑​</strong>​：<ul>
<li>首先调用<code>ApplyDamage</code>函数尝试对目标角色应用伤害。如果<code>ApplyDamage</code>返回<code>true</code>（即伤害应用成功）：<ul>
<li>从碰撞结果（<code>HitResult</code>）中获取对应的组件（<code>HitComp</code>）。</li>
<li>检查该组件是否正在模拟物理（通过<code>HitComp-&gt;IsSimulatingPhysics(HitResult.BoneName)</code>）。</li>
<li>如果组件正在模拟物理，则通过<code>HitComp-&gt;AddImpulseAtLocation</code>方法在碰撞点（<code>HitResult.ImpactPoint</code>）施加一个冲力，冲力的方向由碰撞法线（<code>HitResult.ImpactNormal</code>）和大小（<code>30000.0f</code>）决定，同时指定了受影响的骨骼名称（<code>HitResult.BoneName</code>）。</li>
</ul>
</li>
<li>最后返回<code>true</code>，表示带有方向性的伤害应用成功。如果<code>ApplyDamage</code>返回<code>false</code>，则整个函数也返回<code>false</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="可能的改进或扩展点"><a href="#可能的改进或扩展点" class="headerlink" title="可能的改进或扩展点"></a>可能的改进或扩展点</h3><ol>
<li>​<strong>​错误处理和日志记录​</strong>​：目前代码在获取属性组件失败或组件不模拟物理时只是简单地返回结果，可以考虑添加一些日志记录，方便调试时了解具体发生了什么情况。例如使用<code>UE_LOG</code>宏（如果是虚幻引擎项目）来记录相关信息。</li>
<li>​<strong>​伤害类型和效果扩展​</strong>​：目前只考虑了简单的健康值变化和方向性冲力，实际游戏中可能需要考虑更多伤害类型（如火焰伤害、毒素伤害等）以及不同的伤害效果（如减速、眩晕等），可以在<code>AttributeComp</code>的<code>ApplyHealthChange</code>方法中进一步扩展相关逻辑。</li>
<li>​<strong>​性能优化​</strong>​：如果频繁调用这些函数，可能需要考虑性能优化，比如减少不必要的组件获取操作等。</li>
</ol>
<p>在虚幻引擎（Unreal Engine）中继承<code>UBlueprintFunctionLibrary</code>有以下几个重要思想和实际用途：</p>
<h3 id="提供可在蓝图中使用的自定义函数"><a href="#提供可在蓝图中使用的自定义函数" class="headerlink" title="提供可在蓝图中使用的自定义函数"></a>提供可在蓝图中使用的自定义函数</h3><p><code>UBlueprintFunctionLibrary</code>是一个基类，用于创建可以在虚幻蓝图系统中调用的自定义函数集合。通过继承它，开发者能够将一些通用的、复杂的或者需要在蓝图层面复用的逻辑封装成函数。这样，关卡设计师、策划人员等非程序员也可以方便地在蓝图节点中使用这些函数，而无需编写实际的C++代码，极大地提高了开发效率和灵活性。例如，在一个RPG游戏中，可以创建一个继承自<code>UBlueprintFunctionLibrary</code>的类，里面包含计算角色经验值升级所需经验的函数，蓝图设计师在设置角色升级逻辑时就可以直接调用这个函数。</p>
<h3 id="代码组织和模块化"><a href="#代码组织和模块化" class="headerlink" title="代码组织和模块化"></a>代码组织和模块化</h3><p>将相关的功能函数集中放在一个继承自<code>UBlueprintFunctionLibrary</code>的类中，有助于对代码进行良好的组织和管理。不同的功能模块可以分别封装在不同的函数库类里，使得代码结构更加清晰，易于维护和扩展。比如，在一个开放世界游戏中，可能会有专门处理环境交互的函数库类，包含检测角色与场景物体碰撞、获取附近资源点等函数；还有处理角色战斗的函数库类，包含计算伤害、应用状态效果等函数。</p>
<h3 id="复用性和一致性"><a href="#复用性和一致性" class="headerlink" title="复用性和一致性"></a>复用性和一致性</h3><p>一旦在<code>UBlueprintFunctionLibrary</code>的派生类中实现了某个函数，就可以在整个项目的多个蓝图中重复使用。这保证了在不同地方调用相同功能时逻辑的一致性，避免了重复编写相同代码导致的潜在错误。例如，计算两点之间距离的函数，在游戏中的寻路系统、物体交互判定等多个场景都可能用到，通过封装在函数库类中，就可以确保在各个地方计算的结果都是准确一致的。</p>
<h3 id="与虚幻引擎生态集成"><a href="#与虚幻引擎生态集成" class="headerlink" title="与虚幻引擎生态集成"></a>与虚幻引擎生态集成</h3><p>虚幻引擎的蓝图系统是其重要的可视化编程工具，<code>UBlueprintFunctionLibrary</code>作为与蓝图系统紧密集成的基类，使得自定义函数能够无缝地融入到引擎的生态系统当中。开发者可以利用蓝图的可视化连线、变量传递等特性，方便地与这些自定义函数进行交互，充分发挥虚幻引擎强大的可视化开发优势。</p>
<p>总之，继承<code>UBlueprintFunctionLibrary</code>主要是为了在虚幻引擎项目中更好地组织、复用代码，并增强代码的可访问性和易用性，以适应不同角色在游戏开发过程中的需求。</p>
<h1 id="meta标识符"><a href="#meta标识符" class="headerlink" title="meta标识符"></a>meta标识符</h1><p>在虚幻引擎（Unreal Engine）中，<code>Meta</code> 是一个非常重要的概念，主要用于 <strong>属性（UPROPERTY）</strong>、<strong>函数（UFUNCTION）</strong> 和 <strong>类（UCLASS）</strong> 的元数据（Metadata）标记，以控制编辑器行为、序列化、蓝图交互等。以下是 <code>Meta</code> 的详细解析：</p>
<hr>
<h2 id="1-Meta-的作用"><a href="#1-Meta-的作用" class="headerlink" title="1. Meta 的作用"></a><strong>1. Meta 的作用</strong></h2><p><code>Meta</code> 用于提供额外的信息或指令，主要影响：</p>
<ul>
<li><p><strong>编辑器 UI 行为</strong>（如分类、显示名称、工具提示）</p>
</li>
<li><p><strong>序列化规则</strong>（如是否保存到磁盘）</p>
</li>
<li><p><strong>蓝图交互</strong>（如是否在蓝图中可见）</p>
</li>
<li><p><strong>运行时行为</strong>（如网络复制条件）</p>
</li>
</ul>
<hr>
<h2 id="2-常见使用场景"><a href="#2-常见使用场景" class="headerlink" title="2. 常见使用场景"></a><strong>2. 常见使用场景</strong></h2><h3 id="1-在-UPROPERTY-中使用-Meta"><a href="#1-在-UPROPERTY-中使用-Meta" class="headerlink" title="(1) 在 UPROPERTY 中使用 Meta"></a><strong>(1) 在 <code>UPROPERTY</code> 中使用 Meta</strong></h3><p>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category &#x3D; “Character”,<br>          meta &#x3D; (DisplayName &#x3D; “生命值”, ToolTip &#x3D; “角色的生命值，范围为0-100”))<br>float Health;</p>
<p><strong>常用 Meta 参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>DisplayName</code></td>
<td>在编辑器中的显示名称（覆盖变量名）</td>
</tr>
<tr>
<td><code>ToolTip</code></td>
<td>鼠标悬停时的提示文本</td>
</tr>
<tr>
<td><code>ClampMin</code>&#x2F;<code>ClampMax</code></td>
<td>限制输入范围（如 <code>ClampMin=&quot;0&quot;</code>）</td>
</tr>
<tr>
<td><code>UIMin</code>&#x2F;<code>UIMax</code></td>
<td>在 Slider 控件中的范围</td>
</tr>
<tr>
<td><code>EditCondition</code></td>
<td>动态控制属性是否可编辑（如 <code>EditCondition=&quot;bIsEditable&quot;</code>）</td>
</tr>
<tr>
<td><code>BlueprintPrivate</code></td>
<td>对蓝图隐藏该属性</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-在-UFUNCTION-中使用-Meta"><a href="#2-在-UFUNCTION-中使用-Meta" class="headerlink" title="(2) 在 UFUNCTION 中使用 Meta"></a><strong>(2) 在 <code>UFUNCTION</code> 中使用 Meta</strong></h3><p>UFUNCTION(BlueprintCallable, Category &#x3D; “AI”,<br>          meta &#x3D; (DisplayName &#x3D; “计算伤害”, Keywords &#x3D; “Damage|Attack”))<br>void CalculateDamage(float BaseDamage);</p>
<p><strong>常用 Meta 参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>Keywords</code></td>
<td>在蓝图搜索时的关键字（用 &#96;</td>
</tr>
<tr>
<td><code>DefaultToSelf</code></td>
<td>自动传递 <code>self</code> 对象（如 <code>DefaultToSelf=&quot;Target&quot;</code>）</td>
</tr>
<tr>
<td><code>HidePin</code></td>
<td>隐藏蓝图中函数的某些引脚</td>
</tr>
<tr>
<td><code>AdvancedDisplay</code></td>
<td>将参数标记为“高级”（默认折叠）</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-在-UCLASS-中使用-Meta"><a href="#3-在-UCLASS-中使用-Meta" class="headerlink" title="(3) 在 UCLASS 中使用 Meta"></a><strong>(3) 在 <code>UCLASS</code> 中使用 Meta</strong></h3><p>UCLASS(Blueprintable, meta &#x3D; (DisplayName &#x3D; “玩家角色”, ShortToolTip &#x3D; “可控制的玩家实体”))<br>class APlayerCharacter : public ACharacter;</p>
<p><strong>常用 Meta 参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>BlueprintType</code></td>
<td>允许该类在蓝图中作为变量类型</td>
</tr>
<tr>
<td><code>IsBlueprintBase</code></td>
<td>允许蓝图继承该类</td>
</tr>
<tr>
<td><code>ChildCanTick</code></td>
<td>子类是否可以重写 <code>Tick</code> 事件</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-高级用法"><a href="#3-高级用法" class="headerlink" title="3. 高级用法"></a><strong>3. 高级用法</strong></h2><h3 id="1-动态编辑条件"><a href="#1-动态编辑条件" class="headerlink" title="(1) 动态编辑条件"></a><strong>(1) 动态编辑条件</strong></h3><p>通过 <code>meta = (EditCondition)</code> 实现属性联动的显隐&#x2F;禁用逻辑：</p>
<p>UPROPERTY(EditAnywhere)<br>bool bUseCustomSpeed;</p>
<p>UPROPERTY(EditAnywhere, meta &#x3D; (EditCondition &#x3D; “bUseCustomSpeed”))<br>float CustomSpeed; &#x2F;&#x2F; 仅当bUseCustomSpeed为true时可编辑</p>
<h3 id="2-网络同步控制"><a href="#2-网络同步控制" class="headerlink" title="(2) 网络同步控制"></a><strong>(2) 网络同步控制</strong></h3><p>UPROPERTY(Replicated, meta &#x3D; (ReplicateCondition &#x3D; “bIsAlive”))<br>float Health; &#x2F;&#x2F; 仅在bIsAlive为true时同步</p>
<h3 id="3-资产引用规则"><a href="#3-资产引用规则" class="headerlink" title="(3) 资产引用规则"></a><strong>(3) 资产引用规则</strong></h3><p>UPROPERTY(EditAnywhere, meta &#x3D; (AllowedClasses &#x3D; “Texture2D,Material”))<br>UObject* VisualAsset; &#x2F;&#x2F; 限制只能选择纹理或材质</p>
<hr>
<h2 id="4-实际案例"><a href="#4-实际案例" class="headerlink" title="4. 实际案例"></a><strong>4. 实际案例</strong></h2><h3 id="案例1：属性分类与工具提示"><a href="#案例1：属性分类与工具提示" class="headerlink" title="案例1：属性分类与工具提示"></a><strong>案例1：属性分类与工具提示</strong></h3><p>UPROPERTY(EditDefaultsOnly, Category &#x3D; “Weapon”,<br>          meta &#x3D; (DisplayName &#x3D; “伤害值”, ToolTip &#x3D; “武器的基础伤害值”))<br>float BaseDamage;</p>
<h3 id="案例2：动态滑块控制"><a href="#案例2：动态滑块控制" class="headerlink" title="案例2：动态滑块控制"></a><strong>案例2：动态滑块控制</strong></h3><p>UPROPERTY(EditAnywhere, meta &#x3D; (UIMin &#x3D; 0, UIMax &#x3D; 100, ClampMin &#x3D; 0, ClampMax &#x3D; 100))<br>int32 AccuracyPercent;</p>
<hr>
<h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a><strong>5. 注意事项</strong></h2><ol>
<li><strong>区分 <code>Meta</code> 和 <code>Specifiers</code></strong><ul>
<li><code>BlueprintReadWrite</code> 是 <strong>说明符（Specifier）</strong>，直接控制基础行为。</li>
<li><code>DisplayName</code> 是 <strong>元数据（Meta）</strong>，提供附加信息。</li>
</ul>
</li>
<li><strong>编辑器刷新问题</strong><br> 修改 Meta 后可能需要重启编辑器或重新编译才能生效。</li>
<li><strong>C++ 与蓝图的差异</strong><br> 部分 Meta 参数（如 <code>BlueprintPrivate</code>）仅影响蓝图，不影响 C++ 代码。</li>
</ol>
<h1 id="FgameplayTag游戏标签"><a href="#FgameplayTag游戏标签" class="headerlink" title="FgameplayTag游戏标签"></a>FgameplayTag游戏标签</h1><p>在游戏开发（特别是使用虚幻引擎等引擎开发时），Play Tag（玩法标签）是一种用于标识和分类游戏玩法相关元素的机制。</p>
<ol>
<li>​<strong>​功能特性​</strong>​<ul>
<li>​<strong>​分类与组织​</strong>​<ul>
<li>FGamePlayTag可以用来对游戏中的各种玩法相关的内容进行分类，比如不同的角色能力类型（近战型、远程型等）、任务类型（主线任务、支线任务、日常任务等）、游戏模式（单人模式、多人合作模式、多人对战模式等）。通过这种分类方式，开发团队可以更高效地管理和组织游戏内容。</li>
</ul>
</li>
<li>​<strong>​筛选与查询​</strong>​<ul>
<li>在游戏的开发工具或编辑器中，开发者可以使用这些标签来筛选特定的游戏元素。例如，当想要查找所有与多人对战模式相关的游戏逻辑、资产（如地图、角色等）时，可以通过“多人对战模式”这个FGamePlayTag进行快速筛选。</li>
</ul>
</li>
<li>​<strong>​游戏逻辑关联​</strong>​<ul>
<li>在游戏的运行时逻辑中，FGamePlayTag也起到重要作用。比如，根据玩家当前的任务类型标签（如支线任务标签），游戏可以动态调整界面显示、NPC交互行为或者任务提示等相关逻辑。</li>
</ul>
</li>
</ul>
</li>
<li>​<strong>​实现方式（以虚幻引擎为例）​</strong>​<ul>
<li>在虚幻引擎中，FGamePlayTag是一种轻量级的数据结构。开发人员可以在项目的代码和蓝图中定义和使用这些标签。</li>
<li>可以通过C++代码创建自定义的FGamePlayTag，并将其应用到相应的游戏对象、组件或者函数中。在蓝图中，也有直观的节点来处理FGamePlayTag，例如检查某个对象是否具有特定的FGamePlayTag，或者根据FGamePlayTag执行不同的分支逻辑等。![[Pasted image 20250413161403.png]]</li>
<li><code>FGameplayTag</code> 是一种用于标识和分类游戏内容的强大工具。具体到你提供的代码片段中的 <code>FindNativeInputActionByTag</code> 函数，<code>FGameplayTag</code> 的作用主要体现在以下几个方面：</li>
</ul>
</li>
</ol>
<h3 id="1-​​输入动作的分类与标识​​"><a href="#1-​​输入动作的分类与标识​​" class="headerlink" title="1. ​​输入动作的分类与标识​​"></a>1. ​<strong>​输入动作的分类与标识​</strong>​</h3><p><code>FGameplayTag</code> 在这里用于对不同的输入动作进行分类和标识。通过为每个输入动作分配一个或多个标签，开发者可以方便地管理和引用这些动作。例如：</p>
<ul>
<li>​<strong>​动作类型​</strong>​：如“攻击”、“防御”、“跳跃”、“移动”等。</li>
<li>​<strong>​上下文​</strong>​：如“近战”、“远程”、“特殊”等。</li>
<li>​<strong>​状态​</strong>​：如“按下”、“释放”、“长按”等。</li>
</ul>
<h3 id="2-​​简化输入系统的管理​​"><a href="#2-​​简化输入系统的管理​​" class="headerlink" title="2. ​​简化输入系统的管理​​"></a>2. ​<strong>​简化输入系统的管理​</strong>​</h3><p>使用 <code>FGameplayTag</code> 可以简化输入系统的管理，特别是在处理复杂的输入逻辑时。例如，你可以通过标签来动态绑定和解绑输入动作，而无需硬编码每个输入的具体关联。这在需要频繁更改或扩展输入系统时尤为有用。</p>
<h3 id="3-​​提高代码的可读性和可维护性​​"><a href="#3-​​提高代码的可读性和可维护性​​" class="headerlink" title="3. ​​提高代码的可读性和可维护性​​"></a>3. ​<strong>​提高代码的可读性和可维护性​</strong>​</h3><p>通过使用标签而不是直接引用具体的输入动作，代码变得更加抽象和通用。这不仅提高了代码性，还使得在修改或扩展输入动作时更加方便。例如，添加一个新的输入动作只需要为其分配一个合适的标签，而不需要修改大量的查找逻辑。</p>
<h3 id="4-​​支持运行时的动态配置​​"><a href="#4-​​支持运行时的动态配置​​" class="headerlink" title="4. ​​支持运行时的动态配置​​"></a>4. ​<strong>​支持运行时的动态配置​</strong>​</h3><p><code>FGameplayTag</code> 允许在运行时动态地查询和管理输入动作。这意味着你可以根据游戏的状态或玩家的设置，动态地决定哪些输入动作是可用的。例如，某些技能可能只在特定条件下可用，通过标签可以轻松实现这种条件判断。</p>
<h3 id="5-​​与其他系统的集成​​"><a href="#5-​​与其他系统的集成​​" class="headerlink" title="5. ​​与其他系统的集成​​"></a>5. ​<strong>​与其他系统的集成​</strong>​</h3><p><code>FGameplayTag</code> 不仅限于输入系统，它还可以与其他虚幻引擎的系统（如 Gameplay Ability System, GAS）无缝集成。例如，你可以使用相同的标签来控制角色的能力激活、动画播放等，从而实现跨系统的一致性和协同工作。</p>
<h3 id="具体到你的代码"><a href="#具体到你的代码" class="headerlink" title="具体到你的代码"></a>具体到你的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UInputAction* <span class="title">UDataAsset_input::FindNativeInputActionByTag</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; inTags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历这个数组，如果标签等于动作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> FWarriorInput&amp; InputActionConfig : NativeInput) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InputActionConfig.Tags == inTags &amp;&amp; InputActionConfig.Input_Action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> InputActionConfig.Input_Action;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>​<strong>​功能​</strong>​：该函数通过传入的 <code>FGameplayTag</code> (<code>inTags</code>) 来查找对应的 <code>UInputAction</code> 对象。</li>
<li>​<strong>​用途​</strong>​：<br>  查找特定动作​**​：根据标签快速找到需要的输入动作，例如“跳跃”或“攻击”。</li>
<li>​<strong>​动态绑定​</strong>​：在运行时根据不同的标签动态绑定输入动作，增强游戏的灵活性。</li>
<li>​<strong>​条件控制​</strong>​：结合游戏状态，通过标签控制哪些输入动作可用。</li>
</ul>
<h2 id="输入配置映射集合-DataAsset"><a href="#输入配置映射集合-DataAsset" class="headerlink" title="输入配置映射集合-DataAsset"></a>输入配置映射集合-DataAsset</h2><p>用与将输入标签映射到唯一的输入操作</p>
<h1 id="GENERATED-BODY-宏"><a href="#GENERATED-BODY-宏" class="headerlink" title="GENERATED_BODY()宏"></a>GENERATED_BODY()宏</h1><p><code>GENERATED_BODY()</code> 宏是一个非常重要的部分，它通常出现在由 Unreal Engine 的 Unreal Header Tool (UHT) 自动生成代码的类中。这个宏用于处理 Unreal Engine 的反射系统，它使得类能够在编辑器中被识别和使用，同时也支持序列化、网络复制等功能。<br>&#x3D;&#x3D;tips:看见类与结构体就放在里面！&#x3D;&#x3D;</p>
<h2 id="USTRUCT"><a href="#USTRUCT" class="headerlink" title="USTRUCT"></a>USTRUCT</h2><p><code>USTRUCT(BlueprintType)</code> 是一个用于声明结构的宏，它告诉 Unreal Engine 这个结构可以在蓝图中被使用</p>
<h1 id="TArray"><a href="#TArray" class="headerlink" title="TArray"></a>TArray</h1><p><code>TArray</code> 是 Unreal Engine 4 和 Unreal Engine 5 中用于存储动态数组的类模板。它提供了一系列的方法和属性来管理数组中的元素，包括添加、删除、插入、查找等操作。<code>TArray</code> 可以存储任何类型的数据，包括基本数据类型、结构体、类实例等。</p>
<h1 id="数据资产"><a href="#数据资产" class="headerlink" title="数据资产"></a>数据资产</h1><p>-用于存储和管理游戏中的配置数据，如输入动作、角色属性等。通过数据资产，可以将配置与代码分离，便于非程序员进行编辑和管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  
  


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zoomi"
      src="/images/avatar.jpg" style="border-radius:0;width:120px;height:160px;object-fit:cover;">
  <p class="site-author-name" itemprop="name">Zoomi</p>
  <div class="site-description" itemprop="description">欢迎来到我的虚幻个人博客，不定期更新</div>

  <!-- 在线音乐播放器（QQ音乐示例歌单） -->
  <meting-js
    server="tencent"
    type="playlist"
    id="1948308000"
    fixed="true"
    mini="true"
    autoplay="false"
    order="random"
    loop="all"
    theme="#409EFF">
  </meting-js>

  <!-- 文心一言 AI 助手（网页版嵌入） -->
  <div style="width:100%;min-width:220px;max-width:320px;margin:0 auto;margin-top:12px;">
    <iframe 
      src="https://yiyan.baidu.com/welcome"
      style="width:100%;height:320px;border:none;border-radius:8px;box-shadow:0 2px 8px #0001;"
      title="文心一言AI助手"
      loading="lazy"
      referrerpolicy="no-referrer">
    </iframe>
    <div style="text-align:center;font-size:13px;color:#888;margin-top:2px;">AI助手 · 文心一言</div>
  </div>

  <!-- UE5 API 记忆滚动区 -->
  <div id="ue5-api-scroller" style="max-height:180px;overflow:hidden;border-radius:8px;background:rgba(64,158,255,0.07);margin:12px 0;padding:8px 4px 8px 8px;box-shadow:0 1px 4px #0001;font-size:13px;"></div>
  <link rel="stylesheet" href="/css/ue5-api-scroll.css">
  <script src="/js/ue5-api-scroll.js"></script>

  <!-- 当前时间显示 -->
  <div style="text-align:center;font-size:15px;color:#409EFF;margin-top:12px;">
    <span id="hexo-current-time"></span>
  </div>
  <script>
    function updateHexoTime() {
      var now = new Date();
      var y = now.getFullYear();
      var m = (now.getMonth()+1).toString().padStart(2,'0');
      var d = now.getDate().toString().padStart(2,'0');
      var h = now.getHours().toString().padStart(2,'0');
      var min = now.getMinutes().toString().padStart(2,'0');
      var s = now.getSeconds().toString().padStart(2,'0');
      document.getElementById('hexo-current-time').innerText = `${y}-${m}-${d} ${h}:${min}:${s}`;
    }
    setInterval(updateHexoTime, 1000);
    updateHexoTime();
  </script>

  <!-- 天气预报（和风天气） -->
  <div style="margin:10px 0;text-align:center;">
    <iframe src="https://widget.qweather.net/simple/static/index.html?location=101010100&lang=zh&unit=c&theme=light" width="100%" height="60" frameborder="0" scrolling="no" style="border-radius:8px;"></iframe>
  </div>

  <!-- 访客统计（不蒜子） -->
  <div style="font-size:13px;color:#888;text-align:center;margin-bottom:4px;">
    <span id="busuanzi_container_site_pv" style="display:inline;">本站访问量：<span id="busuanzi_value_site_pv"></span></span>
    <span id="busuanzi_container_site_uv" style="display:inline;margin-left:8px;">访客数：<span id="busuanzi_value_site_uv"></span></span>
  </div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <!-- 留言板入口按钮 -->
  <div style="text-align:center;margin:8px 0 0 0;">
    <a href="/message" style="display:inline-block;padding:6px 18px;background:#409EFF;color:#fff;border-radius:16px;font-size:15px;text-decoration:none;box-shadow:0 2px 8px #0001;">💬 留言板</a>
  </div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">目录</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我的邮箱:LFF3216689784@outlook.com</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script color='255,255,255' opacity='0.7' zIndex='-1' count='88' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  <!-- 留言弹幕功能脚本 -->
  <script src="/js/ue5-api-scroll.js"></script>


<script type="text/javascript" color="80,80,80" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
</body>
</html>
