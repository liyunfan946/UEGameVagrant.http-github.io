<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zoomi的虚幻世界</title>
  
  <subtitle>我的邮箱:LFF3216689784@outlook.com</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-04-22T14:01:04.412Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zoomi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GAS系统API百科全书</title>
    <link href="http://example.com/2025/04/22/GAS%E7%B3%BB%E7%BB%9FAPI%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-by_Zoomi_%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E6%88%91/"/>
    <id>http://example.com/2025/04/22/GAS%E7%B3%BB%E7%BB%9FAPI%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-by_Zoomi_%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E6%88%91/</id>
    <published>2025-04-22T14:00:54.000Z</published>
    <updated>2025-04-22T14:01:04.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAS系统简介-什么是GAS系统"><a href="#GAS系统简介-什么是GAS系统" class="headerlink" title="GAS系统简介-什么是GAS系统"></a>GAS系统简介-什么是GAS系统</h1><p><strong>GAS​</strong>​ 即 ​<strong>​Gameplay Ability System​</strong>​（游戏玩法能力系统），是 ​<strong>​Epic Games​</strong>​ 在 ​<strong>​Unreal Engine（虚幻引擎）​</strong>​ 中开发的一套功能强大且灵活的框架，用于管理和实现复杂的游戏玩法机制。​</p><h3 id="GAS-的核心组件"><a href="#GAS-的核心组件" class="headerlink" title="GAS 的核心组件"></a>GAS 的核心组件</h3><p>GAS 主要由以下三个核心组件构成：</p><ol><li><p>​<strong>​Ability System Component (ASC)​</strong>​:</p><ul><li>​<strong>​作用​</strong>​：作为 GAS 的核心，ASC 负责管理角色的能力、属性和效果。每个拥有 GAS 的角色通常都有一个 ASC 实例。</li><li>​<strong>​功能​</strong>​：<ul><li>管理和激活能力（Abilities）。</li><li>处理属性（Attributes）的增减和查询。</li><li>应用和管理效果（Effects），如增益、减益、伤害等。</li><li>提供输入绑定和能力激活的接口。</li></ul></li></ul></li><li><p>​<strong>​Abilities（能力）​</strong>​:</p><ul><li>​<strong>​定义​</strong>​：能力代表角色可以执行的特定动作或行为，如攻击、跳跃、治疗等。</li><li>​<strong>​实现​</strong>​：通过继承 <code>UGameplayAbility</code> 类来创建自定义能力，定义能力的激活条件、执行逻辑和冷却时间等。</li></ul></li><li><p>​<strong>​Attributes（属性）​</strong>​:</p><ul><li>​<strong>​定义​</strong>​：属性代表角色的各种数值特征，如生命值、法力值、攻击力等。</li><li>​<strong>​实现​</strong>​：通过继承 <code>UAttributeSet</code> 类来创建自定义属性集，定义角色的基础属性和衍生属性。</li></ul></li><li><p>​<strong>​Effects（效果）​</strong>​:</p><ul><li>​<strong>​定义​</strong>​：效果用于修改角色的属性或状态，如增加攻击力、减少移动速度、施加中毒效果等。</li><li>​<strong>​实现​</strong>​：通过创建 <code>GameplayEffect</code> 子类来定义各种效果，设置效果的类型、持续时间、数值变化等。</li></ul></li></ol><h3 id="GAS-的优势与使用步骤"><a href="#GAS-的优势与使用步骤" class="headerlink" title="GAS 的优势与使用步骤"></a>GAS 的优势与使用步骤</h3><ul><li>​<strong>​模块化设计​</strong>​：GAS 将能力、属性和效果分离，使得系统更加清晰和易于维护。</li><li>​<strong>​高度可扩展​</strong>​：开发者可以根据项目需求自定义能力、属性和效果，满足各种复杂的游戏玩法需求。</li><li>​<strong>​灵活的激活机制​</strong>​：支持基于输入、状态或其他条件的能力激活，适应不同的游戏设计模式。</li><li>​<strong>​网络同步​</strong>​：内置的网络同步机制，确保在多人游戏中能力、属性和效果的一致性和实时性。</li><li>​<strong>​可视化编辑​</strong>​：通过蓝图系统，开发者可以在编辑器中直观地配置和调试 GAS 组件，提高开发效率。</li><li><h3 id="如何在项目中启用-GAS"><a href="#如何在项目中启用-GAS" class="headerlink" title="如何在项目中启用 GAS"></a>如何在项目中启用 GAS</h3></li></ul><ol><li><p>​<strong>​启用 GAS 插件​</strong>​：</p><ul><li>在 Unreal Engine 编辑器中，导航到 <code>编辑</code> &gt; <code>插件</code>。</li><li>搜索并启用 <code>Gameplay Ability System</code> 插件。</li><li>重启编辑器以应用更改。</li></ul></li><li><p>​<strong>​创建 Ability System Component (ASC)​</strong>​：</p><ul><li>在角色类中添加一个 <code>UAbilitySystemComponent</code> 类型的成员变量。</li><li>初始化并绑定 ASC 到角色。</li></ul></li><li><p>​<strong>​定义 Attributes​</strong>​：</p><ul><li>创建继承自 <code>UAttributeSet</code> 的自定义属性集类。</li><li>定义所需的属性，如生命值、法力值等。</li></ul></li><li><p>​<strong>​创建 Abilities​</strong>​：</p><ul><li>创建继承自 <code>UGameplayAbility</code> 的自定义能力类。</li><li>实现能力的激活逻辑、执行过程和冷却机制。</li></ul></li><li><p>​<strong>​配置 Effects​</strong>​：</p><ul><li>创建继承自 <code>UGameplayEffect</code> 的自定义效果类。</li><li>定义效果的类型、数值变化和应用逻辑。</li></ul></li><li><p>​<strong>​绑定输入和激活能力​</strong>​：</p><ul><li>在角色或控制器中绑定输入事件，调用 ASC 的能力激活函数。</li><li>根据游戏逻辑决定何时激活特定能力。</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的示例，展示如何在角色类中初始化 GAS 组件并激活一个能力：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYGAME_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IAbilitySystemInterface 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// ASC 实例</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Abilities&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UAbilitySystemComponent</span>* AbilitySystemComponent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 激活特定能力</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityHandle)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAbilitySet.h&quot;</span> <span class="comment">// 自定义属性集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameplayAbility.h&quot;</span> <span class="comment">// 自定义能力</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建并附加 ASC</span></span><br><span class="line">    AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilitySystemComponent&quot;</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">AMyCharacter::GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AbilitySystemComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化属性集</span></span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载并赋予基础能力（假设在蓝图中配置）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent &amp;&amp; NewController)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以在这里根据控制器类型进行额外的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::ActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">TryActivateAbility</span>(AbilityHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="API百科"><a href="#API百科" class="headerlink" title="API百科"></a>API百科</h1><h2 id="virtual-void-UAibilitySystemComponent-InitAbilityActorInfo-AActor-InOwnerActor-AActor-InAvatarActor-函数说明"><a href="#virtual-void-UAibilitySystemComponent-InitAbilityActorInfo-AActor-InOwnerActor-AActor-InAvatarActor-函数说明" class="headerlink" title="virtual void UAibilitySystemComponent::InitAbilityActorInfo(AActor *InOwnerActor, AActor *InAvatarActor) 函数说明"></a><code>virtual void UAibilitySystemComponent::InitAbilityActorInfo(AActor *InOwnerActor, AActor *InAvatarActor)</code> 函数说明</h2><ul><li>​<strong>​功能​</strong>​：初始化能力的 Actor 信息——用于保存关于我们作用于谁以及谁控制我们的信息的结构体。</li><li>​<strong>​参数​</strong>​：<ul><li><code>InOwnerActor</code>：从逻辑上拥有此组件的 Actor。</li><li><code>InAvatarActor</code>：我们在世界中实际作用的物理 Actor。通常是 Pawn，但也可能是 Tower、Building、Turret 等，可能与 <code>InOwnerActor</code> 是同一个对象。</li></ul></li></ul><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>在虚幻引擎的 Gameplay Ability System（GAS）中，这个函数起着关键作用。它确保了能力系统能够正确识别和管理与角色相关的 Actor 信息。<code>OwnerActor</code> 帮助确定逻辑上的所属关系，而 <code>InAvatarActor</code> 则明确了实际进行交互操作的对象，这对于能力的触发、效果应用等方面都非常重要。</p><h3 id="示例代码（假设在自定义组件中调用该函数进行初始化）"><a href="#示例代码（假设在自定义组件中调用该函数进行初始化）" class="headerlink" title="示例代码（假设在自定义组件中调用该函数进行初始化）"></a>示例代码（假设在自定义组件中调用该函数进行初始化）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设在某个自定义组件类中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/ActorComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAbilitySystemComponent.h&quot;</span> <span class="comment">// 引入你的 Ability System Component 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCustomComponent.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> UMyCustomComponent : <span class="keyword">public</span> UActorComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Sets default values for this component&#x27;s properties</span></span><br><span class="line">    <span class="built_in">UMyCustomComponent</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Called when the game starts</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;AbilitySystem&quot;</span>)</span><br><span class="line">    UAbilitySystemComponent* AbilitySystemComp; <span class="comment">// 假设你有一个 Ability System Component 成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Actors&quot;</span>)</span><br><span class="line">    AActor* OwnerActor; <span class="comment">// 可以设置逻辑拥有者 Actor</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Actors&quot;</span>)</span><br><span class="line">    AActor* AvatarActor; <span class="comment">// 可以设置实际作用的 Actor</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 其他私有成员变量和函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 BeginPlay 函数，在其中调用 InitAbilityActorInfo 进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyCustomComponent::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComp &amp;&amp; OwnerActor &amp;&amp; AvatarActor)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComp-&gt;<span class="built_in">InitAbilityActorInfo</span>(OwnerActor, AvatarActor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景说明"><a href="#使用场景说明" class="headerlink" title="使用场景说明"></a>使用场景说明</h3><p>在游戏开发中，当你需要使用 GAS 来管理角色的能力时，通常会在角色或相关组件的初始化阶段调用 <code>InitAbilityActorInfo</code> 函数。例如，在角色生成时，或者在自定义组件初始化时，确保 GAS 能够正确关联到对应的 Actor 信息，以便后续进行能力的激活、效果的管理等操作。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保 <code>AbilitySystemComp</code>、<code>OwnerActor</code> 和 <code>AvatarActor</code> 在调用函数时都已经正确初始化且不为空，否则可能会导致运行时错误。</li><li>根据实际游戏逻辑，合理设置 <code>OwnerActor</code> 和 <code>AvatarActor</code> 的值，以准确反映角色之间的所属和交互关系。</li><li>如果在多人联机环境下，要注意这些 Actor 信息的同步问题，确保客户端和服务器端的一致性。</li></ul><h2 id="PossessedBy-AController-NewController-函数详解"><a href="#PossessedBy-AController-NewController-函数详解" class="headerlink" title="PossessedBy(AController* NewController) 函数详解"></a><code>PossessedBy(AController* NewController)</code> 函数详解</h2><h4 id="核心内容分析"><a href="#核心内容分析" class="headerlink" title="核心内容分析"></a>核心内容分析</h4><p><code>PossessedBy(AController* NewController)</code> 是 Unreal Engine（虚幻引擎）中 <code>ACharacter</code> 类的一个重要虚函数，用于处理控制器（Controller）拥有（Possess）角色（Character）时的逻辑。在游戏开发中，控制器负责管理玩家的输入或 AI 的决策，而角色则是游戏中实际执行动作的实体。当控制器拥有一个角色时，<code>PossessedBy</code> 函数会被调用，允许开发者在角色被控制时进行必要的初始化和设置。</p><h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><ul><li>​<strong>​<code>PossessedBy</code>​</strong>​: 虚函数，用于响应控制器拥有角色的事件。</li><li>​<strong>​<code>AController* NewController</code>​</strong>​: 指向新拥有该角色的控制器的指针。</li></ul><h4 id="在-GAS-中的作用"><a href="#在-GAS-中的作用" class="headerlink" title="在 GAS 中的作用"></a>在 GAS 中的作用</h4><p>在 ​<strong>​Gameplay Ability System (GAS)​</strong>​ 中，<code>PossessedBy</code> 函数的作用尤为重要，因为它涉及到 ​<strong>​Ability System Component (ASC)​</strong>​ 的初始化和管理。ASC 是 GAS 的核心组件，负责管理角色的能力（Abilities）、属性（Attributes）和效果（Effects）。当控制器拥有角色时，需要确保 ASC 能够正确地与控制器关联，并进行必要的初始化操作。</p><h4 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h4><ol><li><p>​<strong>​初始化 Ability System Component (ASC)​</strong>​:<br> 当控制器拥有一个角色时，通常需要确保该角色的 ASC 被正确初始化。这包括绑定与控制器相关的输入、设置默认的游戏玩法标签（Gameplay Tags）等。</p></li><li><p>​<strong>​绑定输入和能力激活​</strong>​:<br> 控制器可能负责处理玩家的输入，这些输入用于激活角色的能力。通过在 <code>PossessedBy</code> 中设置适当的绑定，可以确保当控制器发出指令时，ASC 能够正确响应并激活相应的能力。</p></li><li><p>​<strong>​管理游戏玩法标签和效果​</strong>​:<br> 控制器的拥有关系变化可能会影响角色的游戏玩法标签或应用的效果。例如，当 AI 控制器拥有角色时，可能需要应用特定的效果或标签，以反映 AI 的行为模式。</p></li></ol><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个示例，展示如何在自定义的 Character 类中重写 <code>PossessedBy</code> 函数，并在其中初始化 GAS 相关的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYGAME_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IAbilitySystemInterface 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// ASC 实例</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Abilities&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UMyAbilitySystemComponent</span>* AbilitySystemComponent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnPossess</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 可选：处理控制器失去控制的情况</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbilitySystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAbilitySystemComponent.h&quot;</span> <span class="comment">// 假设你有一个自定义的 ASC 类</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建并附加 ASC</span></span><br><span class="line">    AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UMyAbilitySystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;AbilitySystemComponent&quot;</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">AMyCharacter::GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AbilitySystemComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent &amp;&amp; NewController)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化 ASC，例如绑定输入、设置默认标签等</span></span><br><span class="line">        AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有玩家控制器，可以进一步初始化与玩家相关的内容</span></span><br><span class="line">        APlayerController* PlayerController = <span class="built_in">Cast</span>&lt;APlayerController&gt;(NewController);</span><br><span class="line">        <span class="keyword">if</span> (PlayerController)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 例如，绑定输入映射</span></span><br><span class="line">            <span class="comment">// AbilitySystemComponent-&gt;BindToInput(PlayerController);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 激活默认能力（如果需要）</span></span><br><span class="line">        <span class="comment">// AbilitySystemComponent-&gt;ActivateAbility(FGameplayAbilitySpecHandle());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::UnPossess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">UnPossess</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清理与控制器相关的逻辑，例如清除输入绑定、重置状态等</span></span><br><span class="line">        <span class="comment">// AbilitySystemComponent-&gt;ClearBindings();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键步骤解释"><a href="#关键步骤解释" class="headerlink" title="关键步骤解释"></a>关键步骤解释</h4><ol><li><p>​<strong>​调用父类函数​</strong>​:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Super::<span class="built_in">PossessedBy</span>(NewController);</span><br></pre></td></tr></table></figure><p> 确保基类的 <code>PossessedBy</code> 逻辑被执行，以处理默认的拥有行为。</p></li><li><p>​<strong>​初始化 ASC​</strong>​:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p> 这一步将角色和控制器信息绑定到 ASC，使其能够正确管理角色的能力和属性。</p></li><li><p>​<strong>​处理特定类型的控制器​</strong>​:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">APlayerController* PlayerController = <span class="built_in">Cast</span>&lt;APlayerController&gt;(NewController);</span><br><span class="line"><span class="keyword">if</span> (PlayerController)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 绑定输入或其他玩家特定逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 根据控制器的类型（玩家控制器或 AI 控制器），执行不同的初始化逻辑。</p></li><li><p>​<strong>​激活默认能力​</strong>​:<br> 根据需要，可以在控制器拥有角色时激活某些默认的能力，确保角色在拥有后立即具备所需的行为。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbilitySystemComponent-&gt;ActivateAbility(FGameplayAbilitySpecHandle());</span></span><br></pre></td></tr></table></figure></li><li><p>​<strong>​处理失去控制的情况​</strong>​（可选）:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::UnPossess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">UnPossess</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清理与控制器相关的逻辑，例如清除输入绑定、重置状态等</span></span><br><span class="line">        <span class="comment">// AbilitySystemComponent-&gt;ClearBindings();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在控制器失去对角色的控制时，进行必要的清理工作，确保角色状态的一致性。</p></li></ol><h4 id="使用场景说明-1"><a href="#使用场景说明-1" class="headerlink" title="使用场景说明"></a>使用场景说明</h4><p>在游戏开发中，<code>PossessedBy</code> 函数通常用于以下场景：</p><ul><li>​<strong>​角色初始化​</strong>​: 当玩家或 AI 控制器首次拥有角色时，进行必要的初始化设置，如绑定输入、激活默认能力等。</li><li>​<strong>​控制器切换​</strong>​: 当控制器在运行时切换（例如，玩家死亡后重新控制另一个角色），确保新控制器正确地与角色关联。</li><li>​<strong>​状态管理​</strong>​: 根据控制器的类型（玩家或 AI），调整角色的行为和状态，以适应不同的游戏逻辑。</li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>​<strong>​避免重复初始化​</strong>​: 确保 <code>PossessedBy</code> 中的初始化逻辑不会在每次控制器切换时重复执行不必要的操作，可以通过标志位或其他机制来管理初始化状态。</p></li><li><p>​<strong>​处理失去控制的情况​</strong>​: 除了 <code>PossessedBy</code>，还需要重写 <code>UnPossess</code> 函数，以处理控制器失去对角色控制时的清理工作，确保角色状态的一致性。</p></li><li><p>​<strong>​同步问题​</strong>​: 在多人联机环境下，要注意这些 Actor 信息的同步问题，确保客户端和服务器端的一致性，特别是在激活能力和应用效果时。</p></li><li><p>​<strong>​输入绑定​</strong>​: 确保输入绑定与控制器的类型匹配，避免在 AI 控制器上绑定不必要的玩家输入逻辑。</p></li></ul><hr><h2 id="​​FGameplayAbilitySpec​​"><a href="#​​FGameplayAbilitySpec​​" class="headerlink" title="​​FGameplayAbilitySpec​​"></a>​<strong>​FGameplayAbilitySpec​</strong>​</h2><blockquote><p>​<strong>​是Unreal Engine (UE)​</strong>​ 中 ​<strong>​Gameplay Ability System (GAS)​</strong>​ 的核心结构体，用于定义和管理单个游戏玩法能力实例。</p></blockquote><hr><h2 id="​​1-主要组成部分​​"><a href="#​​1-主要组成部分​​" class="headerlink" title="​​1. 主要组成部分​​"></a>​<strong>​1. 主要组成部分​</strong>​</h2><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>​<strong>​<code>Ability</code>​</strong>​</td><td><code>TSubclassOf&lt;UGameplayAbility&gt;</code></td><td>具体的能力类（如 <code>UMyGameplayAbility</code>）。</td></tr><tr><td>​<strong>​<code>InputID</code>​</strong>​</td><td><code>int32</code></td><td>输入绑定 ID（如键盘按键或手柄按钮）。</td></tr><tr><td>​<strong>​<code>Level</code>​</strong>​</td><td><code>int32</code></td><td>能力等级（影响强度或效果）。</td></tr><tr><td>​<strong>​<code>ActivationBlockedBy</code>​</strong>​</td><td><code>FGameplayTagContainer</code></td><td>阻止激活的标签（如“眩晕”状态）。</td></tr><tr><td>​<strong>​<code>GrantedTags</code>​</strong>​</td><td><code>FGameplayTagContainer</code></td><td>激活时授予的标签（影响其他能力）。</td></tr><tr><td>​<strong>​<code>SourceObject</code>​</strong>​</td><td><code>UObject*</code></td><td>能力来源（如角色、道具）。</td></tr><tr><td>​<strong>​<code>StartTime</code>​</strong>​</td><td><code>float</code></td><td>激活时间（用于计算持续时间&#x2F;冷却）。</td></tr><tr><td>​<strong>​<code>Duration</code>​</strong>​</td><td><code>float</code></td><td>持续时间（持续型能力）。</td></tr><tr><td>​<strong>​<code>CooldownTimeRemaining</code>​</strong>​</td><td><code>float</code></td><td>剩余冷却时间。</td></tr><tr><td>​<strong>​<code>bIsActive</code>​</strong>​</td><td><code>bool</code></td><td>是否处于激活状态。</td></tr></tbody></table><hr><h2 id="​​2-创建与管理​​"><a href="#​​2-创建与管理​​" class="headerlink" title="​​2. 创建与管理​​"></a>​<strong>​2. 创建与管理​</strong>​</h2><h3 id="​​2-1-创建-FGameplayAbilitySpec​​"><a href="#​​2-1-创建-FGameplayAbilitySpec​​" class="headerlink" title="​​2.1 创建 FGameplayAbilitySpec​​"></a>​<strong>​2.1 创建 <code>FGameplayAbilitySpec</code>​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 AbilitySystemComponent</span></span><br><span class="line">UAbilitySystemComponent* ASC = xxx<span class="comment">/* 获取或初始化 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义能力类和等级</span></span><br><span class="line">TSubclassOf&lt;UGameplayAbility&gt; AbilityClass = UMyGameplayAbility::<span class="built_in">StaticClass</span>();</span><br><span class="line">int32 Level = <span class="number">1</span>;</span><br><span class="line">int32 InputID = <span class="number">0</span>; <span class="comment">// 绑定输入（如按键）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Spec</span></span><br><span class="line"><span class="function">FGameplayAbilitySpec <span class="title">Spec</span><span class="params">(AbilityClass, Level, InputID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到 AbilitySystemComponent</span></span><br><span class="line">ASC-&gt;<span class="built_in">GiveAbility</span>(Spec);</span><br></pre></td></tr></table></figure><h3 id="​​3-1-激活-取消能力​​"><a href="#​​3-1-激活-取消能力​​" class="headerlink" title="​​3.1 激活&#x2F;取消能力​​"></a>​<strong>​3.1 激活&#x2F;取消能力​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活能力</span></span><br><span class="line">ASC-&gt;<span class="built_in">ActivateAbility</span>(Spec.Handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消能力</span></span><br><span class="line">ASC-&gt;<span class="built_in">CancelAbility</span>(Spec.Handle, Spec.ActivationInfo, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h1 id="GAS-通知蓝图-很重要必须看！"><a href="#GAS-通知蓝图-很重要必须看！" class="headerlink" title="GAS-通知蓝图-很重要必须看！"></a>GAS-通知蓝图-很重要必须看！</h1><p>看不到图片请联系我，我会给你发本地文档，因为本人很懒，暂时不想添加图片显示。</p><h2 id="Pasted-image-20250422172242-png"><a href="#Pasted-image-20250422172242-png" class="headerlink" title="![[Pasted image 20250422172242.png]]"></a>![[Pasted image 20250422172242.png]]</h2><p>通知蓝图中有个接受通知事件，节点如下<br>该节点发送通知给角色，接受一个角色标签<br>![[Pasted image 20250422172549.png]]<br>通知的的原理：一定要使得游戏标签可见，使用send gameplayevent to actor 节点将通知通过游戏标签发送给角色，Event gameplay enent节点用于接受通知并执行<br>![[Pasted image 20250422173850.png]]<br>那么可以利用在动画蓝图中放置自定义通知，一旦动画播放完，收到通知则将武器绑定到手部，实现或者实现其它任意功能了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GAS系统简介-什么是GAS系统&quot;&gt;&lt;a href=&quot;#GAS系统简介-什么是GAS系统&quot; class=&quot;headerlink&quot; title=&quot;GAS系统简介-什么是GAS系统&quot;&gt;&lt;/a&gt;GAS系统简介-什么是GAS系统&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;GAS​&lt;/</summary>
      
    
    
    
    <category term="虚幻引擎" scheme="http://example.com/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="游戏开发" scheme="http://example.com/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="GAS" scheme="http://example.com/tags/GAS/"/>
    
    <category term="Unreal Engine" scheme="http://example.com/tags/Unreal-Engine/"/>
    
    <category term="Gameplay Ability System" scheme="http://example.com/tags/Gameplay-Ability-System/"/>
    
  </entry>
  
  <entry>
    <title>UE5 调试 API-常用</title>
    <link href="http://example.com/2025/04/15/2025-04-15-%E8%99%9A%E5%B9%BBCpp/"/>
    <id>http://example.com/2025/04/15/2025-04-15-%E8%99%9A%E5%B9%BBCpp/</id>
    <published>2025-04-15T04:00:00.000Z</published>
    <updated>2025-04-26T06:52:33.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE5-调试-API-常用"><a href="#UE5-调试-API-常用" class="headerlink" title="UE5 调试 API-常用"></a>UE5 调试 API-常用</h1><h2 id="基础调试输出"><a href="#基础调试输出" class="headerlink" title="基础调试输出"></a>基础调试输出</h2><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础日志</span></span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;This is a log message&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;This is a warning&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;This is an error&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带变量的输出</span></span><br><span class="line"><span class="type">float</span> Health = <span class="number">75.0f</span>;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Player health: %f&quot;</span>), Health);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带分类的日志（需先在头文件声明）</span></span><br><span class="line"><span class="built_in">DECLARE_LOG_CATEGORY_EXTERN</span>(LogMyGame, Log, All);</span><br><span class="line"><span class="built_in">DEFINE_LOG_CATEGORY</span>(LogMyGame);</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogMyGame, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Custom category log&quot;</span>));</span><br><span class="line"><span class="comment">// 屏幕输出（默认显示2秒）</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">2.0f</span>, FColor::White, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带Key的屏幕输出（可更新）</span></span><br><span class="line"><span class="type">static</span> int32 MyDebugKey = <span class="number">0</span>;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(MyDebugKey, <span class="number">5.0f</span>, FColor::Green, </span><br><span class="line">    FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Health: %.2f&quot;</span>), Health));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试球体</span></span><br><span class="line"><span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), Location, Radius, Segments, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试盒子</span></span><br><span class="line"><span class="built_in">DrawDebugBox</span>(<span class="built_in">GetWorld</span>(), Center, Extent, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试线条</span></span><br><span class="line"><span class="built_in">DrawDebugLine</span>(<span class="built_in">GetWorld</span>(), Start, End, Color, bPersistentLines, LifeTime, DepthPriority, Thickness);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制调试点</span></span><br><span class="line"><span class="built_in">DrawDebugPoint</span>(<span class="built_in">GetWorld</span>(), Location, Size, Color, bPersistentLines, LifeTime, DepthPriority)；</span><br></pre></td></tr></table></figure><h2 id="Unreal-Engine-5-常用宏速查表"><a href="#Unreal-Engine-5-常用宏速查表" class="headerlink" title="Unreal Engine 5 常用宏速查表"></a>Unreal Engine 5 常用宏速查表</h2><h3 id="1-类声明宏"><a href="#1-类声明宏" class="headerlink" title="1. 类声明宏"></a><strong>1. 类声明宏</strong></h3><table><thead><tr><th>宏</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>UCLASS()</code></td><td>声明一个 UE 反射类</td><td><code>UCLASS(Blueprintable, meta=(DisplayName=&quot;My Actor&quot;))</code></td></tr><tr><td><code>UINTERFACE()</code></td><td>声明一个 UE 反射接口</td><td><code>UINTERFACE(MinimalAPI, Blueprintable)</code></td></tr><tr><td><code>UGENERATED_BODY()</code></td><td>自动生成类反射代码（必须放在类体内）</td><td><code>GENERATED_BODY()</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="2-属性宏-UPROPERTY"><a href="#2-属性宏-UPROPERTY" class="headerlink" title="2. 属性宏 (UPROPERTY)"></a><strong>2. 属性宏 (<code>UPROPERTY</code>)</strong></h3><table><thead><tr><th>宏</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>BlueprintReadOnly</code></td><td>蓝图只读</td><td><code>UPROPERTY(BlueprintReadOnly)</code></td></tr><tr><td><code>BlueprintReadWrite</code></td><td>蓝图可读写</td><td><code>UPROPERTY(BlueprintReadWrite)</code></td></tr><tr><td><code>EditAnywhere</code></td><td>在编辑器任意位置可编辑</td><td><code>UPROPERTY(EditAnywhere)</code></td></tr><tr><td><code>EditDefaultsOnly</code></td><td>仅可在默认值（CDO）编辑</td><td><code>UPROPERTY(EditDefaultsOnly)</code></td></tr><tr><td><code>VisibleAnywhere</code></td><td>在编辑器可见但不可编辑</td><td><code>UPROPERTY(VisibleAnywhere)</code></td></tr><tr><td><code>Category=&quot;CategoryName&quot;</code></td><td>在编辑器分类</td><td><code>UPROPERTY(Category=&quot;Movement&quot;)</code></td></tr><tr><td><code>meta=(DisplayName=&quot;Nice Name&quot;)</code></td><td>显示更友好的名称</td><td><code>UPROPERTY(meta=(DisplayName=&quot;Health&quot;))</code></td></tr><tr><td><code>Replicated</code></td><td>网络同步（需在 <code>GetLifetimeReplicatedProps</code> 处理）</td><td><code>UPROPERTY(Replicated)</code></td></tr><tr><td><code>Transient</code></td><td>不保存到磁盘（临时变量）</td><td><code>UPROPERTY(Transient)</code></td></tr><tr><td><code>SaveGame</code></td><td>可序列化到存档</td><td><code>UPROPERTY(SaveGame)</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><h3 id="3-函数宏-UFUNCTION"><a href="#3-函数宏-UFUNCTION" class="headerlink" title="3. 函数宏 (UFUNCTION)"></a><strong>3. 函数宏 (<code>UFUNCTION</code>)</strong></h3><table><thead><tr><th>宏</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>BlueprintCallable</code></td><td>可在蓝图中调用</td><td><code>UFUNCTION(BlueprintCallable)</code></td></tr><tr><td><code>BlueprintPure</code></td><td>纯函数（无副作用）</td><td><code>UFUNCTION(BlueprintPure)</code></td></tr><tr><td><code>BlueprintImplementableEvent</code></td><td>蓝图可覆盖的虚函数（无 C++ 实现）</td><td><code>UFUNCTION(BlueprintImplementableEvent)</code></td></tr><tr><td><code>BlueprintNativeEvent</code></td><td>蓝图可覆盖的虚函数（有默认 C++ 实现）</td><td><code>UFUNCTION(BlueprintNativeEvent)</code></td></tr><tr><td><code>Server</code></td><td>仅在服务器执行（RPC）</td><td><code>UFUNCTION(Server, Reliable)</code></td></tr><tr><td><code>Client</code></td><td>仅在客户端执行（RPC）</td><td><code>UFUNCTION(Client, Reliable)</code></td></tr><tr><td><code>NetMulticast</code></td><td>多播（所有客户端执行）</td><td><code>UFUNCTION(NetMulticast, Reliable)</code></td></tr><tr><td><code>WithValidation</code></td><td>RPC 参数验证</td><td><code>UFUNCTION(Server, WithValidation)</code></td></tr></tbody></table><hr><h3 id="4-结构体宏-USTRUCT"><a href="#4-结构体宏-USTRUCT" class="headerlink" title="4. 结构体宏 (USTRUCT)"></a><strong>4. 结构体宏 (<code>USTRUCT</code>)</strong></h3><table><thead><tr><th>宏</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>USTRUCT()</code></td><td>声明反射结构体</td><td><code>USTRUCT(BlueprintType)</code></td></tr><tr><td><code>GENERATED_BODY()</code></td><td>生成结构体反射代码</td><td><code>GENERATED_BODY()</code></td></tr><tr><td><code>BlueprintType</code></td><td>可在蓝图中使用</td><td><code>USTRUCT(BlueprintType)</code></td></tr><tr><td><code>meta=(BlueprintInternalUseOnly)</code></td><td>仅限内部使用</td><td><code>USTRUCT(meta=(BlueprintInternalUseOnly))</code></td></tr></tbody></table><hr><h3 id="5-枚举宏-UENUM"><a href="#5-枚举宏-UENUM" class="headerlink" title="5. 枚举宏 (UENUM)"></a><strong>5. 枚举宏 (<code>UENUM</code>)</strong></h3><table><thead><tr><th>宏</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>UENUM()</code></td><td>声明反射枚举</td><td><code>UENUM(BlueprintType)</code></td></tr><tr><td><code>BlueprintType</code></td><td>可在蓝图中使用</td><td><code>UENUM(BlueprintType)</code></td></tr><tr><td><code>meta=(DisplayName=&quot;Nice Name&quot;)</code></td><td>显示友好名称</td><td><code>UENUM(meta=(DisplayName=&quot;Weapon Type&quot;))</code></td></tr></tbody></table><hr><h3 id="6-其他常用宏"><a href="#6-其他常用宏" class="headerlink" title="6. 其他常用宏"></a><strong>6. 其他常用宏</strong></h3><table><thead><tr><th>宏</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code></td><td>声明动态多播委托</td><td><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMyDelegate);</code></td></tr><tr><td><code>DECLARE_DELEGATE</code></td><td>声明单播委托</td><td><code>DECLARE_DELEGATE(FMySimpleDelegate);</code></td></tr><tr><td><code>UE_LOG</code></td><td>打印日志</td><td><code>UE_LOG(LogTemp, Warning, TEXT(&quot;Hello&quot;));</code></td></tr><tr><td><code>ensure()</code></td><td>运行时检查（不崩溃）</td><td><code>ensure(MyPointer != nullptr);</code></td></tr><tr><td><code>check()</code></td><td>运行时断言（崩溃）</td><td><code>check(MyPointer != nullptr);</code></td></tr><tr><td><code>GEngine-&gt;AddOnScreenDebugMessage</code></td><td>屏幕打印调试信息</td><td><code>GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(&quot;Hello&quot;));</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="UCapsuleComponent-胶囊体-常用-API-速查表"><a href="#UCapsuleComponent-胶囊体-常用-API-速查表" class="headerlink" title="UCapsuleComponent 胶囊体 常用 API 速查表"></a>UCapsuleComponent 胶囊体 常用 API 速查表</h2><h3 id="1-基础属性设置"><a href="#1-基础属性设置" class="headerlink" title="1. 基础属性设置"></a><strong>1. 基础属性设置</strong></h3><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>SetCapsuleSize(float Radius, float HalfHeight, bool bUpdateOverlaps)</code></td><td>设置胶囊体的半径和半高</td><td><code>CapsuleComp-&gt;SetCapsuleSize(50.f, 100.f);</code></td></tr><tr><td><code>GetScaledCapsuleRadius()</code></td><td>获取当前缩放后的半径</td><td><code>float Radius = CapsuleComp-&gt;GetScaledCapsuleRadius();</code></td></tr><tr><td><code>GetScaledCapsuleHalfHeight()</code></td><td>获取当前缩放后的半高</td><td><code>float HalfHeight = CapsuleComp-&gt;GetScaledCapsuleHalfHeight();</code></td></tr><tr><td><code>GetCapsuleAxis()</code></td><td>获取胶囊体的朝向轴（默认 <code>Z</code> 轴）</td><td><code>FVector Axis = CapsuleComp-&gt;GetCapsuleAxis();</code></td></tr></tbody></table><hr><h3 id="2-碰撞与物理"><a href="#2-碰撞与物理" class="headerlink" title="2. 碰撞与物理"></a><strong>2. 碰撞与物理</strong></h3><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>SetCollisionEnabled(ECollisionEnabled::Type NewType)</code></td><td>启用&#x2F;禁用碰撞</td><td><code>CapsuleComp-&gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);</code></td></tr><tr><td><code>SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse Response)</code></td><td>设置对特定通道的碰撞响应</td><td><code>CapsuleComp-&gt;SetCollisionResponseToChannel(ECC_Pawn, ECR_Ignore);</code></td></tr><tr><td><code>SetGenerateOverlapEvents(bool bGenerate)</code></td><td>是否生成重叠事件</td><td><code>CapsuleComp-&gt;SetGenerateOverlapEvents(true);</code></td></tr><tr><td><code>OnComponentBeginOverlap.AddDynamic()</code></td><td>绑定重叠开始事件</td><td><code>CapsuleComp-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AMyActor::OnCapsuleBeginOverlap);</code></td></tr><tr><td><code>OnComponentEndOverlap.AddDynamic()</code></td><td>绑定重叠结束事件</td><td><code>CapsuleComp-&gt;OnComponentEndOverlap.AddDynamic(this, &amp;AMyActor::OnCapsuleEndOverlap);</code></td></tr></tbody></table><hr><h3 id="3-位置与变换"><a href="#3-位置与变换" class="headerlink" title="3. 位置与变换"></a><strong>3. 位置与变换</strong></h3><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>GetComponentLocation()</code></td><td>获取胶囊体中心位置</td><td><code>FVector Location = CapsuleComp-&gt;GetComponentLocation();</code></td></tr><tr><td><code>GetComponentRotation()</code></td><td>获取胶囊体旋转</td><td><code>FRotator Rotation = CapsuleComp-&gt;GetComponentRotation();</code></td></tr><tr><td><code>SetWorldLocation(FVector NewLocation)</code></td><td>设置世界坐标位置</td><td><code>CapsuleComp-&gt;SetWorldLocation(FVector(0, 0, 100));</code></td></tr><tr><td><code>AddLocalOffset(FVector DeltaLocation)</code></td><td>局部坐标偏移</td><td><code>CapsuleComp-&gt;AddLocalOffset(FVector(10, 0, 0));</code></td></tr></tbody></table><hr><h3 id="4-调试与可视化"><a href="#4-调试与可视化" class="headerlink" title="4. 调试与可视化"></a><strong>4. 调试与可视化</strong></h3><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>SetHiddenInGame(bool bHidden)</code></td><td>隐藏&#x2F;显示胶囊体</td><td><code>CapsuleComp-&gt;SetHiddenInGame(false);</code></td></tr><tr><td><code>ShapeColor</code></td><td>设置调试颜色（编辑器可见）</td><td><code>CapsuleComp-&gt;ShapeColor = FColor::Green;</code></td></tr><tr><td><code>bDrawOnlyIfSelected</code></td><td>仅在选中时显示</td><td><code>CapsuleComp-&gt;bDrawOnlyIfSelected = true;</code></td></tr><tr><td><code>MarkRenderStateDirty()</code></td><td>强制刷新渲染状态</td><td><code>CapsuleComp-&gt;MarkRenderStateDirty();</code></td></tr></tbody></table><hr><h3 id="5-射线检测与几何查询"><a href="#5-射线检测与几何查询" class="headerlink" title="5. 射线检测与几何查询"></a><strong>5. 射线检测与几何查询</strong></h3><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>IsOverlappingComponent(UPrimitiveComponent* OtherComp)</code></td><td>检查是否与其他组件重叠</td><td><code>bool bOverlapping = CapsuleComp-&gt;IsOverlappingComponent(OtherActor-&gt;GetMesh());</code></td></tr><tr><td><code>SweepComponent(FHitResult&amp; OutHit, FVector Start, FVector End, FRotator Rotation)</code></td><td>胶囊体扫描检测</td><td><code>CapsuleComp-&gt;SweepComponent(OutHit, Start, End, FQuat::Identity);</code></td></tr><tr><td><code>GetOverlappingActors(TArray&lt;AActor*&gt;&amp; OutActors)</code></td><td>获取所有重叠的 Actor</td><td><code>CapsuleComp-&gt;GetOverlappingActors(OverlappingActors);</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="零散重要api"><a href="#零散重要api" class="headerlink" title="零散重要api"></a>零散重要api</h1><p>**AutoPossessPlayer &#x3D;EAutoReceiveInput::player0;     设置玩家控制器</p><h1 id="UE5-5-增强输入系统使用指南-C-实现"><a href="#UE5-5-增强输入系统使用指南-C-实现" class="headerlink" title="UE5.5 增强输入系统使用指南 (C++ 实现)"></a>UE5.5 增强输入系统使用指南 (C++ 实现)</h1><p>以下是在 Unreal Engine 5.5 中使用增强输入系统(Enhanced Input System)的完整 C++ 实现方式<br>关键数据结构：输入映射上下文   输入映射</p><p>![[Pasted image 20250414102551.png]]</p><h2 id="输入映射中的触发器和修改器"><a href="#输入映射中的触发器和修改器" class="headerlink" title="输入映射中的触发器和修改器"></a>输入映射中的触发器和修改器</h2><p>虚幻中的轴映射以X轴的右方为正方向！</p><p>一旦开启&#x3D;&#x3D;拌合输入轴值&#x3D;&#x3D;，则意味着可以交换坐标轴的位置<br>YXZ意味着交换X与Y轴的位置，交换后相当于在使用Y轴的正方向  比如W键前进</p><p>![[Pasted image 20250414102006.png]]<br>因为默认是X的右方是正方向，所以只需要否定X轴就是反方向</p><h1 id="增强输入组件"><a href="#增强输入组件" class="headerlink" title="增强输入组件"></a>增强输入组件</h1><h3 id="​​-什么是增强输入组件？​​"><a href="#​​-什么是增强输入组件？​​" class="headerlink" title="​​ 什么是增强输入组件？​​"></a>​<strong>​ 什么是增强输入组件？​</strong>​</h3><p>增强输入组件是虚幻引擎中用于处理玩家输入的组件，属于 ​<strong>​增强输入系统​</strong>​ 的一部分。它取代了传统的输入系统，提供了更强大的功能，如输入动作（Input Actions）、输入映射上下文（Input Mapping Contexts）、修饰器（Modifiers）等，使开发者能够更灵活地定义和管理输入逻辑。</p><h2 id="增强输入组件的核心概念​​"><a href="#增强输入组件的核心概念​​" class="headerlink" title=". 增强输入组件的核心概念​​"></a><strong>. 增强输入组件的核心概念​</strong>​</h2><h3 id="​​输入动作（Input-Actions）​​"><a href="#​​输入动作（Input-Actions）​​" class="headerlink" title="​​输入动作（Input Actions）​​"></a>​<strong>​输入动作（Input Actions）​</strong>​</h3><ul><li>​<strong>​定义​</strong>​：输入动作代表具体的操作，如“跳跃”、“攻击”、“移动”等。</li><li>​<strong>​用途​</strong>​：用于绑定具体的游戏逻辑，便于在不同场景中复用和调整。</li></ul><h3 id="​-输入映射上下文（Input-Mapping-Contexts）​-​"><a href="#​-输入映射上下文（Input-Mapping-Contexts）​-​" class="headerlink" title="​ 输入映射上下文（Input Mapping Contexts）​**​"></a>​ 输入映射上下文（Input Mapping Contexts）​**​</h3><ul><li>​<strong>​定义​</strong>​：输入映射上下文将物理输入（如键盘按键、鼠标按钮、手柄按键）映射到输入动作。</li><li>​<strong>​用途​</strong>​：允许为不同的玩家配置、设备或场景设置不同的输入映射，增强项目的适应性。</li></ul><h3 id="​​-修饰器（Modifiers）​​"><a href="#​​-修饰器（Modifiers）​​" class="headerlink" title="​​ 修饰器（Modifiers）​​"></a>​<strong>​ 修饰器（Modifiers）​</strong>​</h3><ul><li>​<strong>​定义​</strong>​：修饰器用于修改输入行为，如按住时间、双击检测、输入反转等。</li><li>​<strong>​用途​</strong>​：增强输入的灵活性，实现复杂的输入逻辑。</li></ul><h3 id="​​-输入子系统（Input-Subsystem）​​"><a href="#​​-输入子系统（Input-Subsystem）​​" class="headerlink" title="​​ 输入子系统（Input Subsystem）​​"></a>​<strong>​ 输入子系统（Input Subsystem）​</strong>​</h3><ul><li>​<strong>​定义​</strong>​：管理所有输入组件和映射上下文，负责处理输入事件的分发和处理。</li><li>​<strong>​用途​</strong>​：确保输入系统的高效运行和统一管理。</li></ul><h3 id="​​-增强输入组件的优势​​"><a href="#​​-增强输入组件的优势​​" class="headerlink" title="​​ 增强输入组件的优势​​"></a>​<strong>​ 增强输入组件的优势​</strong>​</h3><ul><li>​<strong>​模块化设计​</strong>​：通过输入动作和映射上下文分离输入逻辑与具体实现，便于管理和维护。</li><li>​<strong>​灵活性高​</strong>​：支持多种输入设备（键盘、鼠标、手柄等），并允许动态切换和组合输入方式。</li><li>​<strong>​丰富的功能​</strong>​：支持输入修饰器（如组合键、按住时间等）、轴映射（Axis Mappings）和动作映射（Action Mappings），满足复杂输入需求。</li><li>​<strong>​易于扩展​</strong>​：便于集成自定义逻辑，适应不同项目和平台的需求。</li></ul><h2 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1. 基本设置"></a>1. 基本设置</h2><h3 id="1-1-启用增强输入模块"><a href="#1-1-启用增强输入模块" class="headerlink" title="1.1 启用增强输入模块"></a>1.1 启用增强输入模块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先在项目的 `Build.cs` 文件中添加依赖：</span><br><span class="line">PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; </span><br><span class="line">    <span class="string">&quot;Core&quot;</span>, </span><br><span class="line">    <span class="string">&quot;CoreUObject&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Engine&quot;</span>, </span><br><span class="line">    <span class="string">&quot;InputCore&quot;</span>, </span><br><span class="line">    <span class="string">&quot;EnhancedInput&quot;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-2-创建输入动作-Input-Actions"><a href="#1-2-创建输入动作-Input-Actions" class="headerlink" title="1.2 创建输入动作(Input Actions)"></a>1.2 创建输入动作(Input Actions)</h3><p>在内容浏览器中右键创建 <code>Input Actions</code> 资源：</p><ul><li><p><code>IA_Jump</code></p></li><li><p><code>IA_Move</code></p></li><li><p><code>IA_Look</code></p></li><li><p><code>IA_Fire</code></p></li></ul><h2 id="2-C-利用增强输入系统实现输入映射"><a href="#2-C-利用增强输入系统实现输入映射" class="headerlink" title="2. C++ 利用增强输入系统实现输入映射"></a>2. C++ 利用增强输入系统实现输入映射</h2><h3 id="2-1-玩家控制器头文件-MyPlayerController-h"><a href="#2-1-玩家控制器头文件-MyPlayerController-h" class="headerlink" title="2.1 玩家控制器头文件 (MyPlayerController.h)"></a>2.1 玩家控制器头文件 (MyPlayerController.h)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InputActionValue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPlayerController.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputMappingContext</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputAction</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYPROJECT_API</span> AMyPlayerController : <span class="keyword">public</span> APlayerController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupInputComponent</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入映射上下文</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputMappingContext* DefaultMappingContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入动作</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* JumpAction;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* MoveAction;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* LookAction;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">    UInputAction* FireAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 输入回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnJump</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMove</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnLook</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnFire</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-玩家控制器实现文件-MyPlayerController-cpp"><a href="#2-2-玩家控制器实现文件-MyPlayerController-cpp" class="headerlink" title="2.2 玩家控制器实现文件 (MyPlayerController.cpp)"></a>2.2 玩家控制器实现文件 (MyPlayerController.cpp)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EnhancedInputComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EnhancedInputSubsystems.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地玩家增强输入子系统并添加映射上下文</span></span><br><span class="line">    <span class="keyword">if</span> (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::<span class="built_in">GetSubsystem</span>&lt;UEnhancedInputLocalPlayerSubsystem&gt;(<span class="built_in">GetLocalPlayer</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        Subsystem-&gt;<span class="built_in">AddMappingContext</span>(DefaultMappingContext, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::SetupInputComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupInputComponent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置增强输入组件</span></span><br><span class="line">    <span class="keyword">if</span> (UEnhancedInputComponent* EnhancedInputComponent = <span class="built_in">CastChecked</span>&lt;UEnhancedInputComponent&gt;(InputComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(JumpAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnJump);</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(MoveAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnMove);</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(LookAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnLook);</span><br><span class="line">        EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(FireAction, ETriggerEvent::Triggered, <span class="keyword">this</span>, &amp;AMyPlayerController::OnFire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnJump</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ACharacter* Character = <span class="built_in">GetCharacter</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Character-&gt;<span class="built_in">Jump</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnMove</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FVector2D MovementVector = Value.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ACharacter* Character = <span class="built_in">GetCharacter</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FRotator Rotation = <span class="built_in">GetControlRotation</span>();</span><br><span class="line">        <span class="function"><span class="type">const</span> FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0</span>, Rotation.Yaw, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> FVector ForwardDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X);</span><br><span class="line">        <span class="type">const</span> FVector RightDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::Y);</span><br><span class="line">        </span><br><span class="line">        Character-&gt;<span class="built_in">AddMovementInput</span>(ForwardDirection, MovementVector.Y);</span><br><span class="line">        Character-&gt;<span class="built_in">AddMovementInput</span>(RightDirection, MovementVector.X);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnLook</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FVector2D LookAxisVector = Value.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsLookInputIgnored</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AddYawInput</span>(LookAxisVector.X);</span><br><span class="line">    <span class="built_in">AddPitchInput</span>(LookAxisVector.Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPlayerController::OnFire</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实现射击逻辑</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Fire!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何获取控制器的旋转角度并转换成向量-常用"><a href="#如何获取控制器的旋转角度并转换成向量-常用" class="headerlink" title="如何获取控制器的旋转角度并转换成向量-常用"></a>如何获取控制器的旋转角度并转换成向量-常用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ABird::Move</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;MoveForward&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (Value != <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//根据控制器旋转获取移动方向</span></span><br><span class="line">        FRotator Rotation = <span class="built_in">GetControlRotation</span>();</span><br><span class="line">        <span class="function">FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0</span>, Rotation.Yaw, <span class="number">0</span>)</span></span>;<span class="comment">//获取旋转的Yaw角度</span></span><br><span class="line">        FVector Direction = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X);<span class="comment">//通过旋转矩阵获取方向向量</span></span><br><span class="line">        <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></figure><h1 id="虚幻添加模块的办法-常用"><a href="#虚幻添加模块的办法-常用" class="headerlink" title="虚幻添加模块的办法-常用"></a>虚幻添加模块的办法-常用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.<span class="built_in">AddRange</span>(</span><br><span class="line">    <span class="keyword">new</span> string[] &#123;</span><br><span class="line">        <span class="string">&quot;Core&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CoreUObject&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">        <span class="string">&quot;GroomComponent&quot;</span>  <span class="comment">// 添加毛发组件模块</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="虚幻枚举"><a href="#虚幻枚举" class="headerlink" title="虚幻枚举"></a>虚幻枚举</h1><p>![[Pasted image 20250412151930.png]]<br>在虚幻引擎（Unreal Engine，简称UE）中，​<strong>​枚举（Enum）​</strong>​是一种非常有用的数据类型，用于定义一组命名的常量。使用枚举可以提高代码的可读性和可维护性，避免使用魔法数字（magic numbers），并简化逻辑判断。以下是关于虚幻引擎中枚举的详细介绍，包括其定义、使用方法、类型以及在蓝图和C++中的具体应用。</p><hr><h2 id="​​1-枚举的基本概念​​"><a href="#​​1-枚举的基本概念​​" class="headerlink" title="​​1. 枚举的基本概念​​"></a>​<strong>​1. 枚举的基本概念​</strong>​</h2><p>​<strong>​枚举​</strong>​（Enumeration）是一种用户定义的数据类型，它包含了一组命名的整数常量。通过枚举，可以为这些常量赋予有意义的名字，使代码更加直观和易于理解。<br>​<strong>​示例：​</strong>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EWeekDays</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">`</span><br><span class="line">在上述示例中，`EWeekDays` 是一个枚举类型，包含了一周的七天。每个枚举值（如 `Monday`、`Tuesday` 等）都对应一个整数值，默认情况下从<span class="number">0</span>开始递增。</span><br><span class="line">---</span><br><span class="line">虚幻引擎支持两种主要的枚举类型：</span><br><span class="line"></span><br><span class="line">在C++中定义枚举时，推荐使用 `<span class="keyword">enum</span> <span class="title class_">class</span>`，因为它提供了更好的类型安全和作用域控制。</span><br><span class="line">​**​定义枚举：​**​</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="title">UENUM</span><span class="params">(BlueprintType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> <span class="keyword">class</span> ECharacterClass : uint8</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="function">GUARDIAN <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Guardian&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    WARRIOR  <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Warrior&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    MAGE     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Mage&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    ROGUE    <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Rogue&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure><p>​<strong>​说明：​</strong>​</p><ul><li><code>UENUM(BlueprintType)</code> 宏用于将枚举暴露给蓝图系统，使其在蓝图中可用。</li><li><code>UMETA(DisplayName = &quot;Guardian&quot;)</code> 提供了枚举编辑器中的显示名称，增强可读性。</li><li>使用 <code>enum class</code> 而不是传统的 <code>enum</code>，以避免命名冲突和类型隐式转换的问题。</li></ul><h3 id="​​2-2-蓝图枚举（Blueprint-Enum）​​"><a href="#​​2-2-蓝图枚举（Blueprint-Enum）​​" class="headerlink" title="​​2.2 蓝图枚举（Blueprint Enum）​​"></a>​<strong>​2.2 蓝图枚举（Blueprint Enum）​</strong>​</h3><p>蓝图枚举是专门在蓝图中创建和使用的枚举类型，适用于不需要复杂C++逻辑的场景。<br>​<strong>​创建蓝图枚举的步骤：​</strong>​</p><ol><li>在内容浏览器中，右键点击空白区域，选择 <code>Blueprint Class</code>。</li><li>在弹出的窗口中，选择 <code>Enumeration</code> 作为父类。</li><li>命名并创建蓝图枚举。</li><li>双击打开蓝图枚举，添加和命名各个枚举值。</li></ol><h2 id="​​优点：​​-易于在蓝图中创建和使用，无需编写C-代码。-适用于快速原型设计和逻辑简单的项目。​​缺点：​​-功能上不如C-枚举灵活，特别是在需要复杂逻辑或与其他C-系统集成时。"><a href="#​​优点：​​-易于在蓝图中创建和使用，无需编写C-代码。-适用于快速原型设计和逻辑简单的项目。​​缺点：​​-功能上不如C-枚举灵活，特别是在需要复杂逻辑或与其他C-系统集成时。" class="headerlink" title="​​优点：​​- 易于在蓝图中创建和使用，无需编写C++代码。- 适用于快速原型设计和逻辑简单的项目。​​缺点：​​- 功能上不如C++枚举灵活，特别是在需要复杂逻辑或与其他C++系统集成时。"></a>​<strong>​优点：​</strong>​<br>- 易于在蓝图中创建和使用，无需编写C++代码。<br>- 适用于快速原型设计和逻辑简单的项目。<br>​<strong>​缺点：​</strong>​<br>- 功能上不如C++枚举灵活，特别是在需要复杂逻辑或与其他C++系统集成时。</h2><h2 id="​​3-枚举的使用方法​​"><a href="#​​3-枚举的使用方法​​" class="headerlink" title="​​3. 枚举的使用方法​​"></a>​<strong>​3. 枚举的使用方法​</strong>​</h2><h3 id="​​3-1-在C-中使用枚举​​"><a href="#​​3-1-在C-中使用枚举​​" class="headerlink" title="​​3.1 在C++中使用枚举​​"></a>​<strong>​3.1 在C++中使用枚举​</strong>​</h3><h4 id="​​定义枚举变量​​"><a href="#​​定义枚举变量​​" class="headerlink" title="​​定义枚举变量​​"></a>​<strong>​定义枚举变量​</strong>​</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E CharacterClass = ECharacterClass::Warrior;</span><br></pre></td></tr></table></figure><h4 id="​​在函数中使用枚举​​"><a href="#​​在函数中使用枚举​​" class="headerlink" title="​​在函数中使用枚举​​"></a>​<strong>​在函数中使用枚举​</strong>​</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::SetCharacterClass</span><span class="params">(ECharacterClass NewClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CharacterClass = NewClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (CharacterClass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Guardian:</span><br><span class="line">            <span class="comment">// 守护者逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Warrior:</span><br><span class="line">            <span class="comment">// 战士逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Mage:</span><br><span class="line">            <span class="comment">// 法师逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterClass::Rogue:</span><br><span class="line">            <span class="comment">// 潜行侠逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="​​枚举与蓝图交互​​"><a href="#​​枚举与蓝图交互​​" class="headerlink" title="​​枚举与蓝图交互​​"></a>​<strong>​枚举与蓝图交互​</strong>​</h4><p>通过 <code>UENUM(BlueprintType)</code> 宏，可以在蓝图中访问和修改C++中定义的枚举变量。</p><p>​<strong>​示例：在蓝图中设置角色的职业​</strong>​</p><ol><li><p>在角色类中定义一个公开的枚举变量：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;Character&quot;</span>)</span><br><span class="line">ECharacterClass CharacterClass;</span><br></pre></td></tr></table></figure></li><li><p>在蓝图中，可以通过细节面板直接选择或通过节点修改 <code>CharacterClass</code> 的值。</p></li></ol><h3 id="​​3-2-在蓝图中使用枚举​​"><a href="#​​3-2-在蓝图中使用枚举​​" class="headerlink" title="​​3.2 在蓝图中使用枚举​​"></a>​<strong>​3.2 在蓝图中使用枚举​</strong>​</h3><h4 id="​​创建和使用蓝图枚举​​"><a href="#​​创建和使用蓝图枚举​​" class="headerlink" title="​​创建和使用蓝图枚举​​"></a>​<strong>​创建和使用蓝图枚举​</strong>​</h4><ol><li>​<strong>​创建蓝图枚举​</strong>​：<ul><li>按照前述步骤在内容浏览器中创建一个蓝图枚举，例如 <code>EBP_WeaponType</code>，包含 <code>Pistol</code>、<code>Rifle</code>、<code>Shotgun</code> 等枚举值。</li></ul></li><li>​<strong>​在蓝图中使用枚举变量​</strong>​：<ul><li>在蓝图中添加一个枚举类型的变量，选择刚刚创建的 <code>EBP_WeaponType</code>。</li><li>使用 ​<strong>​Switch on Enum​</strong>​ 节点根据枚举值执行不同的逻辑。<br>​<strong>​示例：根据武器类型播放不同的声音​</strong>​</li></ul></li><li>添加一个 <code>_WeaponType</code> 类型的变量 <code>CurrentWeapon</code>。</li><li>使用 ​<strong>​Switch on Enum​</strong>​ 节点，输入 <code>CurrentWeapon</code>。</li><li>为每个枚举值（如 <code>Pistol</code>、<code>Rifle</code>、<code>Shotgun</code>）添加对应的分支，并连接播放相应声音的节点。</li></ol><hr><h2 id="​​4-枚举的高级用法​​"><a href="#​​4-枚举的高级用法​​" class="headerlink" title="​​4. 枚举的高级用法​​"></a>​<strong>​4. 枚举的高级用法​</strong>​</h2><h3 id="​​4-1-枚举与位掩码（Bitmask）​​"><a href="#​​4-1-枚举与位掩码（Bitmask）​​" class="headerlink" title="​​4.1 枚举与位掩码（Bitmask）​​"></a>​<strong>​4.1 枚举与位掩码（Bitmask）​</strong>​</h3><p>有时需要将多个枚举值组合在一起使用，这时可以使用位掩码。虚幻引擎支持通过设置 <code>Meta</code> 参数来启用位掩码功能。<br>​<strong>​定义位掩码枚举：​</strong>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EPermissions</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    None        = <span class="number">0</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;None&quot;</span>),</span><br><span class="line">    Read        = <span class="number">1</span> &lt;&lt; <span class="number">0</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Read&quot;</span>),</span><br><span class="line">    Write       = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Write&quot;</span>),</span><br><span class="line">    Execute     = <span class="number">1</span> &lt;&lt; <span class="number">2</span> <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;Execute&quot;</span>),</span><br><span class="line">    All         = Read | Write | Execute <span class="built_in">UMETA</span>(DisplayName = <span class="string">&quot;All&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>​使用位掩码枚举：​</strong>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EPermissions UserPermissions = EPermissions::Read | EPermissions::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UserPermissions &amp; EPermissions::Read)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户有读取权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((UserPermissions &amp; EPermissions::All) == EPermissions::All)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户拥有所有权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>​说明：​</strong>​</p><ul><li>使用位移运算符 <code>&lt;&lt;</code> 定义每个权限的独立位。</li><li>使用按位与 <code>&amp;</code> 和按位或 <code>|</code> 运算符进行权限的组合和检查。</li></ul><h3 id="​​4-2-枚举参数​​"><a href="#​​4-2-枚举参数​​" class="headerlink" title="​​4.2 枚举参数​​"></a>​<strong>​4.2 枚举参数​</strong>​</h3><p>枚举常用于函数参数，以增强函数的灵活性和可读性。<br>​<strong>​示例：​</strong>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerformAttack</span><span class="params">(EAttackType AttackType)</span></span>;</span><br></pre></td></tr></table></figure><p>​<strong>​调用方式：​</strong>​<br>在蓝图中调用 <code>PerformAttack</code> 函数时，可以通过下拉菜单选择具体的攻击类型（如 <code>Melee</code>、<code>Ranged</code>、<code>Magic</code>），无需记住具体的数值。</p><h3 id="​​4-3-枚举与数据表（Data-Tables）​​"><a href="#​​4-3-枚举与数据表（Data-Tables）​​" class="headerlink" title="​​4.3 枚举与数据表（Data Tables）​​"></a>​<strong>​4.3 枚举与数据表（Data Tables）​</strong>​</h3><p>枚举可以与数据表结合使用，数据驱动的设计中管理大量相关数据。</p><p>​<strong>​步骤：​</strong>​</p><ol><li>定义一个枚举，表示不同的数据类别。</li><li>创建一个结构体，包含该枚举作为成员变量。</li><li>在编辑器中创建并填充数据表，使用该结构体作为行类型。</li><li>在代码或蓝图中读取数据表，并根据枚举值处理相应的数据。</li></ol><p>​<strong>​示例：​</strong>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FWeaponData</span> : <span class="keyword">public</span> FTableRowBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">    EWeaponType WeaponType;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">    <span class="type">float</span> Damage;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)</span><br><span class="line">    <span class="type">float</span> Range;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="​​5-常见问题与解决方案​​"><a href="#​​5-常见问题与解决方案​​" class="headerlink" title="​​5. 常见问题与解决方案​​"></a>​<strong>​5. 常见问题与解决方案​</strong>​</h2><h3 id="​​5-1-枚举值在蓝图中不显示​​"><a href="#​​5-1-枚举值在蓝图中不显示​​" class="headerlink" title="​​5.1 枚举值在蓝图中不显示​​"></a>​<strong>​5.1 枚举值在蓝图中不显示​</strong>​</h3><p>​<strong>​原因：​</strong>​</p><ul><li>枚举未正确暴露给蓝图，或者缺少必要的元数据。</li></ul><p>​<strong>​解决方法：​</strong>​</p><ul><li>确保在C++中使用 <code>UENUM(BlueprintType)</code> 宏定义枚举。</li><li>检查枚举值是否正确添加了 <code>UMName)</code>，以增强在蓝图中的可读性。</li></ul><h3 id="​​5-2-枚举值在不同平台上的兼容性​​"><a href="#​​5-2-枚举值在不同平台上的兼容性​​" class="headerlink" title="​​5.2 枚举值在不同平台上的兼容性​​"></a>​<strong>​5.2 枚举值在不同平台上的兼容性​</strong>​</h3><p>​<strong>​原因：​</strong>​</p><ul><li>不同平台对枚举大小的默认处理可能不同，导致跨平台数据传输时出现问题。</li></ul><p>​<strong>​解决方法：​</strong>​</p><ul><li><p>明确定义枚举的基础类型，如 <code>uint8</code>，以确保在所有平台上的一致性。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EExampleEnum</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    Value1,</span><br><span class="line">    Value2,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="​​5-3-枚举与序列化问题​​"><a href="#​​5-3-枚举与序列化问题​​" class="headerlink" title="​​5.3 枚举与序列化问题​​"></a>​<strong>​5.3 枚举与序列化问题​</strong>​</h3><p>​<strong>​原因：​</strong>​</p><ul><li>在保存和加载过程中，枚举值可能因为版本变更或未正确处理而导致数据丢失或错误。<br>​<strong>​解决方法：​</strong>​</li><li>确保在序列化相关的数据结构时，枚举值被正确处理。</li><li>使用版本控制机制，以应对枚举值的变更。</li></ul><hr><h2 id="​​6-最佳实践​​"><a href="#​​6-最佳实践​​" class="headerlink" title="​​6. 最佳实践​​"></a>​<strong>​6. 最佳实践​</strong>​</h2><ol><li>​<strong>​使用 <code>enum class</code> 而非传统 <code>enum</code>​</strong>​：<ul><li>提供更好的类型安全和作用域控制，避免命名冲突和隐式转换。</li></ul></li><li>​<strong>​为枚举值添加有意义的名称​</strong>​：<ul><li>使用描述性强的名称，增强代码的可读性和可维护性。</li></ul></li><li>​<strong>​暴露必要的枚举给蓝图​</strong>​：<ul><li>通过 <code>UENUM(BlueprintType)</code> 将需要在蓝图中使用的枚举暴露出来，并合理使用 <code>UMETA</code> 元数据增强其可用性。</li></ul></li><li>​<strong>​考虑枚举的可扩展性​</strong>​：<ul><li>在设计枚举时，预留一定的空间以备将来可能的扩展，避免频繁修改已有的枚举值。</li></ul></li><li>​<strong>​文档和注释​</strong>​：<ul><li>为枚举及其值添加详细的文档和注释，帮助团队成员理解其用途和含义。</li></ul></li><li>​<strong>​避免使用魔法数字​</strong>​：<ul><li>始终使用枚举替代硬编码的数字，提高代码的可读性和可维护性。</li></ul></li></ol><hr><h2 id="​​7-示例项目​​"><a href="#​​7-示例项目​​" class="headerlink" title="​​7. 示例项目​​"></a>​<strong>​7. 示例项目​</strong>​</h2><p>以下是一个简单的示例，展示如何在虚幻枚举来管理角色的状态。</p><h3 id="​​7-1-定义枚举​​"><a href="#​​7-1-定义枚举​​" class="headerlink" title="​​7.1 定义枚举​​"></a>​<strong>​7.1 定义枚举​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterStateEnum.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CharacterStateEnum.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ECharacterState</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Idle        <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Idle&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Walking     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Walking&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Running     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Running&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Jumping     <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Jumping&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Attacking   <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Attacking&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Dead        <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dead&quot;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure><h3 id="​​7-2-在角色类中使用枚举​​"><a href="#​​7-2-在角色类中使用枚举​​" class="headerlink" title="​​7.2 在角色类中使用枚举​​"></a>​<strong>​7.2 在角色类中使用枚举​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CharacterStateEnum.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYGAME_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 角色当前状态</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;State&quot;</span>)</span><br><span class="line">    ECharacterState CurrentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换状态函数</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;State&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(ECharacterState NewState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    CurrentState = ECharacterState::Idle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">    <span class="built_in">HandleState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::SetState</span><span class="params">(ECharacterState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CurrentState = NewState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::HandleState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (CurrentState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Idle:</span><br><span class="line">            <span class="comment">// 执行闲置逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Walking:</span><br><span class="line">            <span class="comment">// 执行行走逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Running:</span><br><span class="line">            <span class="comment">// 执行奔跑逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Jumping:</span><br><span class="line">            <span class="comment">// 执行跳跃逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Attacking:</span><br><span class="line">            <span class="comment">// 执行攻击逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ECharacterState::Dead:</span><br><span class="line">            <span class="comment">// 执行死亡逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="​​7-3-在蓝图中使用枚举​​"><a href="#​​7-3-在蓝图中使用枚举​​" class="headerlink" title="​​7.3 在蓝图中使用枚举​​"></a>​<strong>​7.3 在蓝图中使用枚举​</strong>​</h3><ol><li><p>​<strong>​创建角色蓝图​</strong>​：</p><ul><li>基于 <code>AMyCharacter</code> 创建一个蓝图类 <code>BP_MyCharacter</code>。</li></ul></li><li><p>​<strong>​设置状态变量​</strong>​：</p><ul><li>在蓝图的细节面板中，可以看到 <code>CurrentState</code> 变量，可以直接选择不同的状态。</li></ul></li><li><p>​<strong>​调用状态切换函数​</strong>​：</p><ul><li>使用事件图表中的节点调用 <code>SetState</code> 函数，动态改变角色的状态。</li></ul></li><li><p>​<strong>​扩展状态逻辑​</strong>​：</p><ul><li>在蓝图中，可以进一步扩展 <code>HandleState</code> 的逻辑，使用 ​<strong>​Switch on Enum​</strong>​ 节点根据 <code>CurrentState</code> 执行不同的行为。</li></ul></li></ol><h1 id="硬引用和软引用-性能相关"><a href="#硬引用和软引用-性能相关" class="headerlink" title="硬引用和软引用- 性能相关"></a>硬引用和软引用- 性能相关</h1><p>在虚幻引擎（Unreal Engine）中，<strong>软引用（Soft Reference）</strong>和<strong>硬引用（Hard Reference）</strong>是资源加载和管理的核心概念，直接影响内存使用、加载性能和项目维护。以下是它们的详细对比和用法：</p><hr><h3 id="1-硬引用（Hard-Reference）"><a href="#1-硬引用（Hard-Reference）" class="headerlink" title="1. 硬引用（Hard Reference）"></a><strong>1. 硬引用（Hard Reference）</strong></h3><p><strong>定义</strong>：<br>硬引用表示资源在运行时<strong>强制加载</strong>到内存中。只要引用者存在，被引用的资源会一直驻留内存。<br><strong>特点</strong>：</p><ul><li><p><strong>自动加载</strong>：资源随引用它的对象（如蓝图、关卡）一起加载。</p></li><li><p><strong>内存占用高</strong>：可能导致不必要的内存消耗，尤其是引用大型资源（如纹理、模型）。</p></li><li><p><strong>强依赖性</strong>：若被引用的资源丢失，会导致运行时错误（如红色错误提示）。<br><strong>常见场景</strong>：</p></li><li><p>直接拖放资源到蓝图或关卡中（例如：在蓝图中直接指定一个静态网格或材质）。</p></li><li><p>使用 <code>UPROPERTY</code> 声明时未指定特殊修饰符：</p><p>  UPROPERTY()<br>  UTexture2D* HardTextureRef; &#x2F;&#x2F; 硬引用</p></li></ul><p>&#x3D;&#x3D;硬引用&#x3D;&#x3D;    这也是一个硬引用<br>![[Pasted image 20250412160904.png]]<br>&#x3D;&#x3D;创建软引用&#x3D;&#x3D;<br>软引用的好处是资产仅在需要时加载，这可以节省内存。我们对暂时不需要的不关键资产用软引用<br>但是不适合![[Pasted image 20250412161333.png]]</p><p>![[Pasted image 20250412160946.png]]</p><h1 id="虚幻智能指针"><a href="#虚幻智能指针" class="headerlink" title="虚幻智能指针"></a>虚幻智能指针</h1><h2 id="TObjectPtr"><a href="#TObjectPtr" class="headerlink" title="TObjectPtr"></a>TObjectPtr</h2><p>支持访问跟踪和延迟加载<br>访问跟踪：知道对象何时被加载或者访问<br>延迟加载：只在需要时加载资源<br>缺点：主要适用于成员变量，仅仅在编辑器中有效，在发布版本中会被转换成原始指针，所以不会让游戏变得更快，仅仅提供一种编辑体验</p><h1 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h1><h2 id="要获取父类的数据要使用强制转换，将子类对象转换为父类对象-这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。"><a href="#要获取父类的数据要使用强制转换，将子类对象转换为父类对象-这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。" class="headerlink" title="要获取父类的数据要使用强制转换，将子类对象转换为父类对象   这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。"></a>要获取父类的数据要使用强制转换，将子类对象转换为父类对象   这样就能在动画蓝图中获取到父类角色等蓝图的数据，比如角色移动组件，组件中的速度等数据。</h2><p>tips:&#x3D;&#x3D;使用C++指定动画蓝图父类&#x3D;&#x3D;时一定要关闭编辑器！&#x3D;&#x3D;<strong>Animinstance</strong>&#x3D;&#x3D;是所有动画蓝图的基础蓝图类！可以重写它以实现动画蓝图的功能！<br>![[Pasted image 20250331162306.png]]<br>上图所示表示动画开始时获取角色组件，&#x3D;&#x3D;<code>TryGetPawnOwner（）</code>&#x3D;&#x3D; 用于尝试获取当前动画蓝图实例所关联的Pawn（角色）对象。因为character是Pawn的子类，所以也能获取，但是需要Cast&lt;&gt;()进行类型转换<br>另外，NativeThreadSafeUpdateAnimatio()是在线程中执行的函数，性能更佳！</p><h3 id="使用多个动画蓝图控制动画"><a href="#使用多个动画蓝图控制动画" class="headerlink" title="使用多个动画蓝图控制动画"></a>使用多个动画蓝图控制动画</h3><p>创建一个新蓝图，在另一个类中使用链接图表将蓝图链接。intputpose节点设置在需要姿势的动画蓝图里可以链接另一个蓝图的姿势</p><h1 id="动画蒙太奇-一种动画分组容器"><a href="#动画蒙太奇-一种动画分组容器" class="headerlink" title="动画蒙太奇-一种动画分组容器"></a>动画蒙太奇-一种动画分组容器</h1><p>使用标签指定动画播放的顺序，创建插槽将蒙太奇动画关联到插槽<br>![[Pasted image 20250402141713.png]]<br>网格体可以获取到动画示例，并使用动画蒙太奇。</p><blockquote><p>****** &#x3D;&#x3D;<strong>要想使用蒙太奇，必须在动画蓝图中启用插槽！</strong>&#x3D;&#x3D;</p></blockquote><h2 id="UE5-C-动画蓝图关键API：重写动画开始与每帧更新"><a href="#UE5-C-动画蓝图关键API：重写动画开始与每帧更新" class="headerlink" title="UE5 C++动画蓝图关键API：重写动画开始与每帧更新"></a>UE5 C++动画蓝图关键API：重写动画开始与每帧更新</h2><p>以下是Unreal Engine 5中动画系统两个重要API的C++实现方式，分别用于动画开始执行和每帧执行逻辑，和动画蓝图一致,需要重写Animainstace</p><p>![[Pasted image 20250402142248.png]]在角色的.h文件中申明一个攻击蒙太奇变量，通过网格体访问动画实例，然后使用其中的蒙太奇播放函数<br>![[Pasted image 20250402142750.png]]</p><p>关键api:   Montage_JumpToSection()    Montage_Play()</p><h2 id="如何在-C-中接收动画通知​​"><a href="#如何在-C-中接收动画通知​​" class="headerlink" title="如何在 C++ 中接收动画通知​​"></a><strong>如何在 C++ 中接收动画通知​</strong>​</h2><p>要在 C++ 中接收动画通知，需要以下步骤：</p><h3 id="​​-1-创建自定义-AnimNotify-类​​"><a href="#​​-1-创建自定义-AnimNotify-类​​" class="headerlink" title="​​(1) 创建自定义 AnimNotify 类​​"></a>​<strong>​(1) 创建自定义 AnimNotify 类​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyAnimNotify.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Animation/AnimNotifies/AnimNotify.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAnimNotify.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnMyAnimNotify, USkeletalMeshComponent*, MeshComp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAME_API</span> UMyAnimNotify : <span class="keyword">public</span> UAnimNotify</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写 Notify 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Notify</span><span class="params">(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：声明一个动态多播委托，用于在蓝图中绑定回调</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">&quot;Animation&quot;</span>)</span><br><span class="line">    FOnMyAnimNotify OnNotifyTriggered;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyAnimNotify.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAnimNotify.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SkeletalMeshComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyAnimNotify::Notify</span><span class="params">(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Notify</span>(MeshComp, Animation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里执行你的逻辑（如播放音效、生成特效等）</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;MyAnimNotify Triggered!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要，可以触发委托</span></span><br><span class="line">    <span class="keyword">if</span> (OnNotifyTriggered.<span class="built_in">IsBound</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        OnNotifyTriggered.<span class="built_in">Broadcast</span>(MeshComp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="​​-2-在动画序列中添加自定义通知​​"><a href="#​​-2-在动画序列中添加自定义通知​​" class="headerlink" title="​​(2) 在动画序列中添加自定义通知​​"></a>​<strong>​(2) 在动画序列中添加自定义通知​</strong>​</h3><ol><li>打开 ​<strong>​动画序列（Animation Sequence）​</strong>​。</li><li>在时间轴上右键点击，选择 ​<strong>​Add Notify​</strong>​ → ​<strong>​Add Custom​</strong>​。</li><li>选择你的自定义通知类（如 <code>MyAnimNotify</code>）。</li><li>调整通知的时间点，动画序列执行到通知点即可执行你需要的逻辑<br>一般来说简单逻辑直接在编辑器中实现就好了</li></ol><h2 id="Kismet数学库"><a href="#Kismet数学库" class="headerlink" title="Kismet数学库"></a>Kismet数学库</h2><h3 id="具有向量运算等强大功能，详情查询UE帮助手册"><a href="#具有向量运算等强大功能，详情查询UE帮助手册" class="headerlink" title="具有向量运算等强大功能，详情查询UE帮助手册"></a>具有向量运算等强大功能，详情查询UE帮助手册</h3><p>![[Pasted image 20250331162234.png]]</p><h1 id="反向动力学-IK-inverse-kinematics"><a href="#反向动力学-IK-inverse-kinematics" class="headerlink" title="反向动力学-IK    inverse kinematics"></a>反向动力学-IK    inverse kinematics</h1><h2 id="球体追踪-一种定位距离办法"><a href="#球体追踪-一种定位距离办法" class="headerlink" title="球体追踪-一种定位距离办法"></a>球体追踪-一种定位距离办法</h2><h3 id="控制骨架-animation动画"><a href="#控制骨架-animation动画" class="headerlink" title="控制骨架-animation动画"></a>控制骨架-animation动画</h3><p>可以根据末端执行器移动骨骼位置，指定末端骨骼，IK骨骼，或者添加虚拟骨骼，<br>一：导入骨架<br>二：创建足部追踪函数<br>三：添加新参数：rig element key<br>四：添加get transform函数<br>![[Pasted image 20250331180247.png]]<br>![[Pasted image 20250331180347.png]]<br>![[Pasted image 20250331180436.png]]</p><h2 id="添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置"><a href="#添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置" class="headerlink" title="添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置"></a>添加球追踪通道-具有起点和终点两个向量，会返回一个命中位置</h2><p>经常使用插值来使变量平滑过渡</p><h2 id="全身IK-UE5新增-难点"><a href="#全身IK-UE5新增-难点" class="headerlink" title="全身IK-UE5新增(难点)"></a>全身IK-UE5新增(难点)</h2><p>对身体的任意一串骨骼指定末端执行器</p><h1 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h1><p>所有网格体都具有碰撞属性<br>1.无碰撞<br>2.仅仅查询-无物理模拟（用于射线检测之类…）<br>3.物理模拟<br>4.开启碰撞-支持物理模拟和射线检测，性能成本最高</p><p>简单碰撞与复杂碰撞</p><p>支持重力与推力….需要手动启用</p><h1 id="重叠事件"><a href="#重叠事件" class="headerlink" title="重叠事件"></a>重叠事件</h1><p>使用前必须将角色和角色身上的组件重叠事件设为true</p><p>球体组件 </p><p>当两个物体重叠时就会触发这个事件，可以</p><p>组件开始重叠（用得最多）</p><p>虚幻5中的委托</p><p>观察者模式-</p><p>委托是一种特殊的类，组件对象旗下有许多的委托，比如组件重叠事件，组件开始重叠，组件结束重叠，可以储存观察者列表，可以为某一个特定对象创造委托。并广播这个委托。<br>![[Pasted image 20250401165837.png]]<br>组件继承关系↑</p><p>C++实现：<br>需要创建一个回调函数，这个回调函数可以提供许多关于回调函数的信息，绑定到动态多播委托，要绑定必须对反射系统可见，需要加上UFUNCTION()，因为这种类型的委托可以被蓝图访问</p><p>访问&#x3D;&#x3D;组件对象&#x3D;&#x3D;下面的oncomponentBeginOverlap函数下的AddDynamic(用户对象，回调函数的地址)</p><p>然后回调函数就会在组件重叠的时候被触发。<br>Tips:在虚幻5中要重写继承的虚函数，需要移除UFUCTION等宏，因为会隐式继承一个宏。super常用于保留原函数的功能</p><h1 id="骨骼插槽"><a href="#骨骼插槽" class="headerlink" title="骨骼插槽"></a>骨骼插槽</h1><h1 id="动画重定向-反向目标定位"><a href="#动画重定向-反向目标定位" class="headerlink" title="动画重定向-反向目标定位"></a>动画重定向-反向目标定位</h1><p>1.根据导入的骨骼创建IK骨架，设置反相目标根节点（是所有骨骼中联系其它骨骼的核心节点），<br>根据设置的根节点新建链条，指定起始骨骼。从选定骨骼创建新的重新定位链。<br>2.根据需要替换的骨骼创建IK骨架<br>3.创建IK反向目标</p><p>tips:强制内联，FORCEINLINE</p><h1 id="虚幻引擎拾取系统实现方案总结"><a href="#虚幻引擎拾取系统实现方案总结" class="headerlink" title="虚幻引擎拾取系统实现方案总结"></a>虚幻引擎拾取系统实现方案总结</h1><h2 id="基于重叠事件的拾取系统实现"><a href="#基于重叠事件的拾取系统实现" class="headerlink" title="基于重叠事件的拾取系统实现"></a>基于重叠事件的拾取系统实现</h2><h3 id="核心实现步骤"><a href="#核心实现步骤" class="headerlink" title="核心实现步骤"></a>核心实现步骤</h3><ol><li><p><strong>物品基类(AItem)创建</strong></p><ul><li>继承自<code>AActor</code></li><li>包含<code>USphereComponent</code>用于碰撞检测</li><li>实现<code>PickUp</code>虚函数供子类重写</li></ul></li><li><p><strong>关键代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item.h关键部分</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere) </span><br><span class="line">USphereComponent* CollisionSphere;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnBeginOverlap</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item.cpp关键部分</span></span><br><span class="line">CollisionSphere-&gt;OnComponentBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AItem::OnBeginOverlap);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AItem::OnBeginOverlap</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(APawn* Picker = <span class="built_in">Cast</span>&lt;APawn&gt;(OtherActor))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PickUp</span>(Picker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line"># 虚幻引擎枚举</span><br><span class="line">在普通枚举中加E，枚举变量前加ECS_   ，枚举后面限定枚举变量的数据结构大小以避免额外开销</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250402083301.</span>png]]</span><br><span class="line">在蓝图中指定显示属性</span><br><span class="line">![[Pasted image <span class="number">20250402083446.</span>png]]</span><br><span class="line"></span><br><span class="line"># 在动画实例中更新角色持有武器的状态</span><br><span class="line">![[Pasted image <span class="number">20250402084241.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250402084722.</span>png]]利用枚举选择动画状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 音效</span><br><span class="line"></span><br><span class="line">sound_cue功能可以修改音效，而不改动原本的音频资源</span><br><span class="line"></span><br><span class="line">虚幻<span class="number">5</span>中mate-sounds也可以，优于sound_cue。SFX格式，可以制作随机音效等程序化音效</span><br><span class="line">![[Pasted image <span class="number">20250402160539.</span>png]]![[Pasted image <span class="number">20250402161158.</span>png]]混洗功能</span><br><span class="line"></span><br><span class="line"># UE5的接口类-实际上是一个虚基类</span><br><span class="line">* 将自定义的函数暴露给作用类，而不用考虑类型，使用时作用类继承接口类重写虚函数即可，接口可以实现各个类进行通信，下面是个例子，</span><br><span class="line">![[Pasted image <span class="number">20250404092303.</span>png]]</span><br><span class="line">如果检测碰撞返回的类被成功转换为接口类，则执行接口函数，因为接口类本身就是传递对象的父类，所以能转换成功。然后调用其中的函数将数据传输给另一个类，实现通信。</span><br><span class="line">![[Pasted image <span class="number">20250404092750.</span>png]]</span><br><span class="line"></span><br><span class="line"># 向量点积-求两个向量之间的夹角-返回的是标量无方向</span><br><span class="line">![[Pasted image <span class="number">20250404094522.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 向量归一化</span><br><span class="line">![[Pasted image <span class="number">20250404094726.</span>png]]</span><br><span class="line"></span><br><span class="line">打击点位置-物体位置=指向打击点位置的向量，下面使用UE5的点积式求解角度，此时DotProduct为Cosθ</span><br><span class="line">![[Pasted image <span class="number">20250404095327.</span>png]]</span><br><span class="line">然后计算反余弦即可求出角度θ![[Pasted image <span class="number">20250404110709.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404113610.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 向量叉积</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404114917.</span>png]]</span><br><span class="line">![[Pasted image <span class="number">20250404115350.</span>png]]</span><br><span class="line"></span><br><span class="line">虚幻采用左手坐标系</span><br><span class="line"></span><br><span class="line"># Cascade特效与Niagara</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cascade特效系统</span><br><span class="line">![[Pasted image <span class="number">20250404144744.</span>png]]![[Pasted image <span class="number">20250404145002.</span>png]]</span><br><span class="line">Niagara：</span><br><span class="line">至少需要一个发射器，可以直接挂载在物体上</span><br><span class="line"><span class="number">1.</span>发射器</span><br><span class="line"><span class="number">2.</span>精灵图：会自动面向玩家</span><br><span class="line"><span class="number">3.</span></span><br><span class="line"></span><br><span class="line">在角色身上生成特效：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C++方法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可破坏网格体</span><br><span class="line">场系统：是一个ACtor类</span><br><span class="line">![[Pasted image <span class="number">20250404151132.</span>png]]![[Pasted image <span class="number">20250404151214.</span>png]]</span><br><span class="line">径向衰减，</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404151704.</span>png]]</span><br><span class="line">线性力能打飞物体![[Pasted image <span class="number">20250404151742.</span>png]]</span><br><span class="line">需要一个向量来获取</span><br><span class="line"></span><br><span class="line">C++可以创建一个临时立场，并暴露给蓝图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建一个可破坏物体，并将其挂载在ACTOR上</span><br><span class="line">![[Pasted image <span class="number">20250404153252.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404153622.</span>png]]![[Pasted image <span class="number">20250404153729.</span>png]]</span><br><span class="line">必须包含此模块</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 蓝图原生事件</span><br><span class="line">![[Pasted image <span class="number">20250404154338.</span>png]]</span><br><span class="line"></span><br><span class="line">一旦使用，可以在蓝图和C++中同时使用接口类的接口函数，但是你的虚函数会加上特殊后缀，这样就能将接口暴露给策划或者美术使用![[Pasted image <span class="number">20250404154538.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面一行是加上后缀后的新方法![[Pasted image <span class="number">20250404154728.</span>png]]</span><br><span class="line"></span><br><span class="line">从指定位置生成物体</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404160134.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404160412.</span>png]]一旦发生事件重叠，则消除物品</span><br><span class="line"></span><br><span class="line">C++实现生成物品：</span><br><span class="line">![[Pasted image <span class="number">20250404160912.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先声明一个UClass类暴露给编辑器，然后去编辑器指定蓝图类，则可以用C++生成一个蓝图类（非常重要！）</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404161558.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250404161755.</span>png]]</span><br><span class="line">限定修饰器，取代UClass,可以限定继承蓝图类。最好使用它。</span><br><span class="line"></span><br><span class="line">tips:蓝图也可以继承</span><br><span class="line"></span><br><span class="line"># 自定义组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 伤害</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以在任何角色类中重写伤害函数，这是虚幻自带的伤害函数</span><br><span class="line">![[Pasted image <span class="number">20250405132812.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250405133835.</span>png]]</span><br><span class="line">将健康值限制到<span class="number">0</span>和最大生命之间</span><br><span class="line">![[Pasted image <span class="number">20250405134525.</span>png]]![[Pasted image <span class="number">20250405134850.</span>png]]</span><br><span class="line">![[Pasted image <span class="number">20250405140837.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 追踪角色</span><br><span class="line">利用takedamage函数可以获取攻击对象，将攻击对象存入指针，这样就你能访问攻击对象的属性和方法</span><br><span class="line">![[Pasted image <span class="number">20250406102654.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406102830.</span>png]]</span><br><span class="line">例如判断攻击角色与被攻击角色的距离</span><br><span class="line">![[Pasted image <span class="number">20250406102949.</span>png]]</span><br><span class="line">设置默认半径</span><br><span class="line">![[Pasted image <span class="number">20250406103010.</span>png]]</span><br><span class="line">如果距离大于攻击半径，将攻击对象置空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># AI-导航网格</span><br><span class="line"></span><br><span class="line">## 首先需要创建导航网格体网格![[Pasted image <span class="number">20250406113807.</span>png]]</span><br><span class="line">show navigation控制台开启显示导航命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 混合空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406121727.</span>png]]</span><br><span class="line">这个是动画蓝图中的状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">混合空间可以组合多种动画，并根据变量大小执行相应过渡动画。</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406122450.</span>png]]</span><br><span class="line">设置这个之后可以将移动交给AI托管，</span><br><span class="line">![[Pasted image <span class="number">20250406122537.</span>png]]</span><br><span class="line">必须包含这个头文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 导航目标</span><br><span class="line">![[Pasted image <span class="number">20250406123934.</span>png]]</span><br><span class="line"></span><br><span class="line">可以利用一个角色指针数组将导航点存在里面，需要开启AI模块，并包含相关头文件</span><br><span class="line">![[Pasted image <span class="number">20250406124514.</span>png]]![[Pasted image <span class="number">20250406124901.</span>png]]</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406124934.</span>png]]</span><br><span class="line">创建一个AI控制器，并将目标设为导航点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406125423.</span>png]]</span><br><span class="line"># UE5 AI移动请求代码总结</span><br><span class="line"></span><br><span class="line">## 代码功能</span><br><span class="line">实现AI导航移动并在路径点上绘制调试球体</span><br><span class="line">前面将导航点暴露给了蓝图，所以能直接用蓝图添加导航点</span><br><span class="line">## 代码解析</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">FAIMoveRequest MoveRequest;</span><br><span class="line">MoveRequest.<span class="built_in">SetGoalActor</span>(PatrolTarget);</span><br><span class="line">MoveRequest.<span class="built_in">SetAcceptanceRadius</span>(<span class="number">15.f</span>);</span><br><span class="line">FNavPathSharedPtr NavPath;</span><br><span class="line">EnemyController-&gt;<span class="built_in">MoveTo</span>(MoveRequest, &amp;NavPath);</span><br><span class="line">TArray&lt;FNavPathPoint&gt;&amp; PathPoints = NavPath-&gt;<span class="built_in">GetPathPoints</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Point : PathPoints)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FVector&amp; Location = Point.Location;</span><br><span class="line">    <span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), Location, <span class="number">12.f</span>, <span class="number">12</span>, FColor::Green, <span class="literal">false</span>, <span class="number">10.f</span>);</span><br><span class="line">&#125;```</span><br><span class="line">### <span class="number">1.</span> 创建移动请求</span><br><span class="line"></span><br><span class="line">- `FAIMoveRequest` - AI移动请求类</span><br><span class="line">### <span class="number">2.</span> 设置移动目标</span><br><span class="line">- `<span class="built_in">SetGoalActor</span>(PatrolTarget)` - 设置目标Actor</span><br><span class="line">- `PatrolTarget` - 要移动到的目标(AActor指针)</span><br><span class="line">### <span class="number">3.</span> 设置接受半径</span><br><span class="line">- `<span class="built_in">SetAcceptanceRadius</span>(<span class="number">15.f</span>)` - 到达判定半径(<span class="number">15</span>厘米)</span><br><span class="line">### <span class="number">4.</span>执行移动命令</span><br><span class="line"></span><br><span class="line">- `FNavPathSharedPtr` - 导航路径共享指针</span><br><span class="line">- `EnemyController-&gt;<span class="built_in">MoveTo</span>()` - 执行移动</span><br><span class="line">    - 参数<span class="number">1</span>: 配置好的移动请求  </span><br><span class="line">    - 参数<span class="number">2</span>: 输出导航路径信息    </span><br><span class="line">### <span class="number">5.</span> 获取路径点</span><br><span class="line">- `<span class="built_in">GetPathPoints</span>()` - 获取路径点数组</span><br><span class="line">- `TArray&lt;FNavPathPoint&gt;` - 路径点动态数组</span><br><span class="line">### <span class="number">6.</span> 绘制调试球体</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">DrawDebugSphere</span>()`参数:</span><br><span class="line">    <span class="number">1.</span> 世界上下文</span><br><span class="line">    <span class="number">2.</span> 球体位置(FVector)</span><br><span class="line">    <span class="number">3.</span> 半径(<span class="number">12</span>厘米)</span><br><span class="line">    <span class="number">4.</span> 细分段数(<span class="number">12</span>)</span><br><span class="line">    <span class="number">5.</span> 颜色(FColor::Green)</span><br><span class="line">    <span class="number">6.</span> 是否持久化(<span class="literal">false</span>)</span><br><span class="line">    <span class="number">7.</span> 显示时间(<span class="number">10</span>秒</span><br><span class="line"></span><br><span class="line">这段代码用于在Unreal Engine <span class="number">5</span>中可视化显示AI的导航路径点，通过在每一个路径点位置绘制绿色球体来辅助调试。</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Point : PathPoints)  <span class="comment">// 遍历导航路径中的所有点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FVector&amp; Location = Point.Location;  <span class="comment">// 获取当前路径点的3D位置坐标</span></span><br><span class="line">    <span class="built_in">DrawDebugSphere</span>(           <span class="comment">// 绘制调试球体函数</span></span><br><span class="line">        <span class="built_in">GetWorld</span>(),            <span class="comment">// 参数1：获取当前游戏世界上下文</span></span><br><span class="line">        Location,              <span class="comment">// 参数2：球体中心位置(使用路径点坐标)</span></span><br><span class="line">        <span class="number">12.f</span>,                  <span class="comment">// 参数3：球体半径(12厘米)</span></span><br><span class="line">        <span class="number">12</span>,                    <span class="comment">// 参数4：球体细分精度(12个分段)</span></span><br><span class="line">        FColor::Green,         <span class="comment">// 参数5：球体颜色(绿色)</span></span><br><span class="line">        <span class="literal">false</span>,                 <span class="comment">// 参数6：是否持久化(false=仅当前帧显示)</span></span><br><span class="line">        <span class="number">10.f</span>                  <span class="comment">// 参数7：显示持续时间(10秒)</span></span><br><span class="line">    );</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406173827.</span>png]]</span><br><span class="line">如果距离小于等于半径返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250406175408.</span>png]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定时器</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(TimerHandle_PrimaryAttack, <span class="keyword">this</span>, &amp;ASCharacter::PrimaryAttack_TimeElapsed, <span class="number">0.2f</span>);</span><br></pre></td></tr></table></figure><p>这段代码是基于虚幻引擎（Unreal Engine）的C++ 代码，主要功能是设置一个定时器，以下是对各部分的详细解释：</p></li><li><p>​<strong>​<code>GetWorldTimerManager()</code>​</strong>​：</p><ul><li>这是虚幻引擎中用于获取当前世界上下文（<code>UWorld</code>）的定时器管理器的函数调用。<code>UWorld</code> 代表游戏世界，定时器管理器则是用来管理和控制各种定时任务的对象。通过调用这个函数，我们可以访问到与当前游戏世界相关的定时器相关功能。</li></ul></li><li><p>​<strong>​<code>.SetTimer()</code>​</strong>​：</p><ul><li>这是定时器管理器的一个成员函数，用于设置一个新的定时器。它接受多个参数来配置定时器的行为。</li></ul></li><li><p>​<strong>​<code>TimerHandle_PrimaryAttack</code>​</strong>​：</p><ul><li>这是一个 <code>FTimerHandle</code> 类型的变量，作为定时器的句柄。句柄就像是定时器的一个唯一标识符，后续可以通过这个句柄来对定时器进行操作，比如取消定时器等。通常在类的成员变量中声明这个句柄，以便在不同的函数中都能引用到同一个定时器。</li></ul></li><li><p>​<strong>​<code>this</code>​</strong>​：</p><ul><li><code>this</code> 指针指向当前对象实例。在这段代码中，它表示当前拥有这个定时器设置代码的对象（一般是某个继承自 <code>ASCharacter</code> 的角色类的实例），定时器相关的回调函数将绑定到这个对象上执行。</li></ul></li><li><p>​<strong>​<code>&amp;ASCharacter::PrimaryAttack_TimeElapsed</code>​</strong>​：</p><ul><li>这是一个函数指针，指向 <code>ASCharacter</code> 类中的 <code>PrimaryAttack_TimeElapsed</code> 成员函数。当定时器到期时，虚幻引擎会调用这个指定的成员函数。也就是说，<code>PrimaryAttack_TimeElapsed</code> 函数是定时器触发时要执行的回调逻辑。</li></ul></li><li><p>​<strong>​<code>0.2f</code>​</strong>​：</p><ul><li>这是一个浮点数参数，表示定时器的延迟时间，单位是秒。这里设置为 <code>0.2f</code> 意味着定时器将在 0.2 秒后触发，调用 <code>PrimaryAttack_TimeElapsed</code> 函数。</li></ul></li></ol><p>&#x3D;&#x3D;这段代码的作用是在当前游戏世界中设置一个定时器，0.2 秒后触发 <code>ASCharacter</code> 类中的 <code>PrimaryAttack_TimeElapsed</code> 函数&#x3D;&#x3D;</p><h1 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h1><h1 id="AI行为树"><a href="#AI行为树" class="headerlink" title="AI行为树"></a>AI行为树</h1><p>需要重写Beginplay()<br>头文件中也需要创建AI行为树对象，在beginpaly中运行<br>![[Pasted image 20250411161843.png]]</p><p>![[Pasted image 20250411162416.png]]</p><h3 id="行为树节点状态预览"><a href="#行为树节点状态预览" class="headerlink" title="行为树节点状态预览"></a>行为树节点状态预览</h3><p>![[Pasted image 20250411164703.png]]</p><p>![[Pasted image 20250411164444.png]]<br>这段代码是一个行为树服务（<code>UBTService</code>）的 <code>TickNode</code> 函数实现，主要用于在行为树执行过程中检查AI控制的棋子（Pawn）与目标Actor之间的距离，并将是否在攻击范围内的结果存储到黑板（Blackboard）组件中。</p><p>以下是在虚幻引擎蓝图中使用上述C++代码逻辑的步骤：</p><h3 id="1-创建行为树"><a href="#1-创建行为树" class="headerlink" title="1. 创建行为树"></a>1. 创建行为树</h3><p>在虚幻编辑器中，打开内容浏览器，右键点击并选择 <code>AI</code> -&gt; <code>行为树</code> 来创建一个新的行为树资产。命名为例如 <code>MyAITree</code>。</p><h3 id="2-创建黑板"><a href="#2-创建黑板" class="headerlink" title="2. 创建黑板"></a>2. 创建黑板</h3><p>同样在内容浏览器中，右键点击并选择 <code>AI</code> -&gt; <code>黑板</code> 来创建一个新的黑板资产。命名为例如 <code>MyBlackboard</code>。</p><h3 id="3-在行为树中使用黑板"><a href="#3-在行为树中使用黑板" class="headerlink" title="3. 在行为树中使用黑板"></a>3. 在行为树中使用黑板</h3><p>打开刚才创建的行为树 <code>MyAITree</code>，在行为树的根节点属性中，将 <code>黑板</code> 属性指定为刚刚创建的 <code>MyBlackboard</code>。</p><h3 id="4-创建AI控制器类"><a href="#4-创建AI控制器类" class="headerlink" title="4. 创建AI控制器类"></a>4. 创建AI控制器类</h3><p>在内容浏览器中，右键点击并选择 <code>C++类</code> -&gt; 选择或创建一个合适的父类（比如 <code>AIController</code>），命名为例如 <code>MyAIController</code>。编译项目，确保C++代码编译通过。</p><h3 id="5-在AI控制器类中关联黑板"><a href="#5-在AI控制器类中关联黑板" class="headerlink" title="5. 在AI控制器类中关联黑板"></a>5. 在AI控制器类中关联黑板</h3><p>打开 <code>MyAIController</code> 的头文件（<code>.h</code> 文件），添加以下代码来声明黑板组件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AIController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAIController.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> AMyAIController : <span class="keyword">public</span> AAIController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    UBlackboardComponent* BlackBoardComp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 <code>MyAIController</code> 的源文件（<code>.cpp</code> 文件）的构造函数或 <code>BeginPlay</code> 函数中初始化黑板组件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAIController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyAIController::<span class="built_in">AMyAIController</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    BlackBoardComp = <span class="built_in">CreateDefaultSubobject</span>&lt;UBlackboardComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BlackBoardComp&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-创建行为树服务类"><a href="#6-创建行为树服务类" class="headerlink" title="6. 创建行为树服务类"></a>6. 创建行为树服务类</h3><p>在内容浏览器中，右键点击并选择 <code>C++类</code> -&gt; 选择或创建一个合适的父类（比如 <code>BTService</code>），命名为例如 <code>S8TService</code>。编译项目。</p><h3 id="7-在行为树服务类中关联黑板键"><a href="#7-在行为树服务类中关联黑板键" class="headerlink" title="7. 在行为树服务类中关联黑板键"></a>7. 在行为树服务类中关联黑板键</h3><p>打开 <code>S8TService</code> 的头文件，确保 <code>AttackRangeKey</code> 是一个已声明的成员变量，并且类型合适（比如 <code>FName</code> 类型），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BehaviorTree/BTService.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;S8TService.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> US8TService : <span class="keyword">public</span> UBTService</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    FName AttackRangeKey;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TickNode</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, <span class="type">float</span> DeltaSeconds)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在源文件中实现 <code>TickNode</code> 函数，就是你提供的那段C++代码（注意修正代码中的语法错误，比如一些乱码和不规范的写法）。</p><h3 id="8-在行为树中使用服务"><a href="#8-在行为树中使用服务" class="headerlink" title="8. 在行为树中使用服务"></a>8. 在行为树中使用服务</h3><p>回到行为树 <code>MyAITree</code>，右键点击行为树的节点区域，搜索并添加 <code>S8TService</code> 服务节点。将其放置在合适的位置（比如在根节点下作为子节点）。</p><h3 id="9-设置黑板键"><a href="#9-设置黑板键" class="headerlink" title="9. 设置黑板键"></a>9. 设置黑板键</h3><p>选中添加的 <code>S8TService</code> 节点，在细节面板中找到 <code>AttackRangeKey</code> 属性，设置其值为黑板中用于存储是否在攻击范围内的布尔键的名称（例如命名为 <code>bIsInAttackRange</code>）。</p><h3 id="10-在黑板中设置初始值"><a href="#10-在黑板中设置初始值" class="headerlink" title="10. 在黑板中设置初始值"></a>10. 在黑板中设置初始值</h3><p>打开 <code>MyBlackboard</code>，创建一个新的布尔类型的键，命名为刚才在服务节点中设置的名称（如 <code>bIsInAttackRange</code>），并设置其初始值为 <code>false</code>。</p><h3 id="11-在AI控制器中使用行为树"><a href="#11-在AI控制器中使用行为树" class="headerlink" title="11. 在AI控制器中使用行为树"></a>11. 在AI控制器中使用行为树</h3><p>打开 <code>MyAIController</code> 的源文件，在 <code>Possess</code> 函数中启动行为树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyAIController::Possess</span><span class="params">(APawn* InPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Possess</span>(InPawn);</span><br><span class="line">    <span class="built_in">RunBehaviorTree</span>(MyBTTree); <span class="comment">// 假设MyBTTree是行为树资产的引用，在头文件中声明并赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中添加相应的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AIController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyAIController.generated.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyBTTree.h&quot;</span> <span class="comment">// 引入行为树资产的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAMENAME_API</span> AMyAIController : <span class="keyword">public</span> AAIController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    UBlackboardComponent* BlackBoardComp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">    UBehaviorTree* MyBTTree;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Possess</span><span class="params">(APawn* InPawn)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完成以上步骤后，在游戏运行时，AI控制器会按照行为树的逻辑，通过 <code>S8TService</code> 服务节点定期检查AI控制的Pawn与目标Actor之间的距离，并将结果存储在黑板的指定布尔键中，供后续的行为树节点使用。</p><h3 id="代码详细解析"><a href="#代码详细解析" class="headerlink" title="代码详细解析"></a>代码详细解析</h3><ol><li>​<strong>​调用父类的 <code>TickNode</code> 函数​</strong>​：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Super::<span class="built_in">TickNode</span>(OwnerComp, NodeMemory, DeltaSeconds);</span><br></pre></td></tr></table></figure><p>这一步确保行为树服务的父类逻辑也能正常执行，维持行为树系统的基本运行流程。</p><ol start="2"><li>​<strong>​获取黑板组件​</strong>​：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBlackboardComponent* BlackBoardComp = OwnerComp.<span class="built_in">GetBlackboardComponent</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ensure</span>(BlackBoardComp))</span><br></pre></td></tr></table></figure><p>通过 <code>OwnerComp</code> 获取与之关联的黑板组件，并使用 <code>ensure</code> 宏进行有效性检查。如果黑板组件不存在，<code>ensure</code> 宏会触发断言（在开发环境下）或进行适当的错误处理（在发布环境下）。</p><ol start="3"><li>​<strong>​获取目标Actor​</strong>​：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AActor* TargetActor = <span class="built_in">Cast</span>&lt;AActor&gt;(BlackBoardComp-&gt;<span class="built_in">GetValueAsObject</span>(<span class="string">&quot;TargetActor&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (TargetActor)</span><br></pre></td></tr></table></figure><p>从黑板组件中获取键为 <code>&quot;TargetActor&quot;</code> 的值，并尝试将其转换为 <code>AActor</code> 类型。如果转换成功且目标Actor存在，则继续后续操作。<br>4. ​<strong>​获取AI控制器和其控制的Pawn​</strong>​：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AAIController* MyController = OwnerComp.<span class="built_in">GetAIOwner</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ensure</span>(MyController))</span><br><span class="line">&#123;</span><br><span class="line">    APawn* AIPawn = MyController-&gt;<span class="built_in">GetPawn</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ensure</span>(AIPawn))</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure><p>首先从 <code>OwnerComp</code> 获取AI的所有者（即AI控制器），然后确保控制器存在。接着通过控制器获取其控制的Pawn，并对Pawn的存在性进行有效性检查。</p><ol start="5"><li>​<strong>​计算距离并判断是否在攻击范围内​</strong>​：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> DistanceTo = FVector::<span class="built_in">Distance</span>(TargetActor-&gt;<span class="built_in">GetActorLocation</span>(), AIPawn-&gt;<span class="built_in">GetActorLocation</span>());</span><br><span class="line"><span class="type">bool</span> bWithinRange = DistanceTo &lt; <span class="number">2000.0f</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>FVector::Distance</code> 函数计算目标Actor和AI控制的Pawn之间的距离，并将距离与设定的阈值 <code>2000.0f</code> 进行比较，判断目标是否在攻击范围内。</p><ol start="6"><li>​<strong>​将结果存储到黑板组件​</strong>​：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlackBoardComp-&gt;<span class="built_in">SetValueAsBool</span>(AttackRangeKey.SelectedKeyName, bWithinRange);</span><br></pre></td></tr></table></figure><p>将判断结果（是否在攻击范围内）以布尔值的形式存储到黑板组件中，使用 <code>AttackRangeKey.SelectedKeyName</code> 作为键。</p><p>![[Pasted image 20250411170301.png]]<br>这段代码是一个行为树任务（<code>UBTTask</code>）的<code>ExecuteTask</code>函数实现，用于在虚幻引擎（Unreal Engine）中执行一个范围攻击任务。其主要目的是让AI角色从枪口位置向目标角色发射一个投射物（如子弹等）。</p><h3 id="代码详细解析-1"><a href="#代码详细解析-1" class="headerlink" title="代码详细解析"></a>代码详细解析</h3><ol><li>​<strong>​获取AI控制器和所属角色​</strong>​</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AAIController* MyController = OwnerComp.<span class="built_in">GetAIOwner</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ensure</span>(MyController))</span><br><span class="line">&#123;</span><br><span class="line">    ACharacter* MyPawn = <span class="built_in">Cast</span>&lt;ACharacter&gt;(MyController-&gt;<span class="built_in">GetPawn</span>());</span><br><span class="line">    <span class="keyword">if</span> (MyPawn == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> EBTNodeResult::Failed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 首先通过`OwnerComp.GetAIOwner()`获取行为树组件的AI控制器。</span><br><span class="line">- 使用`ensure`宏检查AI控制器是否有效。如果有效，再通过`MyController-&gt;GetPawn()`获取AI角色所控制的角色（`ACharacter`类型），并检查该角色是否存在。如果角色不存在，直接返回任务失败。</span><br></pre></td></tr></table></figure><ol start="2"><li>​<strong>​获取枪口位置和目标角色​</strong>​</li></ol><p>cpp</p><p>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FVector MuzzleLocation = MyPawn-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetSocketLocation</span>(<span class="string">&quot;Muzzle_01&quot;</span>);</span><br><span class="line">AActor* TargetActor = <span class="built_in">Cast</span>&lt;AActor&gt;(OwnerComp.<span class="built_in">GetBlackboardComponent</span>()-&gt;<span class="built_in">GetValueAsObject</span>(<span class="string">&quot;TargetActor&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (TargetActor == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> EBTNodeResult::Failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 通过`MyPawn-&gt;GetMesh()-&gt;GetSocketLocation(&quot;Muzzle_01&quot;)`获取角色模型上名为`&quot;Muzzle_01&quot;`的插槽位置，即枪口位置。</span><br><span class="line">- 从黑板组件（`BlackboardComponent`）中获取名为`&quot;TargetActor&quot;`的对象，并尝试将其转换为`AActor`类型，得到目标角色。如果目标角色不存在，返回任务失败。</span><br></pre></td></tr></table></figure><ol start="3"><li>​<strong>​计算发射方向和旋转​</strong>​</li></ol><p>cpp</p><p>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FVector Direction = TargetActor-&gt;<span class="built_in">GetActorLocation</span>() - MuzzleLocation;</span><br><span class="line">FRotator MuzzleRotation = Direction.<span class="built_in">Rotation</span>();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 计算从枪口位置到目标角色位置的方向向量`Direction`。</span><br><span class="line">- 根据该方向向量获取对应的旋转`MuzzleRotation`。</span><br></pre></td></tr></table></figure><ol start="4"><li>​<strong>​生成投射物​</strong>​</li></ol><p>cpp</p><p>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FActorSpawnParameters Params;</span><br><span class="line">Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">AActor* NewProj = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, Params);</span><br><span class="line"><span class="keyword">return</span> NewProj? EBTNodeResult::Succeeded : EBTNodeResult::Failed;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 创建一个`FActorSpawnParameters`对象`Params`，并设置其碰撞处理方式为总是生成（`ESpawnActorCollisionHandlingMethod::AlwaysSpawn`）。</span><br><span class="line">- 使用`GetWorld()-&gt;SpawnActor&lt;AActor&gt;`在世界中生成一个指定类（`ProjectileClass`）的投射物，位置为枪口位置，旋转为计算得到的枪口旋转，同时传入生成参数`Params`。如果生成成功，返回任务成功；否则返回任务失败。</span><br></pre></td></tr></table></figure><ol start="5"><li>​<strong>​默认返回失败​</strong>​</li></ol><p>cpp</p><p>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> EBTNodeResult::Failed;</span><br></pre></td></tr></table></figure><p>如果在上述过程中没有提前返回成功或失败，最后返回任务失败。</p><h1 id="C-与UMG案例"><a href="#C-与UMG案例" class="headerlink" title="C++与UMG案例"></a>C++与UMG案例</h1><p>在Unreal Engine中使用C++创建一个简单的3D UI伤害数字，通常涉及以下几个步骤：</p><ol><li>​<strong>​创建UI组件​</strong>​：<ul><li>使用UMG（Unreal Motion Graphics）创建一个UI小部件，用于显示伤害数字。UMG允许你设计UI元素并在游戏中使用它们。</li></ul></li><li>​<strong>​绑定UI事件​</strong>​：<ul><li>在C++中，你需要创建一个UI控件类，并将其与UMG小部件绑定。这通常涉及到创建一个继承自<code>UUserWidget</code>的C++类。</li></ul></li><li>​<strong>​处理伤害事件​</strong>​：<ul><li>在游戏逻辑中，当角色受到伤害时，触发一个事件来显示伤害数字。</li></ul></li><li>​<strong>​动画和显示​</strong>​：<ul><li>实现伤害数字的动画效果，例如从屏幕外飞入并逐渐消失。</li></ul></li></ol><p>下面是一个简化的示例，展示如何在C++中创建一个基本的伤害数字UI：</p><h3 id="步骤1：创建UMG小部件"><a href="#步骤1：创建UMG小部件" class="headerlink" title="步骤1：创建UMG小部件"></a>步骤1：创建UMG小部件</h3><ol><li>打开Unreal Editor，创建一个新的UMG小部件。</li><li>添加一个<code>TextBlock</code>控件，并设置其属性，如字体大小、颜色和位置。</li><li>将UMG小部件保存为一个蓝图类（例如<code>UDamageNumberWidget</code>）。</li></ol><h3 id="步骤2：创建C-UI控件类"><a href="#步骤2：创建C-UI控件类" class="headerlink" title="步骤2：创建C++ UI控件类"></a>步骤2：创建C++ UI控件类</h3><p>在你的C++项目中，创建一个新的C++类，继承自<code>UUserWidget</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/UMG.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/Slate/SObjectWidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/IUMGModule.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/UMG/Public/UMGStyle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/Core/Public/Misc/Paths.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/Core/Public/Misc/FileHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/Core/Public/GenericPlatform/GenericPlatformFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJECT_API</span> UDamageNumberWidget : <span class="keyword">public</span> UUserWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(meta = (BindWidget))</span><br><span class="line">    UTextBlock* DamageText;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Damage UI&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDamageText</span><span class="params">(<span class="type">const</span> FString&amp; Text)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="步骤3：实现C-UI控件类"><a href="#步骤3：实现C-UI控件类" class="headerlink" title="步骤3：实现C++ UI控件类"></a>步骤3：实现C++ UI控件类</h3><p>在<code>.cpp</code>文件中实现<code>SetDamageText</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DamageNumberWidget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDamageNumberWidget::SetDamageText</span><span class="params">(<span class="type">const</span> FString&amp; Text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DamageText)</span><br><span class="line">    &#123;</span><br><span class="line">        DamageText-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(Text));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤4：在游戏中使用UI控件"><a href="#步骤4：在游戏中使用UI控件" class="headerlink" title="步骤4：在游戏中使用UI控件"></a>步骤4：在游戏中使用UI控件</h3><p>在你的游戏逻辑中，创建并显示UI控件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DamageNumberWidget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AYourCharacter::TakeDamage</span><span class="params">(<span class="type">float</span> DamageAmount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建UI控件实例</span></span><br><span class="line">    UDamageNumberWidget* DamageWidget = <span class="built_in">CreateWidget</span>&lt;UDamageNumberWidget&gt;(<span class="built_in">GetWorld</span>(), UDamageNumberWidget::<span class="built_in">StaticClass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DamageWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置伤害文本</span></span><br><span class="line">        DamageWidget-&gt;<span class="built_in">SetDamageText</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%d&quot;</span>), FMath::<span class="built_in">RoundToInt</span>(DamageAmount)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将UI控件添加到视口</span></span><br><span class="line">        <span class="keyword">if</span> (GEngine &amp;&amp; GEngine-&gt;GameViewport)</span><br><span class="line">        &#123;</span><br><span class="line">            DamageWidget-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以添加动画效果，例如淡出或移动</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚幻5自定义控制台函数"><a href="#虚幻5自定义控制台函数" class="headerlink" title="虚幻5自定义控制台函数"></a>虚幻5自定义控制台函数</h1><p>在Unreal Engine（UE）中，你可以通过使用控制台命令（Console Commands）将函数暴露给控制台，从而便于在游戏运行时调用这些函数。这在调试、测试或实现作弊功能时非常有用。以下是详细的步骤和示例，帮助你实现这一目标：</p><h2 id="步骤一：创建一个控制台命令"><a href="#步骤一：创建一个控制台命令" class="headerlink" title="步骤一：创建一个控制台命令"></a>步骤一：创建一个控制台命令</h2><h3 id="1-在C-中创建控制台命令"><a href="#1-在C-中创建控制台命令" class="headerlink" title="1. 在C++中创建控制台命令"></a>1. 在C++中创建控制台命令</h3><p>如果你使用的是C++，可以通过以下步骤创建一个控制台命令：</p><h4 id="a-在头文件中声明函数和命令"><a href="#a-在头文件中声明函数和命令" class="headerlink" title="a. 在头文件中声明函数和命令"></a>a. 在头文件中声明函数和命令</h4><p>假设你有一个类 <code>MyGameInstance</code>，你希望在其中添加一个控制台命令来调用某个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/GameInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameInstance.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJECT_API</span> UMyGameInstance : <span class="keyword">public</span> UGameInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">UMyGameInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 初始化时注册控制台命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 控制台命令调用的函数</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Exec)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheatFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="b-在源文件中实现函数"><a href="#b-在源文件中实现函数" class="headerlink" title="b. 在源文件中实现函数"></a>b. 在源文件中实现函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">UMyGameInstance::<span class="built_in">UMyGameInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置此GameInstance在游戏开始时自动创建</span></span><br><span class="line">    bAutoInitialize = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以添加初始化代码</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;MyGameInstance Initialized&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::CheatFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在这里编写你希望执行的作弊逻辑</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Cheat Function Called&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：给玩家增加生命值（假设玩家有一个SetHealth的方法）</span></span><br><span class="line">    APlayerController* PlayerController = <span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line">    <span class="keyword">if</span> (PlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        ACharacter* Character = PlayerController-&gt;<span class="built_in">GetCharacter</span>();</span><br><span class="line">        <span class="keyword">if</span> (Character)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 假设Character有一个SetHealth方法</span></span><br><span class="line">            <span class="comment">// Character-&gt;SetHealth(Character-&gt;GetHealth() + 100);</span></span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Player Health Increased by 100&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>​说明：​</strong>​</p><ul><li><code>UFUNCTION(Exec)</code> 宏用于将函数暴露给控制台，使其可以通过控制台命令调用。</li><li>确保你的 <code>GameInstance</code> 类在项目设置中被正确设置为默认的 <code>GameInstance</code> 类。</li></ul><h2 id="步骤二：确保控制台命令可用"><a href="#步骤二：确保控制台命令可用" class="headerlink" title="步骤二：确保控制台命令可用"></a>步骤二：确保控制台命令可用</h2><ol><li>​<strong>​启用控制台：​</strong>​<ul><li>默认情况下，UE的控制台可以通过按下 <code>~</code> 键（位于 <code>Tab</code> 键上方）打开。如果无法打开，可以在项目设置中检查输入设置，确保没有禁用控制台。</li></ul></li><li>​<strong>​注册控制台命令：​</strong>​<ul><li>使用 <code>UFUNCTION(Exec)</code> 宏声明的函数会自动注册为控制台命令。确保你的类（如 <code>GameInstance</code>）在游戏启动时被正确初始化。</li></ul></li></ol><h2 id="步骤三：测试控制台命令"><a href="#步骤三：测试控制台命令" class="headerlink" title="步骤三：测试控制台命令"></a>步骤三：测试控制台命令</h2><ol><li>​<strong>​运行游戏：​</strong>​<ul><li>启动你的游戏，确保 <code>GameInstance</code> 已正确初始化。</li></ul></li><li>​<strong>​打开控制台：​</strong>​<ul><li>按下 <code>~</code> 键打开控制台。</li></ul></li><li>​<strong>​输入命令：​</strong>​<ul><li>输入 <code>CheatFunction</code>（假设你的函数名为 <code>CheatFunction</code>），然后按下 <code>Enter</code> 键。</li></ul></li><li>​<strong>​查看结果：​</strong>​<ul><li>如果一切设置正确，你应该在输出日志中看到 <code>Cheat Function Called</code> 的日志信息，并且作弊逻辑（如增加生命值）应被执行。</li></ul></li></ol><h2 id="示例：完整实现增加玩家生命值的作弊功能"><a href="#示例：完整实现增加玩家生命值的作弊功能" class="headerlink" title="示例：完整实现增加玩家生命值的作弊功能"></a>示例：完整实现增加玩家生命值的作弊功能</h2><p>假设你有一个玩家角色类 <code>MyCharacter</code>，其中包含一个 <code>SetHealth</code> 方法：</p><h3 id="1-在-MyCharacter-h-中定义方法"><a href="#1-在-MyCharacter-h-中定义方法" class="headerlink" title="1. 在 MyCharacter.h 中定义方法"></a>1. 在 <code>MyCharacter.h</code> 中定义方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJECT_API</span> AMyCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Health&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetHealth</span><span class="params">(<span class="type">float</span> NewHealth)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Health&quot;</span>)</span><br><span class="line">    <span class="type">float</span> CurrentHealth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-在-MyCharacter-cpp-中实现方法"><a href="#2-在-MyCharacter-cpp-中实现方法" class="headerlink" title="2. 在 MyCharacter.cpp 中实现方法"></a>2. 在 <code>MyCharacter.cpp</code> 中实现方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyCharacter::<span class="built_in">AMyCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    CurrentHealth = <span class="number">100.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyCharacter::SetHealth</span><span class="params">(<span class="type">float</span> NewHealth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CurrentHealth = FMath::<span class="built_in">Clamp</span>(NewHealth, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Health set to %f&quot;</span>), CurrentHealth);</span><br><span class="line">    <span class="comment">// 这里可以添加更新UI或其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-修改-MyGameInstance-CheatFunction-来调用-SetHealth"><a href="#3-修改-MyGameInstance-CheatFunction-来调用-SetHealth" class="headerlink" title="3. 修改 MyGameInstance::CheatFunction 来调用 SetHealth"></a>3. 修改 <code>MyGameInstance::CheatFunction</code> 来调用 <code>SetHealth</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyGameInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Engine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::CheatFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Cheat Function Called&quot;</span>));</span><br><span class="line"></span><br><span class="line">    APlayerController* PlayerController = <span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line">    <span class="keyword">if</span> (PlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        ACharacter* Character = PlayerController-&gt;<span class="built_in">GetCharacter</span>();</span><br><span class="line">        <span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsA</span>&lt;AMyCharacter&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            AMyCharacter* MyCharacter = <span class="built_in">Cast</span>&lt;AMyCharacter&gt;(Character);</span><br><span class="line">            <span class="keyword">if</span> (MyCharacter)</span><br><span class="line">            &#123;</span><br><span class="line">                MyCharacter-&gt;<span class="built_in">SetHealth</span>(<span class="number">200.0f</span>); <span class="comment">// 设置生命值为200</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>​注意：​</strong>​</p><ul><li>确保你的玩家角色类是 <code>AMyCharacter</code> 或者根据实际情况调整类型转换。</li><li>你可以根据需要扩展作弊功能，如添加更多控制台命令，调用不同的函数等。</li></ul><h3 id="额外提示"><a href="#额外提示" class="headerlink" title="额外提示"></a>额外提示</h3><ul><li><p>​<strong>​安全性考虑：​</strong>​ 控制台命令可以用于调试和开发，但在发布版本中应谨慎使用，避免被恶意利用。你可以通过编译条件（如 <code>UE_BUILD_SHIPPING</code>）来移除或禁用作弊相关的控制台命令。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !UE_BUILD_SHIPPING</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Exec)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheatFunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>​<strong>​命令参数：​</strong>​ 你可以为控制台命令添加参数，以增加灵活性。例如，允许玩家输入要增加的生命值数量。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(Exec)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheatAddHealth</span><span class="params">(<span class="type">float</span> Amount)</span></span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyGameInstance.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyGameInstance::CheatAddHealth</span><span class="params">(<span class="type">float</span> Amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Cheat Add Health Called with Amount: %f&quot;</span>), Amount);</span><br><span class="line"></span><br><span class="line">    APlayerController* PlayerController = <span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line">    <span class="keyword">if</span> (PlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        ACharacter* Character = PlayerController-&gt;<span class="built_in">GetCharacter</span>();</span><br><span class="line">        <span class="keyword">if</span> (Character &amp;&amp; Character-&gt;<span class="built_in">IsA</span>&lt;AMyCharacter&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            AMyCharacter* MyCharacter = <span class="built_in">Cast</span>&lt;AMyCharacter&gt;(Character);</span><br><span class="line">            <span class="keyword">if</span> (MyCharacter)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> NewHealth = MyCharacter-&gt;<span class="built_in">GetCurrentHealth</span>() + Amount;</span><br><span class="line">                MyCharacter-&gt;<span class="built_in">SetHealth</span>(NewHealth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样，你可以在控制台中输入 <code>CheatAddHealth 50</code> 来增加50点生命值。</p></li><li><p>​<strong>​文档与调试：​</strong>​ 为你的控制台命令编写文档，确保团队成员了解可用的作弊命令及其用途。同时，利用UE的日志系统记录命令调用，便于调试和监控。</p></li></ul><h2 id="继承gamemode并管理角色死亡等事件"><a href="#继承gamemode并管理角色死亡等事件" class="headerlink" title="继承gamemode并管理角色死亡等事件"></a>继承gamemode并管理角色死亡等事件</h2><p>![[Pasted image 20250411174105.png]]<br>这段C++ 代码是基于虚幻引擎（Unreal Engine）的，主要实现了游戏中玩家死亡后的重生逻辑以及记录玩家被击杀的相关日志信息。</p><h3 id="具体函数功能分析"><a href="#具体函数功能分析" class="headerlink" title="具体函数功能分析"></a>具体函数功能分析</h3><ol><li>​<strong>​<code>ASGameModeBase::RespawnPlayerElapsed</code> 函数​</strong>​<ul><li>​<strong>​功能​</strong>​：负责在合适的时机让玩家角色重新生成。</li><li>​<strong>​代码细节​</strong>​：<ul><li>首先使用 <code>ensure(controller)</code> 来确保传入的 <code>controller</code>（玩家控制器指针）是有效的。如果有效，调用 <code>Controller-&gt;UnPossess()</code> 方法，这会解除玩家控制器与当前所控制的角色之间的关联。</li><li>然后调用 <code>RestartPlayer(controller)</code> 方法，该方法会重新生成玩家角色，让玩家可以重新回到游戏中。</li></ul></li></ul></li><li>​<strong>​<code>ASGameModeBase::OnActorKilled</code> 函数​</strong>​<ul><li>​<strong>​功能​</strong>​：当一个 <code>Actor</code>（这里主要关注玩家角色被击杀的情况）被击杀时被调用，处理玩家被击杀后的重生延迟以及记录击杀日志等操作。</li><li>​<strong>​代码细节​</strong>​：<ul><li>首先将 <code>VictimActor</code> 尝试转换为 <code>ASCharacter</code> 类型的指针 <code>player</code>，因为只有玩家角色才需要进行后续的重生等处理。如果转换成功（即 <code>player</code> 不为空）：<ul><li>声明一个 <code>FTimerHandle</code> 类型的变量 <code>TimerHandle_RespawnDelay</code>，用于管理重生延迟定时器。</li><li>声明一个 <code>FTimerDelegate</code> 类型的变量 <code>Delegate</code>，并通过 <code>BindUFunction</code> 将当前对象的 <code>RespawnPlayerElapsed</code> 函数绑定到该委托上，同时传入被击杀玩家的控制器指针作为参数。这样在定时器触发时就会调用 <code>RespawnPlayerElapsed</code> 函数来重生玩家。</li><li>定义一个 <code>float</code> 类型的变量 <code>RespawnDelay</code> 并赋值为 <code>2.0f</code>，表示重生延迟时间为2秒。</li><li>最后通过 <code>GetWorldTimerManager().SetTimer</code> 方法设置一个定时器，当指定的延迟时间（<code>RespawnDelay</code>）到达时，会触发绑定的委托函数 <code>Delegate</code>，并且设置 <code>false</code> 表示该定时器只触发一次。</li></ul></li><li>使用 <code>UE_LOG</code> 宏记录玩家被击杀的日志信息，包括被击杀玩家的名字和击杀者的名字。</li></ul></li></ul></li></ol><h3 id="可能的改进或扩展方向"><a href="#可能的改进或扩展方向" class="headerlink" title="可能的改进或扩展方向"></a>可能的改进或扩展方向</h3><ul><li>​<strong>​可配置的重生时间​</strong>​：目前重生延迟时间 <code>RespawnDelay</code> 是硬编码为 <code>2.0f</code>，可以考虑从配置文件或游戏设置中读取该值，以便在不同场景或游戏模式下灵活调整。</li><li>​<strong>​更多的击杀日志信息​</strong>​：除了记录玩家名字，还可以记录击杀发生的地点、使用的武器等信息，以提供更详细的击杀分析数据。</li><li>​<strong>​错误处理优化​</strong>​：对于 <code>Cast</code> 操作，目前只是简单判断是否成功，可以考虑在转换失败时进行更详细的错误记录或处理，比如记录一个警告日志说明转换失败的原因。</li></ul><h1 id="继承蓝图函数库添加自定义静态函数"><a href="#继承蓝图函数库添加自定义静态函数" class="headerlink" title="继承蓝图函数库添加自定义静态函数"></a>继承蓝图函数库添加自定义静态函数</h1><p>![[Pasted image 20250411174833.png]]</p><ol><li><p>​<strong>​<code>ApplyDamage</code>函数​</strong>​：</p><ul><li>​<strong>​功能​</strong>​：对目标角色（<code>TargetActor</code>）应用伤害，伤害由伤害施加者（<code>DamageCauser</code>）造成，伤害量为<code>DamageAmount</code>。</li><li>​<strong>​实现逻辑​</strong>​：<ul><li>首先通过<code>USAttributeComponent::GetAttributes(TargetActor)</code>获取目标角色的属性组件（<code>AttributeComp</code>）。</li><li>如果成功获取到属性组件（即<code>AttributeComp</code>不为空），则调用属性组件的<code>ApplyHealthChange</code>方法，传入伤害施加者和伤害量，来应用健康值的变化，并返回该操作的结果（布尔值）。</li><li>如果没有获取到属性组件，则直接返回<code>false</code>，表示伤害应用失败。</li></ul></li></ul></li><li><p>​<strong>​<code>ApplyDirectionalDamage</code>函数​</strong>​：</p><ul><li>​<strong>​功能​</strong>​：对目标角色应用带有方向性的伤害，除了伤害施加者、目标角色和伤害量外，还考虑了碰撞结果（<code>HitResult</code>），用于在特定方向上施加冲力。</li><li>​<strong>​实现逻辑​</strong>​：<ul><li>首先调用<code>ApplyDamage</code>函数尝试对目标角色应用伤害。如果<code>ApplyDamage</code>返回<code>true</code>（即伤害应用成功）：<ul><li>从碰撞结果（<code>HitResult</code>）中获取对应的组件（<code>HitComp</code>）。</li><li>检查该组件是否正在模拟物理（通过<code>HitComp-&gt;IsSimulatingPhysics(HitResult.BoneName)</code>）。</li><li>如果组件正在模拟物理，则通过<code>HitComp-&gt;AddImpulseAtLocation</code>方法在碰撞点（<code>HitResult.ImpactPoint</code>）施加一个冲力，冲力的方向由碰撞法线（<code>HitResult.ImpactNormal</code>）和大小（<code>30000.0f</code>）决定，同时指定了受影响的骨骼名称（<code>HitResult.BoneName</code>）。</li></ul></li><li>最后返回<code>true</code>，表示带有方向性的伤害应用成功。如果<code>ApplyDamage</code>返回<code>false</code>，则整个函数也返回<code>false</code>。</li></ul></li></ul></li></ol><h3 id="可能的改进或扩展点"><a href="#可能的改进或扩展点" class="headerlink" title="可能的改进或扩展点"></a>可能的改进或扩展点</h3><ol><li>​<strong>​错误处理和日志记录​</strong>​：目前代码在获取属性组件失败或组件不模拟物理时只是简单地返回结果，可以考虑添加一些日志记录，方便调试时了解具体发生了什么情况。例如使用<code>UE_LOG</code>宏（如果是虚幻引擎项目）来记录相关信息。</li><li>​<strong>​伤害类型和效果扩展​</strong>​：目前只考虑了简单的健康值变化和方向性冲力，实际游戏中可能需要考虑更多伤害类型（如火焰伤害、毒素伤害等）以及不同的伤害效果（如减速、眩晕等），可以在<code>AttributeComp</code>的<code>ApplyHealthChange</code>方法中进一步扩展相关逻辑。</li><li>​<strong>​性能优化​</strong>​：如果频繁调用这些函数，可能需要考虑性能优化，比如减少不必要的组件获取操作等。</li></ol><p>在虚幻引擎（Unreal Engine）中继承<code>UBlueprintFunctionLibrary</code>有以下几个重要思想和实际用途：</p><h3 id="提供可在蓝图中使用的自定义函数"><a href="#提供可在蓝图中使用的自定义函数" class="headerlink" title="提供可在蓝图中使用的自定义函数"></a>提供可在蓝图中使用的自定义函数</h3><p><code>UBlueprintFunctionLibrary</code>是一个基类，用于创建可以在虚幻蓝图系统中调用的自定义函数集合。通过继承它，开发者能够将一些通用的、复杂的或者需要在蓝图层面复用的逻辑封装成函数。这样，关卡设计师、策划人员等非程序员也可以方便地在蓝图节点中使用这些函数，而无需编写实际的C++代码，极大地提高了开发效率和灵活性。例如，在一个RPG游戏中，可以创建一个继承自<code>UBlueprintFunctionLibrary</code>的类，里面包含计算角色经验值升级所需经验的函数，蓝图设计师在设置角色升级逻辑时就可以直接调用这个函数。</p><h3 id="代码组织和模块化"><a href="#代码组织和模块化" class="headerlink" title="代码组织和模块化"></a>代码组织和模块化</h3><p>将相关的功能函数集中放在一个继承自<code>UBlueprintFunctionLibrary</code>的类中，有助于对代码进行良好的组织和管理。不同的功能模块可以分别封装在不同的函数库类里，使得代码结构更加清晰，易于维护和扩展。比如，在一个开放世界游戏中，可能会有专门处理环境交互的函数库类，包含检测角色与场景物体碰撞、获取附近资源点等函数；还有处理角色战斗的函数库类，包含计算伤害、应用状态效果等函数。</p><h3 id="复用性和一致性"><a href="#复用性和一致性" class="headerlink" title="复用性和一致性"></a>复用性和一致性</h3><p>一旦在<code>UBlueprintFunctionLibrary</code>的派生类中实现了某个函数，就可以在整个项目的多个蓝图中重复使用。这保证了在不同地方调用相同功能时逻辑的一致性，避免了重复编写相同代码导致的潜在错误。例如，计算两点之间距离的函数，在游戏中的寻路系统、物体交互判定等多个场景都可能用到，通过封装在函数库类中，就可以确保在各个地方计算的结果都是准确一致的。</p><h3 id="与虚幻引擎生态集成"><a href="#与虚幻引擎生态集成" class="headerlink" title="与虚幻引擎生态集成"></a>与虚幻引擎生态集成</h3><p>虚幻引擎的蓝图系统是其重要的可视化编程工具，<code>UBlueprintFunctionLibrary</code>作为与蓝图系统紧密集成的基类，使得自定义函数能够无缝地融入到引擎的生态系统当中。开发者可以利用蓝图的可视化连线、变量传递等特性，方便地与这些自定义函数进行交互，充分发挥虚幻引擎强大的可视化开发优势。</p><p>总之，继承<code>UBlueprintFunctionLibrary</code>主要是为了在虚幻引擎项目中更好地组织、复用代码，并增强代码的可访问性和易用性，以适应不同角色在游戏开发过程中的需求。</p><h1 id="meta标识符"><a href="#meta标识符" class="headerlink" title="meta标识符"></a>meta标识符</h1><p>在虚幻引擎（Unreal Engine）中，<code>Meta</code> 是一个非常重要的概念，主要用于 <strong>属性（UPROPERTY）</strong>、<strong>函数（UFUNCTION）</strong> 和 <strong>类（UCLASS）</strong> 的元数据（Metadata）标记，以控制编辑器行为、序列化、蓝图交互等。以下是 <code>Meta</code> 的详细解析：</p><hr><h2 id="1-Meta-的作用"><a href="#1-Meta-的作用" class="headerlink" title="1. Meta 的作用"></a><strong>1. Meta 的作用</strong></h2><p><code>Meta</code> 用于提供额外的信息或指令，主要影响：</p><ul><li><p><strong>编辑器 UI 行为</strong>（如分类、显示名称、工具提示）</p></li><li><p><strong>序列化规则</strong>（如是否保存到磁盘）</p></li><li><p><strong>蓝图交互</strong>（如是否在蓝图中可见）</p></li><li><p><strong>运行时行为</strong>（如网络复制条件）</p></li></ul><hr><h2 id="2-常见使用场景"><a href="#2-常见使用场景" class="headerlink" title="2. 常见使用场景"></a><strong>2. 常见使用场景</strong></h2><h3 id="1-在-UPROPERTY-中使用-Meta"><a href="#1-在-UPROPERTY-中使用-Meta" class="headerlink" title="(1) 在 UPROPERTY 中使用 Meta"></a><strong>(1) 在 <code>UPROPERTY</code> 中使用 Meta</strong></h3><p>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category &#x3D; “Character”,<br>          meta &#x3D; (DisplayName &#x3D; “生命值”, ToolTip &#x3D; “角色的生命值，范围为0-100”))<br>float Health;</p><p><strong>常用 Meta 参数</strong>：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>DisplayName</code></td><td>在编辑器中的显示名称（覆盖变量名）</td></tr><tr><td><code>ToolTip</code></td><td>鼠标悬停时的提示文本</td></tr><tr><td><code>ClampMin</code>&#x2F;<code>ClampMax</code></td><td>限制输入范围（如 <code>ClampMin=&quot;0&quot;</code>）</td></tr><tr><td><code>UIMin</code>&#x2F;<code>UIMax</code></td><td>在 Slider 控件中的范围</td></tr><tr><td><code>EditCondition</code></td><td>动态控制属性是否可编辑（如 <code>EditCondition=&quot;bIsEditable&quot;</code>）</td></tr><tr><td><code>BlueprintPrivate</code></td><td>对蓝图隐藏该属性</td></tr></tbody></table><hr><h3 id="2-在-UFUNCTION-中使用-Meta"><a href="#2-在-UFUNCTION-中使用-Meta" class="headerlink" title="(2) 在 UFUNCTION 中使用 Meta"></a><strong>(2) 在 <code>UFUNCTION</code> 中使用 Meta</strong></h3><p>UFUNCTION(BlueprintCallable, Category &#x3D; “AI”,<br>          meta &#x3D; (DisplayName &#x3D; “计算伤害”, Keywords &#x3D; “Damage|Attack”))<br>void CalculateDamage(float BaseDamage);</p><p><strong>常用 Meta 参数</strong>：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>Keywords</code></td><td>在蓝图搜索时的关键字（用 &#96;</td></tr><tr><td><code>DefaultToSelf</code></td><td>自动传递 <code>self</code> 对象（如 <code>DefaultToSelf=&quot;Target&quot;</code>）</td></tr><tr><td><code>HidePin</code></td><td>隐藏蓝图中函数的某些引脚</td></tr><tr><td><code>AdvancedDisplay</code></td><td>将参数标记为“高级”（默认折叠）</td></tr></tbody></table><hr><h3 id="3-在-UCLASS-中使用-Meta"><a href="#3-在-UCLASS-中使用-Meta" class="headerlink" title="(3) 在 UCLASS 中使用 Meta"></a><strong>(3) 在 <code>UCLASS</code> 中使用 Meta</strong></h3><p>UCLASS(Blueprintable, meta &#x3D; (DisplayName &#x3D; “玩家角色”, ShortToolTip &#x3D; “可控制的玩家实体”))<br>class APlayerCharacter : public ACharacter;</p><p><strong>常用 Meta 参数</strong>：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>BlueprintType</code></td><td>允许该类在蓝图中作为变量类型</td></tr><tr><td><code>IsBlueprintBase</code></td><td>允许蓝图继承该类</td></tr><tr><td><code>ChildCanTick</code></td><td>子类是否可以重写 <code>Tick</code> 事件</td></tr></tbody></table><hr><h2 id="3-高级用法"><a href="#3-高级用法" class="headerlink" title="3. 高级用法"></a><strong>3. 高级用法</strong></h2><h3 id="1-动态编辑条件"><a href="#1-动态编辑条件" class="headerlink" title="(1) 动态编辑条件"></a><strong>(1) 动态编辑条件</strong></h3><p>通过 <code>meta = (EditCondition)</code> 实现属性联动的显隐&#x2F;禁用逻辑：</p><p>UPROPERTY(EditAnywhere)<br>bool bUseCustomSpeed;</p><p>UPROPERTY(EditAnywhere, meta &#x3D; (EditCondition &#x3D; “bUseCustomSpeed”))<br>float CustomSpeed; &#x2F;&#x2F; 仅当bUseCustomSpeed为true时可编辑</p><h3 id="2-网络同步控制"><a href="#2-网络同步控制" class="headerlink" title="(2) 网络同步控制"></a><strong>(2) 网络同步控制</strong></h3><p>UPROPERTY(Replicated, meta &#x3D; (ReplicateCondition &#x3D; “bIsAlive”))<br>float Health; &#x2F;&#x2F; 仅在bIsAlive为true时同步</p><h3 id="3-资产引用规则"><a href="#3-资产引用规则" class="headerlink" title="(3) 资产引用规则"></a><strong>(3) 资产引用规则</strong></h3><p>UPROPERTY(EditAnywhere, meta &#x3D; (AllowedClasses &#x3D; “Texture2D,Material”))<br>UObject* VisualAsset; &#x2F;&#x2F; 限制只能选择纹理或材质</p><hr><h2 id="4-实际案例"><a href="#4-实际案例" class="headerlink" title="4. 实际案例"></a><strong>4. 实际案例</strong></h2><h3 id="案例1：属性分类与工具提示"><a href="#案例1：属性分类与工具提示" class="headerlink" title="案例1：属性分类与工具提示"></a><strong>案例1：属性分类与工具提示</strong></h3><p>UPROPERTY(EditDefaultsOnly, Category &#x3D; “Weapon”,<br>          meta &#x3D; (DisplayName &#x3D; “伤害值”, ToolTip &#x3D; “武器的基础伤害值”))<br>float BaseDamage;</p><h3 id="案例2：动态滑块控制"><a href="#案例2：动态滑块控制" class="headerlink" title="案例2：动态滑块控制"></a><strong>案例2：动态滑块控制</strong></h3><p>UPROPERTY(EditAnywhere, meta &#x3D; (UIMin &#x3D; 0, UIMax &#x3D; 100, ClampMin &#x3D; 0, ClampMax &#x3D; 100))<br>int32 AccuracyPercent;</p><hr><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a><strong>5. 注意事项</strong></h2><ol><li><strong>区分 <code>Meta</code> 和 <code>Specifiers</code></strong><ul><li><code>BlueprintReadWrite</code> 是 <strong>说明符（Specifier）</strong>，直接控制基础行为。</li><li><code>DisplayName</code> 是 <strong>元数据（Meta）</strong>，提供附加信息。</li></ul></li><li><strong>编辑器刷新问题</strong><br> 修改 Meta 后可能需要重启编辑器或重新编译才能生效。</li><li><strong>C++ 与蓝图的差异</strong><br> 部分 Meta 参数（如 <code>BlueprintPrivate</code>）仅影响蓝图，不影响 C++ 代码。</li></ol><h1 id="FgameplayTag游戏标签"><a href="#FgameplayTag游戏标签" class="headerlink" title="FgameplayTag游戏标签"></a>FgameplayTag游戏标签</h1><p>在游戏开发（特别是使用虚幻引擎等引擎开发时），Play Tag（玩法标签）是一种用于标识和分类游戏玩法相关元素的机制。</p><ol><li>​<strong>​功能特性​</strong>​<ul><li>​<strong>​分类与组织​</strong>​<ul><li>FGamePlayTag可以用来对游戏中的各种玩法相关的内容进行分类，比如不同的角色能力类型（近战型、远程型等）、任务类型（主线任务、支线任务、日常任务等）、游戏模式（单人模式、多人合作模式、多人对战模式等）。通过这种分类方式，开发团队可以更高效地管理和组织游戏内容。</li></ul></li><li>​<strong>​筛选与查询​</strong>​<ul><li>在游戏的开发工具或编辑器中，开发者可以使用这些标签来筛选特定的游戏元素。例如，当想要查找所有与多人对战模式相关的游戏逻辑、资产（如地图、角色等）时，可以通过“多人对战模式”这个FGamePlayTag进行快速筛选。</li></ul></li><li>​<strong>​游戏逻辑关联​</strong>​<ul><li>在游戏的运行时逻辑中，FGamePlayTag也起到重要作用。比如，根据玩家当前的任务类型标签（如支线任务标签），游戏可以动态调整界面显示、NPC交互行为或者任务提示等相关逻辑。</li></ul></li></ul></li><li>​<strong>​实现方式（以虚幻引擎为例）​</strong>​<ul><li>在虚幻引擎中，FGamePlayTag是一种轻量级的数据结构。开发人员可以在项目的代码和蓝图中定义和使用这些标签。</li><li>可以通过C++代码创建自定义的FGamePlayTag，并将其应用到相应的游戏对象、组件或者函数中。在蓝图中，也有直观的节点来处理FGamePlayTag，例如检查某个对象是否具有特定的FGamePlayTag，或者根据FGamePlayTag执行不同的分支逻辑等。![[Pasted image 20250413161403.png]]</li><li><code>FGameplayTag</code> 是一种用于标识和分类游戏内容的强大工具。具体到你提供的代码片段中的 <code>FindNativeInputActionByTag</code> 函数，<code>FGameplayTag</code> 的作用主要体现在以下几个方面：</li></ul></li></ol><h3 id="1-​​输入动作的分类与标识​​"><a href="#1-​​输入动作的分类与标识​​" class="headerlink" title="1. ​​输入动作的分类与标识​​"></a>1. ​<strong>​输入动作的分类与标识​</strong>​</h3><p><code>FGameplayTag</code> 在这里用于对不同的输入动作进行分类和标识。通过为每个输入动作分配一个或多个标签，开发者可以方便地管理和引用这些动作。例如：</p><ul><li>​<strong>​动作类型​</strong>​：如“攻击”、“防御”、“跳跃”、“移动”等。</li><li>​<strong>​上下文​</strong>​：如“近战”、“远程”、“特殊”等。</li><li>​<strong>​状态​</strong>​：如“按下”、“释放”、“长按”等。</li></ul><h3 id="2-​​简化输入系统的管理​​"><a href="#2-​​简化输入系统的管理​​" class="headerlink" title="2. ​​简化输入系统的管理​​"></a>2. ​<strong>​简化输入系统的管理​</strong>​</h3><p>使用 <code>FGameplayTag</code> 可以简化输入系统的管理，特别是在处理复杂的输入逻辑时。例如，你可以通过标签来动态绑定和解绑输入动作，而无需硬编码每个输入的具体关联。这在需要频繁更改或扩展输入系统时尤为有用。</p><h3 id="3-​​提高代码的可读性和可维护性​​"><a href="#3-​​提高代码的可读性和可维护性​​" class="headerlink" title="3. ​​提高代码的可读性和可维护性​​"></a>3. ​<strong>​提高代码的可读性和可维护性​</strong>​</h3><p>通过使用标签而不是直接引用具体的输入动作，代码变得更加抽象和通用。这不仅提高了代码性，还使得在修改或扩展输入动作时更加方便。例如，添加一个新的输入动作只需要为其分配一个合适的标签，而不需要修改大量的查找逻辑。</p><h3 id="4-​​支持运行时的动态配置​​"><a href="#4-​​支持运行时的动态配置​​" class="headerlink" title="4. ​​支持运行时的动态配置​​"></a>4. ​<strong>​支持运行时的动态配置​</strong>​</h3><p><code>FGameplayTag</code> 允许在运行时动态地查询和管理输入动作。这意味着你可以根据游戏的状态或玩家的设置，动态地决定哪些输入动作是可用的。例如，某些技能可能只在特定条件下可用，通过标签可以轻松实现这种条件判断。</p><h3 id="5-​​与其他系统的集成​​"><a href="#5-​​与其他系统的集成​​" class="headerlink" title="5. ​​与其他系统的集成​​"></a>5. ​<strong>​与其他系统的集成​</strong>​</h3><p><code>FGameplayTag</code> 不仅限于输入系统，它还可以与其他虚幻引擎的系统（如 Gameplay Ability System, GAS）无缝集成。例如，你可以使用相同的标签来控制角色的能力激活、动画播放等，从而实现跨系统的一致性和协同工作。</p><h3 id="具体到你的代码"><a href="#具体到你的代码" class="headerlink" title="具体到你的代码"></a>具体到你的代码</h3><p>游戏标签关键宏：</p><ul><li><p><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN(TagName)</code>：在头文件声明一个外部标签变量。</p></li><li><p><code>UE_DEFINE_GAMEPLAY_TAG_EXTERN(TagName, TagString)</code>：在CPP文件定义并初始化这个变量。</p></li><li><p><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN(TagName)</code>展开后类似：</p></li><li><p>extern FGameplayTag TAG_Weapon_Rifle;</p></li><li><p><code>UE_DEFINE_GAMEPLAY_TAG_EXTERN(TagName, TagString)</code>展开后类似</p></li><li><p>FGameplayTag TAG_Weapon_Rifle &#x3D;FGameplayTag::RequestGameplayTag(FName(“Weapon.Rifle”));</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UInputAction* <span class="title">UDataAsset_input::FindNativeInputActionByTag</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; inTags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历这个数组，如果标签等于动作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> FWarriorInput&amp; InputActionConfig : NativeInput) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InputActionConfig.Tags == inTags &amp;&amp; InputActionConfig.Input_Action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> InputActionConfig.Input_Action;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>​<strong>​功能​</strong>​：该函数通过传入的 <code>FGameplayTag</code> (<code>inTags</code>) 来查找对应的 <code>UInputAction</code> 对象。</p></li><li><p>​<strong>​用途​</strong>​：<br>  查找特定动作​**​：根据标签快速找到需要的输入动作，例如“跳跃”或“攻击”。</p></li><li><p>​<strong>​动态绑定​</strong>​：在运行时根据不同的标签动态绑定输入动作，增强游戏的灵活性。</p></li><li><p>​<strong>​条件控制​</strong>​：结合游戏状态，通过标签控制哪些输入动作可用。</p></li></ul><h2 id="输入配置映射集合-DataAsset"><a href="#输入配置映射集合-DataAsset" class="headerlink" title="输入配置映射集合-DataAsset"></a>输入配置映射集合-DataAsset</h2><p>用与将输入标签映射到唯一的输入操作</p><h1 id="GENERATED-BODY-宏"><a href="#GENERATED-BODY-宏" class="headerlink" title="GENERATED_BODY()宏"></a>GENERATED_BODY()宏</h1><p><code>GENERATED_BODY()</code> 宏是一个非常重要的部分，它通常出现在由 Unreal Engine 的 Unreal Header Tool (UHT) 自动生成代码的类中。这个宏用于处理 Unreal Engine 的反射系统，它使得类能够在编辑器中被识别和使用，同时也支持序列化、网络复制等功能。<br>&#x3D;&#x3D;tips:看见类与结构体就放在里面！&#x3D;&#x3D;</p><h2 id="USTRUCT"><a href="#USTRUCT" class="headerlink" title="USTRUCT"></a>USTRUCT</h2><p><code>USTRUCT(BlueprintType)</code> 是一个用于声明结构的宏，它告诉 Unreal Engine 这个结构可以在蓝图中被使用</p><h1 id="TArray"><a href="#TArray" class="headerlink" title="TArray"></a>TArray</h1><p><code>TArray</code> 是 Unreal Engine 4 和 Unreal Engine 5 中用于存储动态数组的类模板。它提供了一系列的方法和属性来管理数组中的元素，包括添加、删除、插入、查找等操作。<code>TArray</code> 可以存储任何类型的数据，包括基本数据类型、结构体、类实例等。</p><hr><h1 id="​​TSubclassOf-​​"><a href="#​​TSubclassOf-​​" class="headerlink" title="​​TSubclassOf ​​"></a>​<strong>​<code>TSubclassOf</code> ​</strong>​</h1><p><code>TSubclassOf</code> 是 Unreal Engine 提供的一个模板类，用于安全地存储和引用特定类型的类（必须是 <code>UObject</code> 的子类）。它的核心功能包括：</p><ul><li>​<strong>​类型安全​</strong>​：确保只能赋值为指定父类的子类（例如 <code>TSubclassOf&lt;AActor&gt;</code> 只能接受 <code>AActor</code> 或其子类）。</li><li>​<strong>​编辑器集成​</strong>​：在 UE 编辑器中提供友好的下拉菜单，方便选择类。</li><li>​<strong>​蓝图兼容​</strong>​：允许在蓝图中动态选择和引用类。</li></ul><h1 id="虚幻接口"><a href="#虚幻接口" class="headerlink" title="虚幻接口"></a>虚幻接口</h1><p>作为父类被指定被继承对象，即可调用其中的功能。实现功能复用（接口用于定义一组方法，但不实现它们。任何类都可以实现该接口并覆盖这些方法——虚基类）</p><h2 id="使用流程​​"><a href="#使用流程​​" class="headerlink" title="使用流程​​"></a><strong>使用流程​</strong>​</h2><ol><li>​<strong>​定义接口​</strong>​（C++ 或蓝图）。</li><li>​<strong>​实现接口​</strong>​（在 Actor 类中继承并覆盖方法）。</li><li>​<strong>​调用接口​</strong>​（通过 <code>Cast&lt;IInterface&gt;</code> 检查并调用方法）。<br>代码示例：</li></ol><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enemy.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HealthInterface.h&quot;</span> <span class="comment">// 包含接口头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Enemy.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAME_API</span> AEnemy : <span class="keyword">public</span> AActor, <span class="keyword">public</span> IHealthInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AEnemy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetHealth_Implementation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Health&quot;</span>)</span><br><span class="line">    <span class="type">float</span> Health = <span class="number">100.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enemy.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Enemy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AEnemy::<span class="built_in">AEnemy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">AEnemy::GetHealth_Implementation</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Health;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PlayerCharacter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HealthInterface.h&quot;</span> <span class="comment">// 包含接口头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PlayerCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAME_API</span> APlayerCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">APlayerCharacter</span>();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttackEnemy</span><span class="params">(AActor* Enemy)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PlayerCharacter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PlayerCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerCharacter::AttackEnemy</span><span class="params">(AActor* Enemy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Enemy) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 Enemy 是否实现了 IHealthInterface</span></span><br><span class="line">    <span class="keyword">if</span> (IHealthInterface* HealthInterface = <span class="built_in">Cast</span>&lt;IHealthInterface&gt;(Enemy))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> Health = HealthInterface-&gt;<span class="built_in">GetHealth</span>(); <span class="comment">// 调用接口方法</span></span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Enemy Health: %f&quot;</span>), Health);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果血量 &lt;= 0，消灭敌人</span></span><br><span class="line">        <span class="keyword">if</span> (Health &lt;= <span class="number">0.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Enemy-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Enemy does not implement IHealthInterface!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="​​TSubclassOf-与蓝图的关系​​"><a href="#​​TSubclassOf-与蓝图的关系​​" class="headerlink" title="​​TSubclassOf 与蓝图的关系​​"></a>​<strong>​<code>TSubclassOf</code> 与蓝图的关系​</strong>​</h2><h3 id="​​-1-在-C-中使用-TSubclassOf​​"><a href="#​​-1-在-C-中使用-TSubclassOf​​" class="headerlink" title="​​(1) 在 C++ 中使用 TSubclassOf​​"></a>​<strong>​(1) 在 C++ 中使用 <code>TSubclassOf</code>​</strong>​</h3><ul><li>​<strong>​声明方式​</strong>​：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line">TSubclassOf&lt;UGameplayAbility&gt; AbilityClass;</span><br></pre></td></tr></table></figure></li><li>​<strong>​用途​</strong>​：<ul><li>在 C++ 中定义一个变量，用于存储某个类的引用（如技能、武器、道具的类）。</li><li>在编辑器中，该变量会显示为一个下拉菜单，列出所有符合条件的类（如 <code>UGameplayAbility</code> 的子类）。</li></ul></li></ul><h3 id="​​-2-在蓝图中使用-TSubclassOf​​"><a href="#​​-2-在蓝图中使用-TSubclassOf​​" class="headerlink" title="​​(2) 在蓝图中使用 TSubclassOf​​"></a>​<strong>​(2) 在蓝图中使用 <code>TSubclassOf</code>​</strong>​</h3><ul><li>​<strong>​蓝图兼容性​</strong>​：<ul><li>如果 C++ 中声明了 <code>UPROPERTY(EditAnywhere)</code> 的 <code>TSubclassOf</code> 变量，蓝图可以直接访问并修改它。</li><li>在蓝图中，该变量会显示为一个 ​<strong>​类选择器​</strong>​（Class Picker），允许从符合条件的类中选择。</li></ul></li><li>​<strong>​动态赋值​</strong>​：<ul><li>蓝图可以通过 ​<strong>​“Make” 节点​</strong>​ 或 ​<strong>​“Set” 节点​</strong>​ 动态修改 <code>TSubclassOf</code> 变量的值。</li><li>例如：在蓝图中选择一个技能类并赋值给 <code>AbilityClass</code>。</li></ul></li></ul><hr><h2 id="​​3-TSubclassOf-是否意味着“由蓝图添加数据”？​​"><a href="#​​3-TSubclassOf-是否意味着“由蓝图添加数据”？​​" class="headerlink" title="​​3. TSubclassOf 是否意味着“由蓝图添加数据”？​​"></a>​<strong>​3. <code>TSubclassOf</code> 是否意味着“由蓝图添加数据”？​</strong>​</h2><h3 id="​​-1-不一定​​"><a href="#​​-1-不一定​​" class="headerlink" title="​​(1) 不一定​​"></a>​<strong>​(1) 不一定​</strong>​</h3><ul><li>​<strong>​C++ 也可以直接赋值​</strong>​：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilityClass = UMyFireballAbility::<span class="built_in">StaticClass</span>(); <span class="comment">// 直接在 C++ 中硬编码</span></span><br></pre></td></tr></table></figure>  此时数据完全由 C++ 控制，与蓝图无关。</li><li>​<strong>​蓝图可以覆盖​</strong>​：<ul><li>如果变量标记为 <code>EditAnywhere</code> 或 <code>BlueprintReadWrite</code>，蓝图可以修改它的值。</li><li>但如果没有暴露给蓝图（如仅标记为 <code>VisibleAnywhere</code>），则蓝图无法修改。</li></ul></li></ul><h3 id="​​-2-蓝图的主要作用​​"><a href="#​​-2-蓝图的主要作用​​" class="headerlink" title="​​(2) 蓝图的主要作用​​"></a>​<strong>​(2) 蓝图的主要作用​</strong>​</h3><ul><li>​<strong>​动态选择类​</strong>​：<ul><li>蓝图可以通过类选择器动态选择类（如根据玩家选择切换技能）。</li></ul></li><li>​<strong>​扩展功能​</strong>​：<ul><li>蓝图可以基于 <code>TSubclassOf</code> 变量动态生成对象（如 <code>SpawnActorFromClass</code>）。</li></ul></li></ul><hr><h2 id="​​4-实际应用示例​​"><a href="#​​4-实际应用示例​​" class="headerlink" title="​​4. 实际应用示例​​"></a>​<strong>​4. 实际应用示例​</strong>​</h2><h3 id="​​-1-C-中定义技能类变量​​"><a href="#​​-1-C-中定义技能类变量​​" class="headerlink" title="​​(1) C++ 中定义技能类变量​​"></a>​<strong>​(1) C++ 中定义技能类变量​</strong>​</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMyCharacter</span> : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Abilities&quot;</span>)</span><br><span class="line">    TSubclassOf&lt;UGameplayAbility&gt; FireballAbilityClass; <span class="comment">// 可在蓝图中修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="​​5-关键特性总结​​"><a href="#​​5-关键特性总结​​" class="headerlink" title="​​5. 关键特性总结​​"></a>​<strong>​5. 关键特性总结​</strong>​</h2><table><thead><tr><th>特性</th><th><code>TSubclassOf</code> 的作用</th></tr></thead><tbody><tr><td>​<strong>​类型安全​</strong>​</td><td>确保只能赋值为指定父类的子类</td></tr><tr><td>​<strong>​编辑器下拉菜单​</strong>​</td><td>在 C++ 编辑器和蓝图中显示类选择器</td></tr><tr><td>​<strong>​动态赋值​</strong>​</td><td>允许在运行时修改引用的类</td></tr><tr><td>​<strong>​数据来源​</strong>​</td><td>可硬编码（C++）、蓝图或数据资产</td></tr></tbody></table><hr><h2 id="​​6-总结​​"><a href="#​​6-总结​​" class="headerlink" title="​​6. 总结​​"></a>​<strong>​6. 总结​</strong>​</h2><ul><li>​<strong>​<code>TSubclassOf</code> 的核心功能​</strong>​：安全地引用类，支持编辑器集成和蓝图交互。</li><li>​<strong>​是否依赖蓝图​</strong>​：<ul><li>​<strong>​否​</strong>​：C++ 可以完全控制类的赋值（硬编码或数据资产）。</li><li>​<strong>​是​</strong>​：如果希望动态选择类（如技能切换），蓝图可以通过类选择器实现。</li></ul></li><li>​<strong>​典型用途​</strong>​：技能系统、武器&#x2F;道具管理、动态生成对象等。</li></ul><p>如果需要完全由蓝图添加数据，通常需要结合 ​<strong>​数据资产（Data Asset）​</strong>​ 或 ​<strong>​蓝图变量​</strong>​ 使用，而 <code>TSubclassOf</code> 本身只是一个类型安全的类引用工具。</p><h1 id="数据资产"><a href="#数据资产" class="headerlink" title="数据资产"></a>数据资产</h1><p>-用于存储和管理游戏中的配置数据，如输入动作、角色属性等。通过数据资产，可以将配置与代码分离，便于非程序员进行编辑和管理。</p><h1 id="同步加载与异步加载"><a href="#同步加载与异步加载" class="headerlink" title="同步加载与异步加载"></a>同步加载与异步加载</h1><h2 id="一、同步加载（Synchronous-Loading）"><a href="#一、同步加载（Synchronous-Loading）" class="headerlink" title="一、同步加载（Synchronous Loading）"></a>一、同步加载（Synchronous Loading）</h2><h3 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h3><p>同步加载是指游戏主线程在执行加载操作时，会暂停并等待资源完全加载完毕后再继续执行后续代码。这意味着在资源加载期间，游戏可能会出现短暂的卡顿或“冻结”现象。</p><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><p>在虚幻引擎中，同步加载通常通过调用 <code>LoadObject</code> 或 <code>StaticLoadObject</code> 等函数实现。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步加载一个Actor类</span></span><br><span class="line">AActor* LoadedActor = <span class="built_in">Cast</span>&lt;AActor&gt;(<span class="built_in">StaticLoadObject</span>(AActor::<span class="built_in">StaticClass</span>(), <span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;/Game/Path/To/Actor.Actor&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步加载一个关卡</span></span><br><span class="line">UGameplayStatics::<span class="built_in">OpenLevel</span>(<span class="keyword">this</span>, <span class="built_in">FName</span>(<span class="string">&quot;LevelName&quot;</span>), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><p>​<strong>​优点：​</strong>​</p><ul><li>​<strong>​实现简单​</strong>​：代码逻辑直观，易于理解和实现。</li><li>​<strong>​确保资源可用​</strong>​：加载完成后，资源立即可用，无需担心异步加载的回调问题。<br>​<strong>​缺点：​</strong>​</li><li>​<strong>​性能影响​</strong>​：加载过程中主线程被阻塞，可能导致帧率下降和用户体验不佳。</li><li>​<strong>​卡顿现象​</strong>​：特别是在加载大型资源时，用户可能会明显感受到游戏的停顿。</li></ul><h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>​<strong>​开发阶段​</strong>​：在编辑器中进行快速迭代和测试时，同步加载可以简化流程。</li><li>​<strong>​小型项目​</strong>​：资源较少且加载时间短的项目，同步加载对用户体验影响较小。</li><li>​<strong>​特定需求​</strong>​：某些需要确保资源立即可用的特定场景，如加载菜单界面所需资源。</li></ul><hr><h2 id="二、异步加载（Asynchronous-Loading）"><a href="#二、异步加载（Asynchronous-Loading）" class="headerlink" title="二、异步加载（Asynchronous Loading）"></a>二、异步加载（Asynchronous Loading）</h2><h3 id="1-工作原理-1"><a href="#1-工作原理-1" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h3><p>异步加载允许游戏主线程在资源加载的同时继续执行其他任务，不会因为加载操作而阻塞。加载过程在后台进行，通过回调函数或事件通知主线程资源已加载完毕。</p><h3 id="2-使用方法-1"><a href="#2-使用方法-1" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><p>虚幻引擎提供了多种异步加载的方法，包括 <code>FStreamableManager</code>、<code>AsyncLoading</code> 命名空间下的函数以及蓝图中的异步节点。</p><p>​<strong>​使用 <code>FStreamableManager</code> 加载资产：​</strong>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个委托用于处理加载完成事件</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnAssetLoaded, UObject*, LoadedAsset);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYGAME_API</span> UMyAssetLoader : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">&quot;AssetLoader&quot;</span>)</span><br><span class="line">    FOnAssetLoaded OnAssetLoaded;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadAssetAsync</span><span class="params">(<span class="type">const</span> FString&amp; AssetPath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">FSoftObjectPath <span class="title">SoftPath</span><span class="params">(AssetPath)</span></span>;</span><br><span class="line">        FStreamableManager&amp; Streamable = UAssetManager::<span class="built_in">GetStreamableManager</span>();</span><br><span class="line">        Streamable.<span class="built_in">RequestAsyncLoad</span>(SoftPath, [<span class="keyword">this</span>, SoftPath]()</span><br><span class="line">        &#123;</span><br><span class="line">            UObject* LoadedAsset = SoftPath.<span class="built_in">TryLoad</span>();</span><br><span class="line">            OnAssetLoaded.<span class="built_in">Broadcast</span>(LoadedAsset);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>​使用 <code>UGameplayStatics::LoadStreamLevelAsync</code> 加载关卡异步：​</strong>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步加载一个子关卡</span></span><br><span class="line">UGameplayStatics::<span class="built_in">LoadStreamLevelAsync</span>(<span class="keyword">this</span>, <span class="built_in">FName</span>(<span class="string">&quot;SubLevelName&quot;</span>), <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">FLatentActionInfo</span>());</span><br></pre></td></tr></table></figure><p>​<strong>​蓝图中的异步加载节点：​</strong>​</p><p>虚幻引擎的蓝图系统也提供了异步加载的节点，如 <code>Async Load Assets</code>，方便非编程人员使用。</p><h3 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><p>​<strong>​优点：​</strong>​</p><ul><li>​<strong>​提升性能​</strong>​：避免主线程阻塞，保持游戏的流畅性和响应性。</li><li>​<strong>​优化用户体验​</strong>​：尤其在加载大型资源或关卡时，用户不会感受到明显的卡顿。</li><li>​<strong>​更好的资源管理​</strong>​：可以更灵活地控制加载顺序和优先级，优化内存使用。</li></ul><p>​<strong>​缺点：​</strong>​</p><ul><li>​<strong>​实现复杂​</strong>​：需要处理回调函数或事件，代码逻辑相对复杂。</li><li>​<strong>​资源可用性延迟​</strong>​：资源在加载完成前不可用，可能需要额外的处理来管理资源状态。</li></ul><h3 id="4-适用场景-1"><a href="#4-适用场景-1" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul><li>​<strong>​大型项目​</strong>​：资源丰富且加载时间较长的项目，异步加载能显著提升用户体验。</li><li>​<strong>​开放世界游戏​</strong>​：需要动态加载和卸载远距离区域的资源，减少初始加载时间。</li><li>​<strong>​多平台优化​</strong>​：在不同性能的设备上保持一致的性能表现，特别是在移动设备上尤为重要。</li></ul><hr><h2 id="三、同步加载与异步加载的对比"><a href="#三、同步加载与异步加载的对比" class="headerlink" title="三、同步加载与异步加载的对比"></a>三、同步加载与异步加载的对比</h2><table><thead><tr><th>特性</th><th>同步加载</th><th>异步加载</th></tr></thead><tbody><tr><td>​<strong>​主线程阻塞​</strong>​</td><td>是</td><td>否</td></tr><tr><td>​<strong>​性能影响​</strong>​</td><td>可能导致帧率下降和卡顿</td><td>更高的性能，保持流畅的游戏体验</td></tr><tr><td>​<strong>​实现复杂度​</strong>​</td><td>简单直观</td><td>较复杂，需要处理回调或事件</td></tr><tr><td>​<strong>​用户体验​</strong>​</td><td>可能有明显的加载停顿</td><td>加载过程平滑，用户体验更好</td></tr><tr><td>​<strong>​适用场景​</strong>​</td><td>小型项目、开发阶段、特定需求</td><td>大型项目、开放世界、多平台优化</td></tr></tbody></table><h1 id="资源导入相关问题"><a href="#资源导入相关问题" class="headerlink" title="资源导入相关问题"></a>资源导入相关问题</h1><p>1.所有外部资源必须导入至content文件夹内<br>2.你如果是自己从网上鼓捣下载下来的uesset文件，这种文件虽然可以直接导入至content，但是如果路径与原项目路径名不一致则会出现无法定向贴图材质骨骼等问题。<br>所以一定要确定你这个资源原来的路径。在你自己的项目中同样使用这个路径。</p><h1 id="常用代码—使用这些你就能实现游戏的绝大多数功能"><a href="#常用代码—使用这些你就能实现游戏的绝大多数功能" class="headerlink" title="常用代码—使用这些你就能实现游戏的绝大多数功能"></a>常用代码—使用这些你就能实现游戏的绝大多数功能</h1><h2 id="生成在指定坐标生成一个类（特效、声音等）"><a href="#生成在指定坐标生成一个类（特效、声音等）" class="headerlink" title="生成在指定坐标生成一个类（特效、声音等）"></a>生成在指定坐标生成一个类（特效、声音等）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASCharacter::PrimaryAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FTransform SpawnTM = <span class="built_in">FTransform</span>(<span class="built_in">GetControlRotation</span>(), <span class="built_in">GetActorLocation</span>());</span><br><span class="line">    FActorSpawnParams SpawnParams;</span><br><span class="line">    SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">    <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(ProjectileClass, SpawnTM, SpawnParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取插槽socket位置"><a href="#获取插槽socket位置" class="headerlink" title="获取插槽socket位置"></a>获取插槽socket位置</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FVector HandLocation = <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">GetSocketLocation</span>(<span class="string">&quot;Muzzle&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="添加并使用径向力组件"><a href="#添加并使用径向力组件" class="headerlink" title="添加并使用径向力组件"></a>添加并使用径向力组件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyActor.h</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURGAME_API</span> AMyActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyActor</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Effects&quot;</span>)</span><br><span class="line">    URadialForceComponent* RadialForce;<span class="comment">//径向力组件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyActor.cpp</span></span><br><span class="line">AMyActor::<span class="built_in">AMyActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    RadialForce = <span class="built_in">CreateDefaultSubobject</span>&lt;URadialForceComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RadialForce&quot;</span>));</span><br><span class="line">    RadialForce-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    RadialForce-&gt;Radius = <span class="number">500.0f</span>;          <span class="comment">// 力的作用范围</span></span><br><span class="line">    RadialForce-&gt;Strength = <span class="number">1000.0f</span>;      <span class="comment">// 力的大小</span></span><br><span class="line">    RadialForce-&gt;bImpulseVelChange = <span class="literal">true</span>; <span class="comment">// 是否直接改变速度（true=瞬时速度变化）</span></span><br><span class="line">    RadialForce-&gt;bIgnoreOwningActor = <span class="literal">true</span>; <span class="comment">// 是否忽略自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要施加力的地方调用 <code>FireImpulse()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RadialForce-&gt;<span class="built_in">FireImpulse</span>(); <span class="comment">// 触发径向力</span></span><br></pre></td></tr></table></figure><p> 如果 <code>Actor</code> 数量很多，建议使用 ​<strong>​Sphere Trace​</strong>​ 或 ​<strong>​Overlap Sphere​</strong>​ 来筛选范围内的 Actor，而不是遍历所有 Actor。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">TArray&lt;FOverlapResult&gt; Overlaps;</span><br><span class="line"> FCollisionShape Sphere = FCollisionShape::<span class="built_in">MakeSphere</span>(Radius);</span><br><span class="line"> <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">OverlapMultiByChannel</span>(Overlaps, Origin, FQuat::Identity, ECC_PhysicsBody, Sphere);</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> FOverlapResult&amp; Overlap : Overlaps)</span><br><span class="line">        &#123;</span><br><span class="line">            AActor* Actor = Overlap.<span class="built_in">GetActor</span>();</span><br><span class="line">            <span class="keyword">if</span> (Actor)</span><br><span class="line">  &#123;</span><br><span class="line">                <span class="comment">// 施加力...</span></span><br><span class="line">  &#125;</span><br><span class="line">   &#125;  ```</span><br><span class="line"></span><br><span class="line">## 射线检测</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">USInteractionComponent::PrimaryInteract</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FCollisionObjectQueryParams ObjectQueryParams;</span><br><span class="line">    ObjectQueryParams.<span class="built_in">AddObjectTypesToQuery</span>(ECC_WorldDynamic);</span><br><span class="line"></span><br><span class="line">    AActor* MyOwner = <span class="built_in">GetOwner</span>();</span><br><span class="line"></span><br><span class="line">    FVector EyeLocation;</span><br><span class="line">    FRotator EyeRotation;</span><br><span class="line">    MyOwner-&gt;<span class="built_in">GetActorEyesViewPoint</span>(EyeLocation, EyeRotation);</span><br><span class="line"></span><br><span class="line">    FVector End = EyeLocation + (EyeRotation.<span class="built_in">Vector</span>() * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    FHitResult Hit;</span><br><span class="line">    <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByObjectType</span>(Hit, EyeLocation, End, ObjectQueryParams);</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">`FHitResult` 结构体（射线检测 `Hit` 的返回结果）保存了多种数据类型，用于描述碰撞检测的详细信息。以下是 `FHitResult` 中包含的主要数据类型及其用途：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### ​**​<span class="number">1.</span> 碰撞位置与方向​**​</span><br><span class="line"></span><br><span class="line">|数据类型|成员变量|说明|</span><br><span class="line">|---|---|---|</span><br><span class="line">|​**​`FVector`​**​|`ImpactPoint`|碰撞发生的精确位置（世界坐标系）。|</span><br><span class="line">|​**​`FVector`​**​|`Location`|与 `ImpactPoint` 类似，但可能因碰撞规则不同（如射线起点偏移）。|</span><br><span class="line">|​**​`FVector`​**​|`Normal`|碰撞表面的法线方向（单位向量）。|</span><br><span class="line">|​**​`FVector`​**​|`TraceStart` / `TraceEnd`|射线检测的起点和终点（需手动记录，`FHitResult` 本身不存储）。|</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### ​**​<span class="number">2.</span> 碰撞对象信息​**​</span><br><span class="line"></span><br><span class="line">|数据类型|成员变量|说明|</span><br><span class="line">|---|---|---|</span><br><span class="line">|​**​`AActor*`​**​|`Actor`|被碰撞的 Actor 对象指针。|</span><br><span class="line">|​**​`UPrimitiveComponent*`​**​|`Component`|被碰撞的组件（如静态网格体、骨骼网格体等）。|</span><br><span class="line">|​**​`FName`​**​|`BoneName`|如果碰撞的是骨骼网格体，返回命中的骨骼名称。|</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### ​**​<span class="number">3.</span> 物理与材质信息​**​</span><br><span class="line"></span><br><span class="line">|数据类型|成员变量|说明|</span><br><span class="line">|---|---|---|</span><br><span class="line">|​**​`<span class="type">float</span>`​**​|`Distance`|从射线起点到碰撞点的距离。|</span><br><span class="line">|​**​`<span class="type">float</span>`​**​|`Time`|碰撞发生的时间（通常用于运动学模拟）。|</span><br><span class="line">|​**​`UPhysicalMaterial*`​**​|`PhysMat`|碰撞表面的物理材质（如金属、木材等）。|</span><br><span class="line">|​**​`FMaterialRenderProxy*`​**​|`Material`|碰撞表面的渲染材质（用于视觉效果）。|</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### ​**​<span class="number">4.</span> 调试与扩展信息​**​</span><br><span class="line"></span><br><span class="line">|数据类型|成员变量|说明|</span><br><span class="line">|---|---|---|</span><br><span class="line">|​**​`uint8`​**​|`FaceIndex`|命中多边形的索引（适用于静态网格体）。|</span><br><span class="line">|​**​`FName`​**​|`Item`|自定义标识符（需手动设置）。|</span><br><span class="line">|​**​`FHitResult::HitFlags`​**​|`Flags`|标记碰撞类型（如是否为阻挡碰撞）。|</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### ​**​<span class="number">5.</span> 其他数据​**​</span><br><span class="line"></span><br><span class="line">|数据类型|成员变量|说明|</span><br><span class="line">|---|---|---|</span><br><span class="line">|​**​`FVector`​**​|`Impulse`|如果碰撞触发了物理响应，返回施加的冲量。|</span><br><span class="line">|​**​`FHitResult::HitGroup`​**​|`HitGroup`|命中的碰撞组（需自定义设置）。|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">射线击中后需要判断被击中类是否存在接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下是代码片段示例</span><br><span class="line">```cpp</span><br><span class="line">FHitResult Hit;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByObjectType</span>(Hit, EyeLocation, End, ObjectQueryParams))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 尝试将击中的Actor转换为实现了指定接口的类型</span></span><br><span class="line">        IMyInterface* InterfaceActor = <span class="built_in">Cast</span>&lt;IMyInterface&gt;(Hit.<span class="built_in">GetActor</span>());</span><br><span class="line">        <span class="keyword">if</span> (InterfaceActor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里表示击中的Actor实现了IMyInterface接口，可以进行相关操作</span></span><br><span class="line">            InterfaceActor-&gt;<span class="built_in">SomeInterfaceFunction</span>(); <span class="comment">// 假设接口有一个这样的函数</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>也可以这样判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">USInteractionComponent::PrimaryInteract</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FCollisionObjectQueryParams ObjectQueryParams;</span><br><span class="line">    ObjectQueryParams.<span class="built_in">AddObjectTypesToQuery</span>(ECC_WorldDynamic);</span><br><span class="line">    AActor* MyOwner = <span class="built_in">GetOwner</span>();</span><br><span class="line">    FVector EyeLocation;</span><br><span class="line">    FRotator EyeRotation;</span><br><span class="line">    MyOwner-&gt;<span class="built_in">GetActorEyesViewPoint</span>(EyeLocation, EyeRotation);</span><br><span class="line">    FVector End = EyeLocation + (EyeRotation.<span class="built_in">Vector</span>() * <span class="number">1000</span>);</span><br><span class="line">    FHitResult Hit;</span><br><span class="line">    <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByObjectType</span>(Hit, EyeLocation, End, ObjectQueryParams);</span><br><span class="line">    AActor* HitActor = Hit.<span class="built_in">GetActor</span>();</span><br><span class="line">    <span class="keyword">if</span> (HitActor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HitActor-&gt;<span class="built_in">Implements</span>&lt;ISGameplayInterface&gt;())<span class="comment">//检查被击中类是否实现接口</span></span><br><span class="line">        &#123;</span><br><span class="line">            APawn* MyPawn = <span class="built_in">Cast</span>&lt;APawn&gt;(MyOwner);</span><br><span class="line">            ISGameplayInterface::<span class="built_in">Execute_Interact</span>(HitActor, MyPawn);<span class="comment">//调用类上的接口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="球体横扫检测-SweepMultiByObjectType"><a href="#球体横扫检测-SweepMultiByObjectType" class="headerlink" title="球体横扫检测&#x3D;&#x3D;SweepMultiByObjectType&#x3D;&#x3D;"></a>球体横扫检测&#x3D;&#x3D;SweepMultiByObjectType&#x3D;&#x3D;</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TArray&lt;FHitResult&gt; Hits;</span><br><span class="line">FCollisionShape Shape;</span><br><span class="line">Shape.<span class="built_in">SetSphere</span>(<span class="number">10.0f</span>);</span><br><span class="line"><span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SweepMultiByObjectType</span>(Hits, EyeLocation, End, FQuat::Identity, objectQueryParams, Shape);</span><br></pre></td></tr></table></figure><p>可以保存一个半径为10的球体横扫碰撞到的所有数据，返回一个布尔值用于检测是否碰撞到物体。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UE5-调试-API-常用&quot;&gt;&lt;a href=&quot;#UE5-调试-API-常用&quot; class=&quot;headerlink&quot; title=&quot;UE5 调试 API-常用&quot;&gt;&lt;/a&gt;UE5 调试 API-常用&lt;/h1&gt;&lt;h2 id=&quot;基础调试输出&quot;&gt;&lt;a href=&quot;#基础调</summary>
      
    
    
    
    <category term="Unreal Engine" scheme="http://example.com/categories/Unreal-Engine/"/>
    
    <category term="C++" scheme="http://example.com/categories/Unreal-Engine/C/"/>
    
    
    <category term="UE5" scheme="http://example.com/tags/UE5/"/>
    
    <category term="调试" scheme="http://example.com/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="日志" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
